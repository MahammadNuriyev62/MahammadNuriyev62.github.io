<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelCraft - Local Multiplayer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 14px;
            pointer-events: auto;
            max-width: 400px;
        }

        #hud h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 18px;
        }

        #hud p {
            margin: 5px 0;
            line-height: 1.5;
        }

        #blockSelector {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            pointer-events: auto;
        }

        .blockOption {
            width: 50px;
            height: 50px;
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 5px;
            transition: all 0.2s;
            position: relative;
        }

        .blockOption:hover {
            transform: scale(1.1);
            border-color: #00d4ff;
        }

        .blockOption.selected {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .blockOption span {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: #00ff88;
        }

        #menuScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }

        #menuScreen.hidden {
            display: none;
        }

        #menuScreen h1 {
            font-size: 72px;
            color: #00ff88;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        #menuScreen h2 {
            font-size: 24px;
            color: #00d4ff;
            margin-bottom: 40px;
        }

        .menuButton {
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: transparent;
            color: #00ff88;
            border: 2px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            min-width: 300px;
        }

        .menuButton:hover {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        #roomIdInput {
            padding: 15px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            border: 2px solid #00ff88;
            border-radius: 5px;
            margin: 10px;
            min-width: 300px;
            text-align: center;
        }

        #connectionStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 14px;
            pointer-events: none;
        }

        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            background: #ff0000;
        }

        .status-dot.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00d4ff;
            font-size: 12px;
            max-width: 250px;
            pointer-events: none;
        }

        #instructions h4 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        #instructions p {
            margin: 5px 0;
            line-height: 1.4;
        }

        #fpsCounter {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 14px;
            pointer-events: none;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>

        <div id="ui">
            <div id="crosshair"></div>

            <div id="hud">
                <h3>VoxelCraft</h3>
                <p>Position: <span id="position">0, 0, 0</span></p>
                <p>Players Online: <span id="playerCount">1</span></p>
                <p>Room: <span id="roomDisplay">Solo</span></p>
            </div>

            <div id="fpsCounter">FPS: <span id="fps">60</span></div>

            <div id="connectionStatus">
                <span class="status-dot"></span>
                <span id="statusText">Offline</span>
            </div>

            <div id="blockSelector">
                <div class="blockOption selected" data-block="grass" style="background: linear-gradient(to bottom, #7cfc00 0%, #228b22 100%);">
                    <span>1</span>
                </div>
                <div class="blockOption" data-block="dirt" style="background: #8b4513;">
                    <span>2</span>
                </div>
                <div class="blockOption" data-block="stone" style="background: #808080;">
                    <span>3</span>
                </div>
                <div class="blockOption" data-block="wood" style="background: #8b4513;">
                    <span>4</span>
                </div>
                <div class="blockOption" data-block="leaf" style="background: #228b22;">
                    <span>5</span>
                </div>
                <div class="blockOption" data-block="sand" style="background: #f4a460;">
                    <span>6</span>
                </div>
                <div class="blockOption" data-block="water" style="background: #1e90ff;">
                    <span>7</span>
                </div>
            </div>

            <div id="instructions">
                <h4>Controls:</h4>
                <p>WASD - Move</p>
                <p>Space - Jump</p>
                <p>Mouse - Look</p>
                <p>Left Click - Break</p>
                <p>Right Click - Place</p>
                <p>1-7 - Select Block</p>
                <p>ESC - Menu</p>
            </div>
        </div>

        <div id="menuScreen">
            <h1>VoxelCraft</h1>
            <h2>Local Multiplayer Voxel Game</h2>
            <button class="menuButton" id="singlePlayerBtn">Single Player</button>
            <button class="menuButton" id="hostGameBtn">Host Game</button>
            <input type="text" id="roomIdInput" placeholder="Enter Room ID to Join" style="display: none;">
            <button class="menuButton" id="joinGameBtn">Join Game</button>
            <div style="margin-top: 30px; padding: 20px; background: rgba(0, 255, 136, 0.1); border: 2px solid #00ff88; border-radius: 10px; max-width: 500px;">
                <p style="color: #00ff88; font-size: 14px;">üåê Local Multiplayer: Share your Room ID with friends on the same WiFi network!</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // Game Configuration
        const CHUNK_SIZE = 16;
        const WORLD_SIZE = 3;
        const BLOCK_SIZE = 1;
        const GRAVITY = 20;
        const JUMP_FORCE = 8;
        const MOVE_SPEED = 5;
        const MOUSE_SENSITIVITY = 0.002;
        const RENDER_DISTANCE = 100;

        // Block Types
        const BLOCK_TYPES = {
            air: 0,
            grass: 1,
            dirt: 2,
            stone: 3,
            wood: 4,
            leaf: 5,
            sand: 6,
            water: 7
        };

        const BLOCK_COLORS = {
            1: [0.48, 0.98, 0.00], // grass
            2: [0.54, 0.27, 0.07], // dirt
            3: [0.50, 0.50, 0.50], // stone
            4: [0.54, 0.27, 0.07], // wood
            5: [0.13, 0.54, 0.13], // leaf
            6: [0.95, 0.64, 0.37], // sand
            7: [0.11, 0.56, 1.00]  // water
        };

        // Game State
        let scene, camera, renderer, canvas;
        let worldData = {}; // Sparse array for block data
        let chunks = {}; // Chunk meshes
        let players = {};
        let currentPlayer;
        let selectedBlock = BLOCK_TYPES.grass;
        let isPointerLocked = false;
        let keys = {};
        let velocity = { x: 0, y: 0, z: 0 };
        let canJump = false;

        // Networking
        let peer;
        let connections = [];
        let isHost = false;
        let myPlayerId;
        let roomId;
        let lastNetworkUpdate = 0;
        const NETWORK_UPDATE_INTERVAL = 50; // ms

        // FPS Counter
        let frameCount = 0;
        let lastFpsUpdate = performance.now();

        // Initialize Three.js
        function initThree() {
            canvas = document.getElementById('canvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, RENDER_DISTANCE);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, RENDER_DISTANCE);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Initialize current player
            currentPlayer = {
                position: { x: 8, y: 25, z: 8 },
                rotation: { x: 0, y: 0 },
                id: myPlayerId,
                mesh: null
            };

            camera.position.set(currentPlayer.position.x, currentPlayer.position.y, currentPlayer.position.z);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('blur', clearKeys);
        }

        function clearKeys() {
            keys = {};
        }

        // Chunk functions
        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }

        function worldToChunk(x, z) {
            return {
                chunkX: Math.floor(x / CHUNK_SIZE),
                chunkZ: Math.floor(z / CHUNK_SIZE)
            };
        }

        // Generate World with optimized chunk-based rendering
        function generateWorld() {
            const startX = -Math.floor(WORLD_SIZE / 2);
            const startZ = -Math.floor(WORLD_SIZE / 2);

            for (let cx = 0; cx < WORLD_SIZE; cx++) {
                for (let cz = 0; cz < WORLD_SIZE; cz++) {
                    generateChunkData(startX + cx, startZ + cz);
                }
            }

            // Build all chunk meshes
            rebuildAllChunks();
        }

        function generateChunkData(chunkX, chunkZ) {
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldZ = chunkZ * CHUNK_SIZE + z;

                    // Simple terrain generation
                    const height = Math.floor(
                        Math.sin(worldX * 0.1) * 3 +
                        Math.cos(worldZ * 0.1) * 3 +
                        Math.sin(worldX * 0.05) * Math.cos(worldZ * 0.05) * 5 +
                        10
                    );

                    // Generate terrain layers
                    for (let y = 0; y <= height; y++) {
                        let blockType;
                        if (y === height) {
                            blockType = BLOCK_TYPES.grass;
                        } else if (y >= height - 3) {
                            blockType = BLOCK_TYPES.dirt;
                        } else {
                            blockType = BLOCK_TYPES.stone;
                        }
                        setBlockData(worldX, y, worldZ, blockType);
                    }

                    // Add some trees
                    if (Math.random() > 0.97 && height > 8) {
                        generateTreeData(worldX, height + 1, worldZ);
                    }
                }
            }
        }

        function generateTreeData(x, y, z) {
            // Trunk
            for (let i = 0; i < 5; i++) {
                setBlockData(x, y + i, z, BLOCK_TYPES.wood);
            }

            // Leaves
            for (let dx = -2; dx <= 2; dx++) {
                for (let dy = 3; dy <= 6; dy++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;
                        if (dy === 6 && (Math.abs(dx) > 1 || Math.abs(dz) > 1)) continue;
                        setBlockData(x + dx, y + dy, z + dz, BLOCK_TYPES.leaf);
                    }
                }
            }
        }

        function getBlockKey(x, y, z) {
            return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        }

        function setBlockData(x, y, z, type) {
            const key = getBlockKey(x, y, z);
            if (type === BLOCK_TYPES.air) {
                delete worldData[key];
            } else {
                worldData[key] = type;
            }
        }

        function getBlockData(x, y, z) {
            const key = getBlockKey(x, y, z);
            return worldData[key] || BLOCK_TYPES.air;
        }

        function setBlock(x, y, z, type) {
            setBlockData(x, y, z, type);

            // Rebuild affected chunks
            const { chunkX, chunkZ } = worldToChunk(x, z);
            rebuildChunk(chunkX, chunkZ);

            // Also rebuild adjacent chunks if block is on edge
            const localX = x - chunkX * CHUNK_SIZE;
            const localZ = z - chunkZ * CHUNK_SIZE;

            if (localX === 0) rebuildChunk(chunkX - 1, chunkZ);
            if (localX === CHUNK_SIZE - 1) rebuildChunk(chunkX + 1, chunkZ);
            if (localZ === 0) rebuildChunk(chunkX, chunkZ - 1);
            if (localZ === CHUNK_SIZE - 1) rebuildChunk(chunkX, chunkZ + 1);
        }

        function rebuildAllChunks() {
            const startX = -Math.floor(WORLD_SIZE / 2);
            const startZ = -Math.floor(WORLD_SIZE / 2);

            for (let cx = 0; cx < WORLD_SIZE; cx++) {
                for (let cz = 0; cz < WORLD_SIZE; cz++) {
                    rebuildChunk(startX + cx, startZ + cz);
                }
            }
        }

        function rebuildChunk(chunkX, chunkZ) {
            const key = getChunkKey(chunkX, chunkZ);

            // Remove old mesh
            if (chunks[key]) {
                scene.remove(chunks[key]);
                chunks[key].geometry.dispose();
                chunks[key].material.dispose();
                delete chunks[key];
            }

            // Build new mesh with face culling
            const geometry = buildChunkGeometry(chunkX, chunkZ);
            if (geometry) {
                const material = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    side: THREE.FrontSide
                });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                chunks[key] = mesh;
            }
        }

        function buildChunkGeometry(chunkX, chunkZ) {
            const positions = [];
            const colors = [];
            const normals = [];

            const startX = chunkX * CHUNK_SIZE;
            const startZ = chunkZ * CHUNK_SIZE;

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let y = 0; y < 30; y++) { // Height limit
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const worldX = startX + x;
                        const worldZ = startZ + z;
                        const blockType = getBlockData(worldX, y, worldZ);

                        if (blockType === BLOCK_TYPES.air) continue;

                        const color = BLOCK_COLORS[blockType];

                        // Check each face and only add if exposed
                        addBlockFaces(worldX, y, worldZ, blockType, positions, colors, normals, color);
                    }
                }
            }

            if (positions.length === 0) return null;

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

            return geometry;
        }

        function addBlockFaces(x, y, z, blockType, positions, colors, normals, color) {
            // Check each face
            const faces = [
                { dir: [0, 1, 0], corners: [[0,1,0],[1,1,0],[1,1,1],[0,1,1]] }, // top
                { dir: [0, -1, 0], corners: [[0,0,0],[0,0,1],[1,0,1],[1,0,0]] }, // bottom
                { dir: [1, 0, 0], corners: [[1,0,0],[1,0,1],[1,1,1],[1,1,0]] }, // right
                { dir: [-1, 0, 0], corners: [[0,0,0],[0,1,0],[0,1,1],[0,0,1]] }, // left
                { dir: [0, 0, 1], corners: [[0,0,1],[0,1,1],[1,1,1],[1,0,1]] }, // front
                { dir: [0, 0, -1], corners: [[0,0,0],[1,0,0],[1,1,0],[0,1,0]] }  // back
            ];

            faces.forEach(face => {
                const [dx, dy, dz] = face.dir;
                const neighborType = getBlockData(x + dx, y + dy, z + dz);

                // Only render face if neighbor is air or transparent
                if (neighborType === BLOCK_TYPES.air) {
                    const corners = face.corners;

                    // Create two triangles for the face
                    const v0 = [x + corners[0][0], y + corners[0][1], z + corners[0][2]];
                    const v1 = [x + corners[1][0], y + corners[1][1], z + corners[1][2]];
                    const v2 = [x + corners[2][0], y + corners[2][1], z + corners[2][2]];
                    const v3 = [x + corners[3][0], y + corners[3][1], z + corners[3][2]];

                    // Triangle 1
                    positions.push(...v0, ...v1, ...v2);
                    // Triangle 2
                    positions.push(...v0, ...v2, ...v3);

                    // Colors and normals
                    for (let i = 0; i < 6; i++) {
                        colors.push(...color);
                        normals.push(dx, dy, dz);
                    }
                }
            });
        }

        // Player Controls
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;

                // Block selection with number keys
                if (e.code >= 'Digit1' && e.code <= 'Digit7') {
                    const index = parseInt(e.code.replace('Digit', '')) - 1;
                    const blockOptions = document.querySelectorAll('.blockOption');
                    if (blockOptions[index]) {
                        blockOptions.forEach(opt => opt.classList.remove('selected'));
                        blockOptions[index].classList.add('selected');
                        selectedBlock = BLOCK_TYPES[blockOptions[index].dataset.block];
                    }
                }

                // ESC to unlock pointer
                if (e.code === 'Escape' && isPointerLocked) {
                    document.exitPointerLock();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            document.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mousedown', onMouseDown);
            document.addEventListener('contextmenu', (e) => {
                if (isPointerLocked) e.preventDefault();
            });

            // Pointer lock
            canvas.addEventListener('click', () => {
                if (!isPointerLocked && document.getElementById('menuScreen').classList.contains('hidden')) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                const wasLocked = isPointerLocked;
                isPointerLocked = document.pointerLockElement === canvas;

                if (!isPointerLocked && wasLocked) {
                    document.getElementById('menuScreen').classList.remove('hidden');
                }
            });

            // Block selector clicks
            document.querySelectorAll('.blockOption').forEach(option => {
                option.addEventListener('click', (e) => {
                    document.querySelectorAll('.blockOption').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    selectedBlock = BLOCK_TYPES[option.dataset.block];
                });
            });
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            currentPlayer.rotation.y -= event.movementX * MOUSE_SENSITIVITY;
            currentPlayer.rotation.x -= event.movementY * MOUSE_SENSITIVITY;
            currentPlayer.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, currentPlayer.rotation.x));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = currentPlayer.rotation.y;
            camera.rotation.x = currentPlayer.rotation.x;
        }

        let lastClickTime = 0;
        const CLICK_COOLDOWN = 200; // ms

        function onMouseDown(event) {
            if (!isPointerLocked) return;

            const now = performance.now();
            if (now - lastClickTime < CLICK_COOLDOWN) return;
            lastClickTime = now;

            const result = raycast();
            if (!result) return;

            if (event.button === 0) { // Left click - break block
                breakBlock(result.point.x, result.point.y, result.point.z);
            } else if (event.button === 2) { // Right click - place block
                placeBlock(result.point.x, result.point.y, result.point.z, result.normal);
            }
        }

        function raycast() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Only raycast against chunk meshes
            const chunkMeshes = Object.values(chunks);
            const intersects = raycaster.intersectObjects(chunkMeshes);

            if (intersects.length > 0 && intersects[0].distance < 5) {
                return {
                    point: intersects[0].point,
                    normal: intersects[0].face.normal,
                    object: intersects[0].object
                };
            }
            return null;
        }

        function breakBlock(x, y, z) {
            const bx = Math.floor(x - (x < 0 ? 1 : 0));
            const by = Math.floor(y - (y < 0 ? 1 : 0));
            const bz = Math.floor(z - (z < 0 ? 1 : 0));

            if (getBlockData(bx, by, bz) !== BLOCK_TYPES.air) {
                setBlock(bx, by, bz, BLOCK_TYPES.air);
                broadcastBlockUpdate(bx, by, bz, BLOCK_TYPES.air);
            }
        }

        function placeBlock(x, y, z, normal) {
            const bx = Math.floor(x + normal.x * 0.5);
            const by = Math.floor(y + normal.y * 0.5);
            const bz = Math.floor(z + normal.z * 0.5);

            // Don't place block where player is
            const px = Math.floor(currentPlayer.position.x);
            const py = Math.floor(currentPlayer.position.y);
            const pyFloor = Math.floor(currentPlayer.position.y - 1.5);
            const pz = Math.floor(currentPlayer.position.z);

            if ((bx === px && by === py && bz === pz) ||
                (bx === px && by === pyFloor && bz === pz)) {
                return;
            }

            if (getBlockData(bx, by, bz) === BLOCK_TYPES.air) {
                setBlock(bx, by, bz, selectedBlock);
                broadcastBlockUpdate(bx, by, bz, selectedBlock);
            }
        }

        // Optimized Physics
        function updatePhysics(deltaTime) {
            const moveX = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
            const moveZ = (keys['KeyS'] ? 1 : 0) - (keys['KeyW'] ? 1 : 0);

            // Calculate movement direction
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), currentPlayer.rotation.y);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), currentPlayer.rotation.y);

            velocity.x = (forward.x * moveZ + right.x * moveX) * MOVE_SPEED;
            velocity.z = (forward.z * moveZ + right.z * moveX) * MOVE_SPEED;

            // Apply gravity
            velocity.y -= GRAVITY * deltaTime;

            // Jump
            if (keys['Space'] && canJump) {
                velocity.y = JUMP_FORCE;
                canJump = false;
            }

            // Update position with collision detection
            applyPhysicsAndCollision(deltaTime);

            // Update camera position
            camera.position.set(currentPlayer.position.x, currentPlayer.position.y, currentPlayer.position.z);

            // Update HUD
            document.getElementById('position').textContent =
                `${Math.floor(currentPlayer.position.x)}, ${Math.floor(currentPlayer.position.y)}, ${Math.floor(currentPlayer.position.z)}`;

            // Throttled network update
            const now = performance.now();
            if (now - lastNetworkUpdate > NETWORK_UPDATE_INTERVAL) {
                broadcastPlayerUpdate();
                lastNetworkUpdate = now;
            }
        }

        function applyPhysicsAndCollision(deltaTime) {
            // X axis
            let newX = currentPlayer.position.x + velocity.x * deltaTime;
            if (!checkCollision(newX, currentPlayer.position.y, currentPlayer.position.z)) {
                currentPlayer.position.x = newX;
            } else {
                velocity.x = 0;
            }

            // Y axis
            let newY = currentPlayer.position.y + velocity.y * deltaTime;
            if (!checkCollision(currentPlayer.position.x, newY, currentPlayer.position.z)) {
                currentPlayer.position.y = newY;
                canJump = false;
            } else {
                if (velocity.y < 0) {
                    canJump = true;
                    currentPlayer.position.y = Math.floor(currentPlayer.position.y - 1.5) + 1.5;
                }
                velocity.y = 0;
            }

            // Z axis
            let newZ = currentPlayer.position.z + velocity.z * deltaTime;
            if (!checkCollision(currentPlayer.position.x, currentPlayer.position.y, newZ)) {
                currentPlayer.position.z = newZ;
            } else {
                velocity.z = 0;
            }
        }

        function checkCollision(x, y, z) {
            // Check blocks around player position
            const minX = Math.floor(x - 0.3);
            const maxX = Math.floor(x + 0.3);
            const minY = Math.floor(y - 1.5);
            const maxY = Math.floor(y + 0.3);
            const minZ = Math.floor(z - 0.3);
            const maxZ = Math.floor(z + 0.3);

            for (let bx = minX; bx <= maxX; bx++) {
                for (let by = minY; by <= maxY; by++) {
                    for (let bz = minZ; bz <= maxZ; bz++) {
                        if (getBlockData(bx, by, bz) !== BLOCK_TYPES.air) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Render other players
        function updateOtherPlayers() {
            Object.entries(players).forEach(([id, player]) => {
                if (id === myPlayerId) return;

                if (!player.mesh) {
                    // Create player representation
                    const geometry = new THREE.BoxGeometry(0.6, 1.8, 0.6);
                    const material = new THREE.MeshLambertMaterial({
                        color: player.color || Math.random() * 0xffffff
                    });
                    player.mesh = new THREE.Mesh(geometry, material);
                    scene.add(player.mesh);
                }

                player.mesh.position.set(player.position.x, player.position.y - 0.9, player.position.z);
            });
        }

        // Networking Functions
        function initNetworking() {
            myPlayerId = 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function hostGame() {
            peer = new Peer(myPlayerId);

            peer.on('open', (id) => {
                roomId = id;
                isHost = true;
                document.getElementById('roomDisplay').textContent = roomId.substring(0, 8) + '...';
                updateConnectionStatus('Hosting', true);

                alert(`Room ID: ${roomId}\nShare this ID with friends to join!`);
            });

            peer.on('connection', (conn) => {
                connections.push(conn);
                setupConnection(conn);
            });

            startGame();
        }

        function joinGame(roomIdToJoin) {
            myPlayerId = 'player_' + Math.random().toString(36).substr(2, 9);
            peer = new Peer(myPlayerId);

            peer.on('open', () => {
                const conn = peer.connect(roomIdToJoin);
                connections.push(conn);
                setupConnection(conn);
                roomId = roomIdToJoin;
                document.getElementById('roomDisplay').textContent = 'Joined';
                startGame();
            });
        }

        function setupConnection(conn) {
            conn.on('open', () => {
                updateConnectionStatus('Connected', true);
                updatePlayerCount();

                // Send initial world state if host
                if (isHost) {
                    conn.send({ type: 'worldState', data: worldData });
                }
            });

            conn.on('data', (data) => {
                handleNetworkMessage(data, conn);
            });

            conn.on('close', () => {
                connections = connections.filter(c => c !== conn);
                updatePlayerCount();

                // Remove player mesh
                Object.entries(players).forEach(([id, player]) => {
                    if (player.mesh && connections.length === 0) {
                        scene.remove(player.mesh);
                        delete players[id];
                    }
                });
            });
        }

        function handleNetworkMessage(data, conn) {
            switch (data.type) {
                case 'worldState':
                    // Load world state from host
                    worldData = data.data;
                    rebuildAllChunks();
                    break;

                case 'playerUpdate':
                    if (!players[data.playerId]) {
                        players[data.playerId] = {
                            position: {},
                            rotation: {},
                            color: Math.random() * 0xffffff
                        };
                    }
                    players[data.playerId].position = data.position;
                    players[data.playerId].rotation = data.rotation;
                    break;

                case 'blockUpdate':
                    setBlock(data.x, data.y, data.z, data.blockType);
                    // Relay to other players if host
                    if (isHost) {
                        connections.forEach(c => {
                            if (c !== conn && c.open) {
                                c.send(data);
                            }
                        });
                    }
                    break;
            }
        }

        function broadcastPlayerUpdate() {
            if (connections.length === 0) return;

            const message = {
                type: 'playerUpdate',
                playerId: myPlayerId,
                position: currentPlayer.position,
                rotation: currentPlayer.rotation
            };

            connections.forEach(conn => {
                if (conn.open) {
                    try {
                        conn.send(message);
                    } catch (e) {
                        console.error('Failed to send player update:', e);
                    }
                }
            });
        }

        function broadcastBlockUpdate(x, y, z, blockType) {
            if (connections.length === 0) return;

            const message = {
                type: 'blockUpdate',
                x, y, z, blockType
            };

            connections.forEach(conn => {
                if (conn.open) {
                    try {
                        conn.send(message);
                    } catch (e) {
                        console.error('Failed to send block update:', e);
                    }
                }
            });
        }

        function updateConnectionStatus(status, connected) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.getElementById('statusText');

            statusText.textContent = status;
            if (connected) {
                statusDot.classList.add('connected');
            } else {
                statusDot.classList.remove('connected');
            }
        }

        function updatePlayerCount() {
            const count = connections.filter(c => c.open).length + 1;
            document.getElementById('playerCount').textContent = count;
        }

        // Game Loop
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); // Cap delta time
            lastTime = currentTime;

            if (isPointerLocked) {
                updatePhysics(deltaTime);
                updateOtherPlayers();
            }

            renderer.render(scene, camera);

            // Update FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            document.getElementById('menuScreen').classList.add('hidden');
            setTimeout(() => {
                canvas.requestPointerLock();
            }, 100);
        }

        // Menu Events
        document.getElementById('singlePlayerBtn').addEventListener('click', () => {
            initNetworking();
            updateConnectionStatus('Offline', false);
            startGame();
        });

        document.getElementById('hostGameBtn').addEventListener('click', () => {
            initNetworking();
            hostGame();
        });

        document.getElementById('joinGameBtn').addEventListener('click', () => {
            const input = document.getElementById('roomIdInput');
            if (input.style.display === 'none') {
                input.style.display = 'block';
                input.focus();
            } else {
                const roomId = input.value.trim();
                if (roomId) {
                    joinGame(roomId);
                } else {
                    alert('Please enter a Room ID!');
                }
            }
        });

        // Initialize Game
        initNetworking();
        initThree();
        generateWorld();
        setupControls();
        animate();

        console.log('VoxelCraft initialized! Optimized with chunk-based rendering and face culling.');
    </script>
</body>
</html>
