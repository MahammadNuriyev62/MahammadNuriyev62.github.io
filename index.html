<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahammad Nuriyev | Computational Research</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&family=Inter:wght@300;400;600;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ff88;
            --primary-dim: #00cc6e;
            --secondary: #00d4ff;
            --accent: #ff0080;
            --bg-dark: #0a0e1a;
            --bg-darker: #050810;
            --bg-card: rgba(15, 23, 42, 0.8);
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-dim: #64748b;
            --border: rgba(0, 255, 136, 0.2);
            --glow: rgba(0, 255, 136, 0.4);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-darker);
            color: var(--text-primary);
            line-height: 1.7;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* Background Effects */
        .bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.12;
            pointer-events: none;
        }

        .bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: radial-gradient(circle at 20% 50%, rgba(0, 255, 136, 0.08) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(0, 212, 255, 0.08) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Main Container */
        .container {
            position: relative;
            z-index: 10;
            max-width: 1280px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Header */
        header {
            padding: 2rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            text-decoration: none;
            letter-spacing: -0.02em;
        }

        .logo::before {
            content: '{ ';
            color: var(--secondary);
        }

        .logo::after {
            content: ' }';
            color: var(--secondary);
        }

        nav {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        nav a {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.3s ease;
        }

        nav a:hover {
            color: var(--primary);
        }

        .nav-games-btn {
            display: inline-block;
            padding: 0.6rem 1.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            border: 2px solid var(--primary);
            background: transparent;
            color: var(--primary);
            text-decoration: none;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
        }

        .nav-games-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary);
            transition: left 0.3s ease;
            z-index: -1;
        }

        .nav-games-btn:hover {
            color: var(--bg-darker);
            box-shadow: 0 0 30px var(--glow);
        }

        .nav-games-btn:hover::before {
            left: 0;
        }

        /* Hero Section */
        .hero {
            min-height: 85vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 4rem 2rem;
            position: relative;
        }

        /* 3D Cube */
        .cube-scene {
            perspective: 1200px;
            width: 240px;
            height: 240px;
            margin: 0 auto 3rem;
            cursor: grab;
            position: relative;
        }

        .cube-scene:active {
            cursor: grabbing;
        }

        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            animation: floatCube 20s infinite linear;
        }

        .cube.dragging {
            animation: none;
            transition: none;
        }

        .cube.auto-rotate {
            animation: floatCube 20s infinite linear;
        }

        @keyframes floatCube {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        .cube-face {
            position: absolute;
            width: 240px;
            height: 240px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 212, 255, 0.05) 100%);
            border: 2px solid var(--border);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 0 0 30px var(--glow);
        }

        .cube-face.front  { transform: translateZ(120px); }
        .cube-face.back   { transform: translateZ(-120px) rotateY(180deg); }
        .cube-face.right  { transform: rotateY(90deg) translateZ(120px); }
        .cube-face.left   { transform: rotateY(-90deg) translateZ(120px); }
        .cube-face.top    { transform: rotateX(90deg) translateZ(120px); }
        .cube-face.bottom { transform: rotateX(-90deg) translateZ(120px); }

        .hero h1 {
            font-size: clamp(2.5rem, 8vw, 6rem);
            font-weight: 900;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.03em;
            line-height: 1.1;
        }

        .hero .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: clamp(1rem, 2vw, 1.3rem);
            color: var(--text-secondary);
            margin-bottom: 3rem;
            font-weight: 400;
        }

        .cta-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 1rem 2rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            font-weight: 600;
            border: 2px solid var(--primary);
            background: transparent;
            color: var(--primary);
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary);
            transition: left 0.3s ease;
            z-index: -1;
        }

        .btn:hover {
            color: var(--bg-darker);
            box-shadow: 0 0 40px var(--glow);
        }

        .btn:hover::before {
            left: 0;
        }

        .btn.secondary {
            border-color: var(--secondary);
            color: var(--secondary);
        }

        .btn.secondary::before {
            background: var(--secondary);
        }

        /* Warning Box */
        .warning {
            max-width: 900px;
            margin: 4rem auto;
            padding: 2rem;
            background: rgba(255, 180, 0, 0.05);
            border: 2px solid rgba(255, 180, 0, 0.3);
            border-left: 5px solid #ffb400;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .warning::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #ffb400, transparent);
            animation: warningGlow 2s ease-in-out infinite;
        }

        @keyframes warningGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .warning-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .warning-icon {
            font-size: 2rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        .warning-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: #ffb400;
            letter-spacing: 0.05em;
        }

        .warning-content {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .warning-content strong {
            color: #ffb400;
        }

        /* Section */
        section {
            padding: 6rem 0;
        }

        .section-header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .section-title {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }

        .section-subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto;
        }

        /* Stats Grid */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 4rem 0;
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 2rem;
            text-align: center;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            animation: scan 3s linear infinite;
        }

        @keyframes scan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-card:hover {
            border-color: var(--primary);
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.2);
        }

        .stat-number {
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        /* Content Card */
        .content-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 3rem;
            margin: 3rem 0;
            backdrop-filter: blur(20px);
            transition: border-color 0.3s ease;
        }

        .content-card:hover {
            border-color: var(--primary);
        }

        .card-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .card-title::before {
            content: '// ';
            color: var(--text-dim);
        }

        /* Blog Grid */
        .blog-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
        }

        .article-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 2.5rem;
            backdrop-filter: blur(20px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
        }

        .article-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }

        .article-card:hover {
            transform: translateY(-10px);
            border-color: var(--primary);
            box-shadow: 0 20px 60px rgba(0, 255, 136, 0.15);
        }

        .article-card:hover::after {
            transform: scaleX(1);
        }

        .article-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 1rem;
            display: inline-block;
        }

        .article-date::before {
            content: '[';
            color: var(--text-dim);
        }

        .article-date::after {
            content: ']';
            color: var(--text-dim);
        }

        .article-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--text-primary);
            line-height: 1.3;
        }

        .article-excerpt {
            color: var(--text-secondary);
            line-height: 1.7;
            margin-bottom: 1.5rem;
        }

        .article-link {
            font-family: 'JetBrains Mono', monospace;
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: gap 0.3s ease;
        }

        .article-link::after {
            content: '→';
            transition: transform 0.3s ease;
        }

        .article-link:hover {
            gap: 1rem;
        }

        .article-link:hover::after {
            transform: translateX(5px);
        }

        /* Footer */
        footer {
            border-top: 1px solid var(--border);
            padding: 3rem 0;
            text-align: center;
            margin-top: 6rem;
        }

        .footer-content {
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .footer-status {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--primary);
            border-radius: 50%;
            margin-right: 0.5rem;
            box-shadow: 0 0 10px var(--glow);
            animation: pulse 2s ease-in-out infinite;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero {
                min-height: auto;
                padding: 3rem 1rem;
            }

            .cube-scene {
                width: 180px;
                height: 180px;
            }

            .cube-face {
                width: 180px;
                height: 180px;
                font-size: 2rem;
            }

            .cube-face.front,
            .cube-face.back,
            .cube-face.right,
            .cube-face.left,
            .cube-face.top,
            .cube-face.bottom {
                transform: none;
            }

            .cube-face.front  { transform: translateZ(90px); }
            .cube-face.back   { transform: translateZ(-90px) rotateY(180deg); }
            .cube-face.right  { transform: rotateY(90deg) translateZ(90px); }
            .cube-face.left   { transform: rotateY(-90deg) translateZ(90px); }
            .cube-face.top    { transform: rotateX(90deg) translateZ(90px); }
            .cube-face.bottom { transform: rotateX(-90deg) translateZ(90px); }

            nav a:not(.nav-games-btn) {
                display: none;
            }

            .blog-grid {
                grid-template-columns: 1fr;
            }

            .cta-group {
                flex-direction: column;
            }

            section {
                padding: 4rem 0;
            }
        }

        /* Smooth Scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Selection */
        ::selection {
            background: var(--primary);
            color: var(--bg-darker);
        }
    </style>
</head>
<body>
    <!-- Background Effects -->
    <div class="bg-gradient"></div>
    <canvas class="bg-canvas" id="matrix-canvas"></canvas>
    <canvas class="bg-canvas" id="neural-canvas"></canvas>

    <!-- Header -->
    <div class="container">
        <header>
            <a href="#" class="logo">MN</a>
            <nav>
                <a href="#research">Research</a>
                <a href="#publications">Publications</a>
                <a href="games.html" class="nav-games-btn">Games</a>
            </nav>
        </header>
    </div>

    <!-- Hero -->
    <section class="hero">
        <div class="cube-scene">
            <div class="cube">
                <div class="cube-face front">ML</div>
                <div class="cube-face back">AI</div>
                <div class="cube-face right">CS</div>
                <div class="cube-face left">∇</div>
                <div class="cube-face top">Σ</div>
                <div class="cube-face bottom">∫</div>
            </div>
        </div>

        <h1>Mahammad Nuriyev</h1>
        <p class="subtitle">Exploring Computational Complexity & Information Theory</p>

        <div class="cta-group">
            <a href="games.html" class="btn">Browse Games</a>
            <a href="#publications" class="btn secondary">View Research</a>
        </div>
    </section>

    <!-- Warning -->
    <div class="container">
        <div class="warning">
            <div class="warning-header">
                <span class="warning-icon">⚠️</span>
                <h3 class="warning-title">DISCLAIMER</h3>
            </div>
            <div class="warning-content">
                <strong>Important Notice:</strong> The content and information presented on this website may contain inaccuracies, errors, or outdated information. Articles are generated for educational and exploratory purposes. Always verify critical information from authoritative academic sources before relying on it for research, implementation, or decision-making.
            </div>
        </div>
    </div>

    <!-- Stats -->
    <div class="container">
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number">∞</div>
                <div class="stat-label">Computational Depth</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">3</div>
                <div class="stat-label">Research Articles</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">λ</div>
                <div class="stat-label">Complexity Theory</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">Σ</div>
                <div class="stat-label">Information Theory</div>
            </div>
        </div>
    </div>

    <!-- About -->
    <div class="container">
        <section id="research">
            <div class="content-card">
                <h2 class="card-title">Research Focus</h2>
                <p style="color: var(--text-secondary); font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;">
                    Investigating the theoretical foundations of computation, algorithmic complexity, and information theory. My work explores the boundaries between computable and incomputable, efficient and intractable, pattern and randomness.
                </p>
                <p style="color: var(--text-dim); font-size: 1rem; line-height: 1.8;">
                    <strong style="color: var(--primary);">Core Areas:</strong> Kolmogorov Complexity • Turing Machines • Shannon Entropy • P vs NP • Computational Complexity • Algorithmic Information Theory
                </p>
            </div>
        </section>
    </div>

    <!-- Publications -->
    <div class="container">
        <section id="publications">
            <div class="section-header">
                <h2 class="section-title">Latest Publications</h2>
                <p class="section-subtitle">Deep dives into computational theory and information science</p>
            </div>

            <div class="blog-grid">
                <article class="article-card">
                    <span class="article-date">2025.10.25</span>
                    <h3 class="article-title">The Million-Dollar Question: Why P vs NP Matters</h3>
                    <p class="article-excerpt">
                        Comprehensive analysis of the most famous unsolved problem in computer science. Explores implications for cryptography, optimization, and the fundamental nature of computational difficulty.
                    </p>
                    <a href="/2025/10/25/p-vs-np-million-dollar-question.html" class="article-link">Read Article</a>
                </article>

                <article class="article-card">
                    <span class="article-date">2025.10.20</span>
                    <h3 class="article-title">Shannon's Information Theory Revolution</h3>
                    <p class="article-excerpt">
                        Deep dive into Claude Shannon's 1948 masterpiece that transformed communication, compression, and our understanding of information as a fundamental physical quantity.
                    </p>
                    <a href="/2025/10/20/shannon-information-theory.html" class="article-link">Read Article</a>
                </article>

                <article class="article-card">
                    <span class="article-date">2025.10.15</span>
                    <h3 class="article-title">The Elegant Universe of Turing Machines</h3>
                    <p class="article-excerpt">
                        From simple rules to infinite possibilities—exploring how Turing machines define the boundaries of computation and what it fundamentally means to compute.
                    </p>
                    <a href="/2025/10/15/turing-machines-elegance.html" class="article-link">Read Article</a>
                </article>
            </div>
        </section>
    </div>

    <!-- Footer -->
    <div class="container">
        <footer>
            <div class="footer-content">
                © 2025 Mahammad Nuriyev. All rights reserved.
            </div>
            <div class="footer-status">
                <span class="status-dot"></span>
                System Online • Uptime: ∞ • Errors: 0
            </div>
        </footer>
    </div>

    <script>
        // Interactive 3D Cube with Quaternion-based rotation
        const cubeScene = document.querySelector('.cube-scene');
        const cube = document.querySelector('.cube');

        // Quaternion class for accurate 3D rotation
        class Quaternion {
            constructor(w = 1, x = 0, y = 0, z = 0) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
            }

            static fromAxisAngle(axis, angle) {
                const halfAngle = angle / 2;
                const s = Math.sin(halfAngle);
                return new Quaternion(
                    Math.cos(halfAngle),
                    axis.x * s,
                    axis.y * s,
                    axis.z * s
                );
            }

            multiply(q) {
                return new Quaternion(
                    this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z,
                    this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,
                    this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,
                    this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w
                );
            }

            normalize() {
                const len = Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                if (len > 0) {
                    this.w /= len;
                    this.x /= len;
                    this.y /= len;
                    this.z /= len;
                }
                return this;
            }

            toMatrix() {
                const xx = this.x * this.x;
                const xy = this.x * this.y;
                const xz = this.x * this.z;
                const xw = this.x * this.w;
                const yy = this.y * this.y;
                const yz = this.y * this.z;
                const yw = this.y * this.w;
                const zz = this.z * this.z;
                const zw = this.z * this.w;

                return [
                    1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 0,
                    2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 0,
                    2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy), 0,
                    0, 0, 0, 1
                ];
            }

            toCSSMatrix() {
                return `matrix3d(${this.toMatrix().join(',')})`;
            }

            slerp(q, t) {
                let dot = this.w * q.w + this.x * q.x + this.y * q.y + this.z * q.z;

                if (dot < 0) {
                    q = new Quaternion(-q.w, -q.x, -q.y, -q.z);
                    dot = -dot;
                }

                if (dot > 0.9995) {
                    return new Quaternion(
                        this.w + t * (q.w - this.w),
                        this.x + t * (q.x - this.x),
                        this.y + t * (q.y - this.y),
                        this.z + t * (q.z - this.z)
                    ).normalize();
                }

                const theta = Math.acos(dot);
                const sinTheta = Math.sin(theta);
                const w1 = Math.sin((1 - t) * theta) / sinTheta;
                const w2 = Math.sin(t * theta) / sinTheta;

                return new Quaternion(
                    this.w * w1 + q.w * w2,
                    this.x * w1 + q.x * w2,
                    this.y * w1 + q.y * w2,
                    this.z * w1 + q.z * w2
                );
            }
        }

        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let currentRotation = new Quaternion();
        let rotationVelocity = new Quaternion();
        let autoRotateTimeout;

        function updateCubeRotation() {
            cube.style.transform = currentRotation.toCSSMatrix();
        }

        function getRotationFromDrag(deltaX, deltaY, sensitivity = 0.5) {
            const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (dragDistance < 0.1) return new Quaternion();

            const axis = {
                x: -deltaY / dragDistance,
                y: deltaX / dragDistance,
                z: 0
            };

            const angle = (dragDistance * sensitivity * Math.PI) / 180;
            return Quaternion.fromAxisAngle(axis, angle);
        }

        cubeScene.addEventListener('mousedown', (e) => {
            isDragging = true;
            cube.classList.add('dragging');
            cube.classList.remove('auto-rotate');
            previousMouseX = e.clientX;
            previousMouseY = e.clientY;
            rotationVelocity = new Quaternion();

            if (autoRotateTimeout) clearTimeout(autoRotateTimeout);
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMouseX;
            const deltaY = e.clientY - previousMouseY;

            const dragRotation = getRotationFromDrag(deltaX, deltaY, 1.0);
            rotationVelocity = dragRotation;
            currentRotation = dragRotation.multiply(currentRotation).normalize();

            updateCubeRotation();

            previousMouseX = e.clientX;
            previousMouseY = e.clientY;
        });

        document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            cube.classList.remove('dragging');

            let momentum = 30;
            let currentVelocity = rotationVelocity;

            const applyMomentum = () => {
                if (momentum <= 0) {
                    autoRotateTimeout = setTimeout(() => {
                        cube.style.animation = 'none';
                        cube.style.transform = currentRotation.toCSSMatrix();
                        setTimeout(() => cube.classList.add('auto-rotate'), 50);
                    }, 3000);
                    return;
                }

                currentVelocity = currentVelocity.slerp(new Quaternion(), 0.05);
                currentRotation = currentVelocity.multiply(currentRotation).normalize();
                updateCubeRotation();

                momentum--;
                requestAnimationFrame(applyMomentum);
            };

            applyMomentum();
        });

        // Touch support
        cubeScene.addEventListener('touchstart', (e) => {
            isDragging = true;
            cube.classList.add('dragging');
            cube.classList.remove('auto-rotate');
            const touch = e.touches[0];
            previousMouseX = touch.clientX;
            previousMouseY = touch.clientY;
            rotationVelocity = new Quaternion();
            if (autoRotateTimeout) clearTimeout(autoRotateTimeout);
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const touch = e.touches[0];
            const deltaX = touch.clientX - previousMouseX;
            const deltaY = touch.clientY - previousMouseY;

            const dragRotation = getRotationFromDrag(deltaX, deltaY, 1.0);
            rotationVelocity = dragRotation;
            currentRotation = dragRotation.multiply(currentRotation).normalize();
            updateCubeRotation();

            previousMouseX = touch.clientX;
            previousMouseY = touch.clientY;
        }, { passive: false });

        document.addEventListener('touchend', () => {
            if (!isDragging) return;
            isDragging = false;
            cube.classList.remove('dragging');

            let momentum = 30;
            let currentVelocity = rotationVelocity;

            const applyMomentum = () => {
                if (momentum <= 0) {
                    autoRotateTimeout = setTimeout(() => {
                        cube.style.animation = 'none';
                        cube.style.transform = currentRotation.toCSSMatrix();
                        setTimeout(() => cube.classList.add('auto-rotate'), 50);
                    }, 3000);
                    return;
                }

                currentVelocity = currentVelocity.slerp(new Quaternion(), 0.05);
                currentRotation = currentVelocity.multiply(currentRotation).normalize();
                updateCubeRotation();

                momentum--;
                requestAnimationFrame(applyMomentum);
            };

            applyMomentum();
        });

        // Matrix Rain
        const matrixCanvas = document.getElementById('matrix-canvas');
        const matrixCtx = matrixCanvas.getContext('2d');
        matrixCanvas.width = window.innerWidth;
        matrixCanvas.height = window.innerHeight;

        const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
        const fontSize = 14;
        const columns = matrixCanvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);

        function drawMatrix() {
            matrixCtx.fillStyle = 'rgba(5, 8, 16, 0.05)';
            matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            matrixCtx.fillStyle = '#00ff88';
            matrixCtx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const char = chars[Math.floor(Math.random() * chars.length)];
                matrixCtx.fillText(char, i * fontSize, drops[i] * fontSize);

                if (drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }

        setInterval(drawMatrix, 50);

        // Neural Network
        const neuralCanvas = document.getElementById('neural-canvas');
        const neuralCtx = neuralCanvas.getContext('2d');
        neuralCanvas.width = window.innerWidth;
        neuralCanvas.height = window.innerHeight;

        class Node {
            constructor() {
                this.x = Math.random() * neuralCanvas.width;
                this.y = Math.random() * neuralCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > neuralCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > neuralCanvas.height) this.vy *= -1;
            }

            draw() {
                neuralCtx.beginPath();
                neuralCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                neuralCtx.fillStyle = '#00d4ff';
                neuralCtx.fill();
            }
        }

        const nodes = Array(40).fill(null).map(() => new Node());

        function drawNeuralNetwork() {
            neuralCtx.clearRect(0, 0, neuralCanvas.width, neuralCanvas.height);

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 120) {
                        neuralCtx.beginPath();
                        neuralCtx.moveTo(nodes[i].x, nodes[i].y);
                        neuralCtx.lineTo(nodes[j].x, nodes[j].y);
                        neuralCtx.strokeStyle = `rgba(0, 212, 255, ${0.3 * (1 - dist / 120)})`;
                        neuralCtx.lineWidth = 0.5;
                        neuralCtx.stroke();
                    }
                }
            }

            nodes.forEach(node => {
                node.update();
                node.draw();
            });

            requestAnimationFrame(drawNeuralNetwork);
        }

        drawNeuralNetwork();

        // Resize handler
        window.addEventListener('resize', () => {
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            neuralCanvas.width = window.innerWidth;
            neuralCanvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
