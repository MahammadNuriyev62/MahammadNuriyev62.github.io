<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horror Maze Chase - WiFi Multiplayer</title>
    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a0000 0%, #000000 50%, #1a0000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            background: rgba(20, 0, 0, 0.9);
            border: 3px solid #ff0000;
            border-radius: 20px;
            box-shadow: 0 0 60px rgba(255, 0, 0, 0.5), inset 0 0 40px rgba(0, 0, 0, 0.8);
            padding: 30px;
            max-width: 1100px;
            width: 95%;
        }

        #menu {
            text-align: center;
        }

        h1 {
            color: #ff0000;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            animation: flicker 3s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            55% { opacity: 1; }
            60% { opacity: 0.9; }
        }

        .warning {
            color: #ffaa00;
            font-size: 0.9em;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid #ffaa00;
            border-radius: 5px;
        }

        .button-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, #990000 0%, #ff0000 100%);
            color: white;
            border: 2px solid #ff0000;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }

        input {
            padding: 15px;
            font-size: 16px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            width: 300px;
            margin: 10px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
        }

        input::placeholder {
            color: #999;
        }

        #gameArea {
            display: none;
        }

        #gameCanvas {
            border: 3px solid #ff0000;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background: #0a0a0a;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.9);
        }

        #info {
            text-align: center;
            margin-bottom: 20px;
            color: #fff;
        }

        #roomInfo {
            background: linear-gradient(135deg, #990000, #660000);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }

        #gameStats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 10px 0;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ff0000;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.75em;
            color: #999;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ff0000;
            margin-top: 5px;
        }

        #playerList {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: left;
            border: 2px solid #ff0000;
            max-height: 150px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 14px;
            padding: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
        }

        .player-status {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }

        .status-monster {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
            animation: pulse 1s infinite;
        }

        .status-alive {
            background: #00ff00;
        }

        .status-caught {
            background: #666;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        #controls {
            text-align: center;
            color: #999;
            margin-top: 15px;
            font-size: 12px;
        }

        .hidden {
            display: none;
        }

        #status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .status-success {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            border: 1px solid #00ff00;
        }

        .status-error {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6666;
            border: 1px solid #ff0000;
        }

        .status-info {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
            border: 1px solid #ffaa00;
        }

        #joinSection {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #660000;
        }

        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0000;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
        }

        #gameOver h2 {
            color: #ff0000;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }

        #gameOver p {
            color: #fff;
            font-size: 1.5em;
            margin: 10px 0;
        }

        #legend {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            color: #999;
            margin-top: 10px;
        }

        #legend span {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="menu">
            <h1>üè∞ HORROR MAZE CHASE üëπ</h1>
            <div class="warning">
                ‚ö†Ô∏è Navigate a deadly maze! Collect keys üîë, avoid traps üí•, lock doors üö™<br>
                Monster: Hunt survivors! | Survivors: Find hidden passages and ESCAPE!
            </div>

            <div class="button-group">
                <button onclick="createRoom()">üî¥ Create Room (Be the Monster)</button>
            </div>

            <div id="joinSection">
                <input type="text" id="roomIdInput" placeholder="Enter Room ID to Join">
                <br>
                <button onclick="joinRoom()">üèÉ Join & Survive</button>
            </div>

            <div id="status" class="hidden"></div>
        </div>

        <div id="gameArea">
            <div id="info">
                <div id="roomInfo"></div>
                <div id="gameStats">
                    <div class="stat-box">
                        <div class="stat-label">Time</div>
                        <div class="stat-value" id="timer">0:00</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Alive</div>
                        <div class="stat-value" id="aliveCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Keys</div>
                        <div class="stat-value" id="keyCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Caught</div>
                        <div class="stat-value" id="caughtCount">0</div>
                    </div>
                </div>
                <div id="playerList"></div>
                <div id="controls">
                    <span id="controlsText">WASD/Arrows: Move | E: Use Door | R: Lock Door (costs 1 key)</span>
                </div>
                <div id="legend">
                    <span>üß± Wall</span>
                    <span>üö™ Door (Press E)</span>
                    <span>üîí Locked</span>
                    <span>üîë Key</span>
                    <span>üí• Trap</span>
                    <span>üåÄ Hidden Passage</span>
                </div>
            </div>
            <canvas id="gameCanvas" width="1000" height="700"></canvas>
        </div>
    </div>

    <div id="gameOver">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p id="gameOverMessage"></p>
        <p id="gameOverStats"></p>
    </div>

    <script>
        // Game state
        let peer = null;
        let connections = [];
        let isHost = false;
        let myId = null;
        let roomId = null;
        let gameStartTime = 0;
        let gameTime = 0;

        const players = {};
        const CELL_SIZE = 40;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Map layout (1=wall, 0=empty, 2=door, 3=trap, 4=key, 5=hidden passage)
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,4,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,0,1,0,1,1,1,0,1,0,1,0,2,0,1,1,1,0,1,0,1,3,1],
            [1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,4,0,1],
            [1,3,1,0,2,0,1,0,1,0,2,0,1,1,1,0,1,0,1,1,1,0,1,0,1],
            [1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1],
            [1,0,1,0,0,0,0,0,1,0,4,0,0,0,0,0,1,0,0,0,0,0,0,3,1],
            [1,0,2,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],
            [1,5,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,5,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Game objects
        const doors = [];
        const keys = [];
        const traps = [];
        const passages = [];

        // Initialize map objects
        for (let y = 0; y < map.length; y++) {
            for (let x = 0; x < map[y].length; x++) {
                if (map[y][x] === 2) {
                    doors.push({ x, y, open: false, locked: false });
                } else if (map[y][x] === 4) {
                    keys.push({ x, y, collected: false });
                } else if (map[y][x] === 3) {
                    traps.push({ x, y, active: true });
                } else if (map[y][x] === 5) {
                    passages.push({ x, y, discovered: false });
                }
            }
        }

        // My player
        let myPlayer = {
            x: 60,
            y: 60,
            vx: 0,
            vy: 0,
            radius: 12,
            color: '#00ff00',
            name: 'Player',
            isCaught: false,
            isMonster: false,
            keysCollected: 0,
            stunned: false,
            stunnedUntil: 0
        };

        // Input handling
        const keys_pressed = {};
        const PLAYER_SPEED = 1.5;
        const MONSTER_SPEED = 2.0;
        const FRICTION = 0.85;
        const CATCH_DISTANCE = 35;

        document.addEventListener('keydown', (e) => {
            keys_pressed[e.key.toLowerCase()] = true;

            // Interact with doors (E key)
            if (e.key.toLowerCase() === 'e' && !myPlayer.isCaught) {
                interactWithDoor();
            }

            // Lock doors (R key)
            if (e.key.toLowerCase() === 'r' && !myPlayer.isCaught && myPlayer.keysCollected > 0) {
                lockDoor();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys_pressed[e.key.toLowerCase()] = false;
        });

        function interactWithDoor() {
            const playerCell = {
                x: Math.floor(myPlayer.x / CELL_SIZE),
                y: Math.floor(myPlayer.y / CELL_SIZE)
            };

            doors.forEach((door, index) => {
                const dist = Math.sqrt(Math.pow(door.x - playerCell.x, 2) + Math.pow(door.y - playerCell.y, 2));
                if (dist < 2 && !door.locked) {
                    door.open = !door.open;
                    broadcast({
                        type: 'doorToggle',
                        doorIndex: index,
                        open: door.open
                    });
                }
            });
        }

        function lockDoor() {
            const playerCell = {
                x: Math.floor(myPlayer.x / CELL_SIZE),
                y: Math.floor(myPlayer.y / CELL_SIZE)
            };

            doors.forEach((door, index) => {
                const dist = Math.sqrt(Math.pow(door.x - playerCell.x, 2) + Math.pow(door.y - playerCell.y, 2));
                if (dist < 2 && !door.locked && door.open === false) {
                    door.locked = true;
                    myPlayer.keysCollected--;
                    document.getElementById('keyCount').textContent = myPlayer.keysCollected;

                    broadcast({
                        type: 'doorLock',
                        doorIndex: index,
                        locked: true
                    });
                }
            });
        }

        // Create room (Host - Monster)
        function createRoom() {
            showStatus('Creating room...', 'info');
            peer = new Peer();

            peer.on('open', (id) => {
                myId = id;
                roomId = id;
                isHost = true;
                myPlayer.isMonster = true;
                myPlayer.color = '#ff0000';
                myPlayer.radius = 18;
                myPlayer.name = 'üëπ MONSTER';
                myPlayer.x = canvas.width - 60;
                myPlayer.y = canvas.height - 60;
                players[myId] = { ...myPlayer };

                showStatus('Room created! You are the MONSTER!', 'success');
                startGame();

                peer.on('connection', (conn) => {
                    handleConnection(conn);
                });
            });

            peer.on('error', (err) => {
                showStatus('Error: ' + err.message, 'error');
            });
        }

        // Join room (Player)
        function joinRoom() {
            const inputRoomId = document.getElementById('roomIdInput').value.trim();

            if (!inputRoomId) {
                showStatus('Please enter a Room ID', 'error');
                return;
            }

            showStatus('Joining room...', 'info');
            peer = new Peer();

            peer.on('open', (id) => {
                myId = id;
                roomId = inputRoomId;
                isHost = false;
                myPlayer.isMonster = false;
                myPlayer.color = '#00ff00';
                myPlayer.name = 'Survivor ' + Math.floor(Math.random() * 1000);

                const conn = peer.connect(inputRoomId);
                handleConnection(conn);
            });

            peer.on('error', (err) => {
                showStatus('Error: Could not join room. Check the Room ID.', 'error');
            });
        }

        // Handle peer connection
        function handleConnection(conn) {
            connections.push(conn);

            conn.on('open', () => {
                showStatus('Connected!', 'success');

                conn.send({
                    type: 'join',
                    id: myId,
                    player: myPlayer
                });

                if (!isHost) {
                    startGame();
                }
            });

            conn.on('data', (data) => {
                handleData(data, conn);
            });

            conn.on('close', () => {
                connections = connections.filter(c => c !== conn);
            });
        }

        // Handle incoming data
        function handleData(data, conn) {
            switch(data.type) {
                case 'join':
                    players[data.id] = data.player;
                    updatePlayerList();

                    if (isHost) {
                        conn.send({
                            type: 'playerList',
                            players: players,
                            doors: doors,
                            keys: keys,
                            traps: traps,
                            passages: passages
                        });

                        broadcastToOthers({
                            type: 'playerJoined',
                            id: data.id,
                            player: data.player
                        }, conn);
                    }
                    break;

                case 'playerList':
                    Object.assign(players, data.players);
                    doors.length = 0;
                    doors.push(...data.doors);
                    keys.length = 0;
                    keys.push(...data.keys);
                    traps.length = 0;
                    traps.push(...data.traps);
                    passages.length = 0;
                    passages.push(...data.passages);
                    players[myId] = myPlayer;
                    updatePlayerList();
                    break;

                case 'playerJoined':
                    players[data.id] = data.player;
                    updatePlayerList();
                    break;

                case 'update':
                    if (players[data.id]) {
                        players[data.id].x = data.x;
                        players[data.id].y = data.y;
                        players[data.id].isCaught = data.isCaught;
                        players[data.id].keysCollected = data.keysCollected;
                        players[data.id].stunned = data.stunned;
                    }
                    break;

                case 'doorToggle':
                    if (doors[data.doorIndex]) {
                        doors[data.doorIndex].open = data.open;
                    }
                    break;

                case 'doorLock':
                    if (doors[data.doorIndex]) {
                        doors[data.doorIndex].locked = data.locked;
                    }
                    break;

                case 'keyCollect':
                    if (keys[data.keyIndex]) {
                        keys[data.keyIndex].collected = true;
                    }
                    break;

                case 'passageDiscover':
                    if (passages[data.passageIndex]) {
                        passages[data.passageIndex].discovered = true;
                    }
                    break;

                case 'caught':
                    if (players[data.victimId]) {
                        players[data.victimId].isCaught = true;
                        if (data.victimId === myId) {
                            myPlayer.isCaught = true;
                            showGameOver('YOU WERE CAUGHT!', 'The monster got you!', data.survivalTime);
                        }
                        updatePlayerList();
                    }
                    break;

                case 'gameOver':
                    if (!isHost) {
                        showGameOver(data.title, data.message, data.time);
                    }
                    break;

                case 'leave':
                    delete players[data.id];
                    updatePlayerList();
                    break;
            }
        }

        function broadcastToOthers(data, except = null) {
            connections.forEach(conn => {
                if (conn !== except && conn.open) {
                    conn.send(data);
                }
            });
        }

        function broadcast(data) {
            connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }

        // Start game
        function startGame() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';

            const role = isHost ? 'üëπ You are the MONSTER!' : 'üèÉ SURVIVE!';
            document.getElementById('roomInfo').textContent = `Room ID: ${roomId} | ${role}`;

            players[myId] = myPlayer;
            updatePlayerList();

            gameStartTime = Date.now();
            gameLoop();
        }

        // Update player list display
        function updatePlayerList() {
            const listEl = document.getElementById('playerList');
            let aliveCount = 0;
            let caughtCount = 0;

            listEl.innerHTML = '<strong style="color: #ff0000;">Players:</strong><br>';

            Object.keys(players).forEach(id => {
                const player = players[id];
                const isMe = id === myId;

                let statusClass = 'status-alive';
                let statusText = '‚úì Alive';

                if (player.isMonster) {
                    statusClass = 'status-monster';
                    statusText = 'üëπ Monster';
                } else if (player.isCaught) {
                    statusClass = 'status-caught';
                    statusText = 'üíÄ Caught';
                    caughtCount++;
                } else {
                    aliveCount++;
                }

                listEl.innerHTML += `
                    <div class="player-item">
                        <div class="player-status ${statusClass}"></div>
                        <span style="color: ${player.isCaught ? '#666' : '#fff'}">${player.name}${isMe ? ' (You)' : ''}</span>
                    </div>
                `;
            });

            document.getElementById('aliveCount').textContent = aliveCount;
            document.getElementById('caughtCount').textContent = caughtCount;
            document.getElementById('keyCount').textContent = myPlayer.keysCollected;

            // Check game over condition
            if (isHost && aliveCount === 0 && Object.keys(players).length > 1) {
                const time = formatTime(gameTime);
                broadcast({
                    type: 'gameOver',
                    title: 'ALL CAUGHT!',
                    message: 'The monster caught everyone!',
                    time: time
                });
                showGameOver('VICTORY!', 'You caught all survivors!', time);
            }
        }

        // Game loop
        function gameLoop() {
            gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            document.getElementById('timer').textContent = formatTime(gameTime);

            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Collision detection
        function canMoveTo(x, y, radius) {
            const corners = [
                { x: x - radius, y: y - radius },
                { x: x + radius, y: y - radius },
                { x: x - radius, y: y + radius },
                { x: x + radius, y: y + radius }
            ];

            for (let corner of corners) {
                const cellX = Math.floor(corner.x / CELL_SIZE);
                const cellY = Math.floor(corner.y / CELL_SIZE);

                if (cellY < 0 || cellY >= map.length || cellX < 0 || cellX >= map[0].length) {
                    return false;
                }

                const cell = map[cellY][cellX];

                // Wall collision
                if (cell === 1) {
                    return false;
                }

                // Door collision (only if closed)
                if (cell === 2) {
                    const door = doors.find(d => d.x === cellX && d.y === cellY);
                    if (door && !door.open) {
                        return false;
                    }
                }

                // Hidden passage (acts as wall if not discovered)
                if (cell === 5) {
                    const passage = passages.find(p => p.x === cellX && p.y === cellY);
                    if (passage && !passage.discovered) {
                        return false;
                    }
                }
            }

            return true;
        }

        // Update game state
        function update() {
            if (myPlayer.isCaught) return;

            // Check if stunned
            if (myPlayer.stunned && Date.now() < myPlayer.stunnedUntil) {
                return;
            } else if (myPlayer.stunned) {
                myPlayer.stunned = false;
            }

            const speed = myPlayer.isMonster ? MONSTER_SPEED : PLAYER_SPEED;

            // Handle input
            if (keys_pressed['arrowup'] || keys_pressed['w']) myPlayer.vy -= speed;
            if (keys_pressed['arrowdown'] || keys_pressed['s']) myPlayer.vy += speed;
            if (keys_pressed['arrowleft'] || keys_pressed['a']) myPlayer.vx -= speed;
            if (keys_pressed['arrowright'] || keys_pressed['d']) myPlayer.vx += speed;

            // Apply friction
            myPlayer.vx *= FRICTION;
            myPlayer.vy *= FRICTION;

            // Calculate new position
            const newX = myPlayer.x + myPlayer.vx;
            const newY = myPlayer.y + myPlayer.vy;

            // Check collisions and update position
            if (canMoveTo(newX, myPlayer.y, myPlayer.radius)) {
                myPlayer.x = newX;
            } else {
                myPlayer.vx = 0;
            }

            if (canMoveTo(myPlayer.x, newY, myPlayer.radius)) {
                myPlayer.y = newY;
            } else {
                myPlayer.vy = 0;
            }

            // Collect keys
            const playerCell = {
                x: Math.floor(myPlayer.x / CELL_SIZE),
                y: Math.floor(myPlayer.y / CELL_SIZE)
            };

            keys.forEach((key, index) => {
                if (!key.collected && key.x === playerCell.x && key.y === playerCell.y) {
                    key.collected = true;
                    myPlayer.keysCollected++;
                    broadcast({
                        type: 'keyCollect',
                        keyIndex: index
                    });
                }
            });

            // Discover hidden passages
            passages.forEach((passage, index) => {
                const dist = Math.sqrt(Math.pow((passage.x * CELL_SIZE + CELL_SIZE/2) - myPlayer.x, 2) +
                                     Math.pow((passage.y * CELL_SIZE + CELL_SIZE/2) - myPlayer.y, 2));
                if (!passage.discovered && dist < 30) {
                    passage.discovered = true;
                    broadcast({
                        type: 'passageDiscover',
                        passageIndex: index
                    });
                }
            });

            // Check traps
            traps.forEach(trap => {
                if (trap.active && trap.x === playerCell.x && trap.y === playerCell.y && !myPlayer.isMonster) {
                    myPlayer.stunned = true;
                    myPlayer.stunnedUntil = Date.now() + 2000; // Stunned for 2 seconds
                }
            });

            // Monster catches players
            if (isHost && myPlayer.isMonster) {
                Object.keys(players).forEach(id => {
                    if (id !== myId && !players[id].isCaught) {
                        const other = players[id];
                        const dx = other.x - myPlayer.x;
                        const dy = other.y - myPlayer.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < CATCH_DISTANCE) {
                            players[id].isCaught = true;
                            broadcast({
                                type: 'caught',
                                victimId: id,
                                survivalTime: formatTime(gameTime)
                            });
                            updatePlayerList();
                        }
                    }
                });
            }

            // Update my player in the players object
            players[myId] = { ...myPlayer };

            // Send position update
            if (Math.abs(myPlayer.vx) > 0.1 || Math.abs(myPlayer.vy) > 0.1 || Math.random() < 0.1) {
                broadcast({
                    type: 'update',
                    id: myId,
                    x: myPlayer.x,
                    y: myPlayer.y,
                    isCaught: myPlayer.isCaught,
                    keysCollected: myPlayer.keysCollected,
                    stunned: myPlayer.stunned
                });
            }
        }

        // Render game
        function render() {
            // Dark background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw map
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    const cellType = map[y][x];
                    const screenX = x * CELL_SIZE;
                    const screenY = y * CELL_SIZE;

                    if (cellType === 1) {
                        // Wall
                        ctx.fillStyle = '#333';
                        ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#222';
                        ctx.strokeRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                    } else if (cellType === 2) {
                        // Door
                        const door = doors.find(d => d.x === x && d.y === y);
                        if (door) {
                            if (door.locked) {
                                ctx.fillStyle = '#ff0000';
                                ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                                ctx.fillStyle = '#fff';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('üîí', screenX + CELL_SIZE/2, screenY + CELL_SIZE/2 + 7);
                            } else if (door.open) {
                                ctx.fillStyle = 'rgba(0, 100, 0, 0.3)';
                                ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                            } else {
                                ctx.fillStyle = '#654321';
                                ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                                ctx.fillStyle = '#fff';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('üö™', screenX + CELL_SIZE/2, screenY + CELL_SIZE/2 + 7);
                            }
                        }
                    } else if (cellType === 3) {
                        // Trap
                        const trap = traps.find(t => t.x === x && t.y === y);
                        if (trap && trap.active) {
                            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                            ctx.fillStyle = `rgba(255, 100, 0, ${pulse})`;
                            ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                            ctx.fillStyle = '#fff';
                            ctx.font = '20px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('üí•', screenX + CELL_SIZE/2, screenY + CELL_SIZE/2 + 7);
                        }
                    } else if (cellType === 4) {
                        // Key
                        const key = keys.find(k => k.x === x && k.y === y);
                        if (key && !key.collected) {
                            const float = Math.sin(Date.now() / 500 + x + y) * 3;
                            ctx.fillStyle = '#ffff00';
                            ctx.shadowColor = '#ffff00';
                            ctx.shadowBlur = 15;
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('üîë', screenX + CELL_SIZE/2, screenY + CELL_SIZE/2 + 7 + float);
                            ctx.shadowBlur = 0;
                        }
                    } else if (cellType === 5) {
                        // Hidden passage
                        const passage = passages.find(p => p.x === x && p.y === y);
                        if (passage) {
                            if (passage.discovered) {
                                const swirl = Date.now() / 1000;
                                ctx.fillStyle = `rgba(100, 0, 200, 0.5)`;
                                ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                                ctx.fillStyle = '#fff';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('üåÄ', screenX + CELL_SIZE/2, screenY + CELL_SIZE/2 + 7);
                            } else {
                                ctx.fillStyle = '#333';
                                ctx.fillRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                                ctx.strokeStyle = '#222';
                                ctx.strokeRect(screenX, screenY, CELL_SIZE, CELL_SIZE);
                            }
                        }
                    }
                }
            }

            // Draw all players
            Object.keys(players).forEach(id => {
                const player = players[id];
                const isMe = id === myId;

                if (player.isCaught && !player.isMonster) {
                    // Caught player (faded)
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üíÄ', player.x, player.y + 7);
                } else if (player.isMonster) {
                    // Monster (pulsing red with glow)
                    const pulseSize = player.radius + Math.sin(Date.now() / 200) * 3;

                    const monsterGlow = ctx.createRadialGradient(
                        player.x, player.y, pulseSize * 0.5,
                        player.x, player.y, pulseSize * 2.5
                    );
                    monsterGlow.addColorStop(0, 'rgba(255, 0, 0, 0.6)');
                    monsterGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = monsterGlow;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, pulseSize * 2.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(player.x + 3, player.y + 3, pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#880000';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(player.x - 6, player.y - 4, 3, 0, Math.PI * 2);
                    ctx.arc(player.x + 6, player.y - 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Alive player
                    const playerGlow = ctx.createRadialGradient(
                        player.x, player.y, player.radius * 0.5,
                        player.x, player.y, player.radius * 1.8
                    );
                    playerGlow.addColorStop(0, 'rgba(0, 255, 0, 0.4)');
                    playerGlow.addColorStop(1, 'rgba(0, 255, 0, 0)');
                    ctx.fillStyle = playerGlow;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius * 1.8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(player.x + 2, player.y + 2, player.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Stunned effect
                    if (player.stunned) {
                        ctx.fillStyle = '#ffff00';
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 3;
                    } else {
                        ctx.fillStyle = player.color;
                        ctx.strokeStyle = isMe ? '#fff' : '#00aa00';
                        ctx.lineWidth = isMe ? 3 : 2;
                    }

                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Show key count
                    if (player.keysCollected > 0) {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`üîë${player.keysCollected}`, player.x, player.y - player.radius - 12);
                    }
                }

                // Name
                ctx.fillStyle = player.isMonster ? '#ff0000' : (player.isCaught ? '#666' : '#00ff00');
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(player.name, player.x, player.y - player.radius - 3);
                ctx.shadowBlur = 0;
            });
        }

        function showGameOver(title, message, time) {
            const gameOverDiv = document.getElementById('gameOver');
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverStats').textContent = `Time: ${time} | Keys: ${myPlayer.keysCollected}`;
            gameOverDiv.style.display = 'block';
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status-' + type;
            statusEl.classList.remove('hidden');
        }

        window.addEventListener('beforeunload', () => {
            if (peer) {
                broadcast({
                    type: 'leave',
                    id: myId
                });
                peer.destroy();
            }
        });
    </script>
</body>
</html>
