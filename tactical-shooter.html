<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactical Warfare - 2D Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #1a1a1a;
            color: #0f0;
        }

        #gameCanvas {
            display: block;
            background: #87ceeb;
            margin: 0 auto;
            border: 3px solid #333;
        }

        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .player-panel {
            position: absolute;
            top: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border: 3px solid;
            min-width: 280px;
        }

        .player1-panel {
            left: 20px;
            border-color: #00ff00;
        }

        .player2-panel {
            right: 20px;
            border-color: #ff0000;
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player1-panel .player-name {
            color: #00ff00;
        }

        .player2-panel .player-name {
            color: #ff0000;
        }

        .health-display {
            margin-bottom: 10px;
        }

        .bar-container {
            background: #222;
            height: 22px;
            border: 1px solid #555;
            margin: 5px 0;
            position: relative;
        }

        .bar {
            height: 100%;
            transition: width 0.3s ease;
        }

        .health-bar {
            background: linear-gradient(90deg, #ff0000, #00ff00);
        }

        .ammo-bar {
            background: linear-gradient(90deg, #ffaa00, #ffff00);
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 12px;
            text-shadow: 1px 1px 2px #000;
            font-weight: bold;
        }

        .weapon-display {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }

        .weapon-icon {
            font-size: 24px;
        }

        .weapon-name {
            color: #ffaa00;
            font-weight: bold;
        }

        .vehicle-status {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
            color: #00aaff;
            font-size: 14px;
        }

        .kill-feed {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            min-width: 300px;
            max-width: 500px;
        }

        .kill-message {
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            margin: 5px 0;
            border-left: 4px solid #ff0000;
            animation: slideDown 0.3s ease, fadeOut 0.5s ease 3.5s;
            text-align: center;
            color: #fff;
        }

        @keyframes slideDown {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #menu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 70px;
            color: #00ff00;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            font-weight: bold;
        }

        .menu-subtitle {
            font-size: 24px;
            color: #888;
            margin-bottom: 50px;
        }

        .menu-button {
            background: transparent;
            border: 3px solid #00ff00;
            color: #00ff00;
            padding: 18px 50px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            pointer-events: all;
            margin: 10px;
        }

        .menu-button:hover {
            background: #00ff00;
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
        }

        .controls-display {
            margin-top: 50px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border: 2px solid #444;
        }

        .player-controls {
            text-align: left;
        }

        .controls-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid;
        }

        .player1-controls .controls-header {
            color: #00ff00;
            border-color: #00ff00;
        }

        .player2-controls .controls-header {
            color: #ff0000;
            border-color: #ff0000;
        }

        .control-row {
            margin: 8px 0;
            color: #aaa;
            font-size: 14px;
        }

        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            border: 1px solid #666;
            border-radius: 3px;
            color: #fff;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over-screen.show {
            display: flex;
        }

        .game-over-title {
            font-size: 80px;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 0 0 30px currentColor;
        }

        .winner-announcement {
            font-size: 45px;
            margin-bottom: 40px;
            color: #fff;
        }

        .final-stats {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border: 3px solid #00ff00;
            margin-bottom: 30px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            gap: 60px;
            margin: 12px 0;
            font-size: 18px;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border: 2px solid #ffaa00;
            color: #ffaa00;
            font-size: 14px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1400" height="800"></canvas>
    <!-- Actual game world will be 3500x1400, canvas is viewport -->

    <div id="hud">
        <div class="player-panel player1-panel">
            <div class="player-name">PLAYER 1 [GREEN]</div>
            <div class="health-display">
                <div class="bar-container">
                    <div class="bar health-bar" id="p1HealthBar" style="width: 100%"></div>
                    <div class="bar-text" id="p1HealthText">100 / 100</div>
                </div>
            </div>
            <div class="weapon-display">
                <div class="weapon-icon" id="p1WeaponIcon">🔫</div>
                <div>
                    <div class="weapon-name" id="p1WeaponName">PISTOL</div>
                    <div class="bar-container" style="width: 150px;">
                        <div class="bar ammo-bar" id="p1AmmoBar" style="width: 100%"></div>
                        <div class="bar-text" id="p1AmmoText">∞</div>
                    </div>
                </div>
            </div>
            <div class="vehicle-status" id="p1Vehicle" style="display: none;"></div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444;">
                <div style="color: #ffaa00; font-size: 14px;">SCORE: <span id="p1Score">0</span></div>
                <div style="color: #ff00ff; font-size: 14px; margin-top: 5px;">COMBO: <span id="p1Combo">0</span>x</div>
            </div>
        </div>

        <div class="player-panel player2-panel">
            <div class="player-name">PLAYER 2 [RED]</div>
            <div class="health-display">
                <div class="bar-container">
                    <div class="bar health-bar" id="p2HealthBar" style="width: 100%"></div>
                    <div class="bar-text" id="p2HealthText">100 / 100</div>
                </div>
            </div>
            <div class="weapon-display">
                <div class="weapon-icon" id="p2WeaponIcon">🔫</div>
                <div>
                    <div class="weapon-name" id="p2WeaponName">PISTOL</div>
                    <div class="bar-container" style="width: 150px;">
                        <div class="bar ammo-bar" id="p2AmmoBar" style="width: 100%"></div>
                        <div class="bar-text" id="p2AmmoText">∞</div>
                    </div>
                </div>
            </div>
            <div class="vehicle-status" id="p2Vehicle" style="display: none;"></div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444;">
                <div style="color: #ffaa00; font-size: 14px;">SCORE: <span id="p2Score">0</span></div>
                <div style="color: #ff00ff; font-size: 14px; margin-top: 5px;">COMBO: <span id="p2Combo">0</span>x</div>
            </div>
        </div>

        <div class="kill-feed" id="killFeed"></div>

        <div class="instructions">
            Press E (P1) or ENTER (P2) to interact with vehicles and structures
        </div>
    </div>

    <div id="menu">
        <div class="menu-title">TACTICAL WARFARE</div>
        <div class="menu-subtitle">2D COMBAT SIMULATOR</div>
        <button class="menu-button" onclick="startGame()">START BATTLE</button>

        <div class="controls-display">
            <div class="player-controls player1-controls">
                <div class="controls-header">PLAYER 1 CONTROLS</div>
                <div class="control-row"><span class="key">A</span> <span class="key">D</span> Move Left/Right</div>
                <div class="control-row"><span class="key">W</span> Jump / Climb</div>
                <div class="control-row"><span class="key">S</span> Crouch / Hide</div>
                <div class="control-row"><span class="key">SPACE</span> Shoot</div>
                <div class="control-row"><span class="key">Q</span> Switch Weapon</div>
                <div class="control-row"><span class="key">E</span> Interact (Enter/Exit Vehicle)</div>
                <div class="control-row"><span class="key">R</span> Reload</div>
            </div>
            <div class="player-controls player2-controls">
                <div class="controls-header">PLAYER 2 CONTROLS</div>
                <div class="control-row"><span class="key">←</span> <span class="key">→</span> Move Left/Right</div>
                <div class="control-row"><span class="key">↑</span> Jump / Climb</div>
                <div class="control-row"><span class="key">↓</span> Crouch / Hide</div>
                <div class="control-row"><span class="key">SHIFT</span> Shoot</div>
                <div class="control-row"><span class="key">CTRL</span> Switch Weapon</div>
                <div class="control-row"><span class="key">ENTER</span> Interact (Enter/Exit Vehicle)</div>
                <div class="control-row"><span class="key">0</span> Reload</div>
            </div>
        </div>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-title" id="gameOverTitle">BATTLE OVER</div>
        <div class="winner-announcement" id="winnerText"></div>
        <div class="final-stats" id="finalStatsDisplay"></div>
        <button class="menu-button" onclick="backToMenu()">BACK TO MENU</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GRAVITY = 0.8;
        const JUMP_FORCE = -15;
        const MOVE_SPEED = 5;
        const PLAYER_WIDTH = 30;
        const PLAYER_HEIGHT = 50;

        // World and camera
        const WORLD_WIDTH = 3500;
        const WORLD_HEIGHT = 1400;
        const VIEWPORT_WIDTH = canvas.width;
        const VIEWPORT_HEIGHT = canvas.height;

        let camera = {
            x: 0,
            y: 0,
            targetX: 0,
            targetY: 0,
            smoothing: 0.1
        };

        // Game state
        let gameActive = false;
        let keys = {};
        let bullets = [];
        let particles = [];
        let weapons = [];
        let vehicles = [];
        let structures = [];
        let platforms = [];
        let ladders = [];
        let healthPickups = [];
        let ammoPickups = [];
        let powerUps = [];
        let destructibles = [];

        // Players
        let player1, player2;

        // Weapon types
        const WEAPON_TYPES = {
            PISTOL: {
                name: 'PISTOL',
                icon: '🔫',
                damage: 15,
                fireRate: 300,
                ammo: Infinity,
                maxAmmo: Infinity,
                bulletSpeed: 15,
                bulletSize: 4,
                color: '#ffff00',
                automatic: false
            },
            RIFLE: {
                name: 'RIFLE',
                icon: '🔫',
                damage: 20,
                fireRate: 150,
                ammo: 30,
                maxAmmo: 30,
                bulletSpeed: 20,
                bulletSize: 5,
                color: '#ff6600',
                automatic: true
            },
            SHOTGUN: {
                name: 'SHOTGUN',
                icon: '💥',
                damage: 12,
                fireRate: 600,
                ammo: 8,
                maxAmmo: 8,
                bulletSpeed: 12,
                bulletSize: 6,
                spread: 5,
                pellets: 5,
                color: '#ff0000',
                automatic: false
            },
            SNIPER: {
                name: 'SNIPER',
                icon: '🎯',
                damage: 80,
                fireRate: 1200,
                ammo: 5,
                maxAmmo: 5,
                bulletSpeed: 30,
                bulletSize: 8,
                color: '#00ffff',
                automatic: false
            },
            ROCKET: {
                name: 'ROCKET',
                icon: '🚀',
                damage: 60,
                fireRate: 2000,
                ammo: 3,
                maxAmmo: 3,
                bulletSpeed: 10,
                bulletSize: 12,
                explosive: true,
                explosionRadius: 100,
                color: '#ff00ff',
                automatic: false
            },
            MACHINE_GUN: {
                name: 'MACHINE_GUN',
                icon: '🔫',
                damage: 15,
                fireRate: 80,
                ammo: 100,
                maxAmmo: 100,
                bulletSpeed: 18,
                bulletSize: 4,
                color: '#ffaa00',
                automatic: true
            },
            LASER: {
                name: 'LASER',
                icon: '⚡',
                damage: 25,
                fireRate: 100,
                ammo: 50,
                maxAmmo: 50,
                bulletSpeed: 35,
                bulletSize: 3,
                color: '#00ff00',
                automatic: true
            },
            FLAMETHROWER: {
                name: 'FLAMETHROWER',
                icon: '🔥',
                damage: 8,
                fireRate: 50,
                ammo: 200,
                maxAmmo: 200,
                bulletSpeed: 8,
                bulletSize: 8,
                spread: 8,
                color: '#ff4400',
                automatic: true,
                flame: true
            },
            GRENADE: {
                name: 'GRENADE',
                icon: '💣',
                damage: 70,
                fireRate: 1500,
                ammo: 5,
                maxAmmo: 5,
                throwSpeed: 12,
                bulletSize: 8,
                explosive: true,
                explosionRadius: 120,
                color: '#00aa00',
                automatic: false,
                isGrenade: true
            }
        };

        // Audio System
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine', volume = 0.15) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playShootSound(weaponType) {
            if (weaponType === 'PISTOL') {
                playSound(400, 0.1, 'square', 0.15);
            } else if (weaponType === 'RIFLE') {
                playSound(300, 0.08, 'square', 0.12);
            } else if (weaponType === 'SHOTGUN') {
                playSound(200, 0.15, 'sawtooth', 0.18);
            } else if (weaponType === 'SNIPER') {
                playSound(500, 0.2, 'sine', 0.2);
            } else if (weaponType === 'ROCKET') {
                playSound(150, 0.3, 'sawtooth', 0.2);
            }
        }

        function playExplosionSound() {
            playSound(80, 0.4, 'sawtooth', 0.25);
            setTimeout(() => playSound(40, 0.3, 'sawtooth', 0.2), 50);
        }

        function playHitSound() {
            playSound(250, 0.1, 'triangle', 0.15);
        }

        function playJumpSound() {
            playSound(400, 0.1, 'sine', 0.1);
        }

        function playPickupSound() {
            playSound(600, 0.1, 'sine', 0.15);
            setTimeout(() => playSound(800, 0.1, 'sine', 0.15), 50);
        }

        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' || e.key === 'Shift') e.preventDefault();
        });
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Player class
        class Player {
            constructor(x, y, color, controls, name) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_WIDTH;
                this.height = PLAYER_HEIGHT;
                this.vx = 0;
                this.vy = 0;
                this.color = color;
                this.controls = controls;
                this.name = name;
                this.health = 100;
                this.maxHealth = 100;
                this.facing = 1; // 1 = right, -1 = left
                this.grounded = false;
                this.crouching = false;
                this.onLadder = false;
                this.weapon = {...WEAPON_TYPES.PISTOL};
                this.inventory = [WEAPON_TYPES.PISTOL];
                this.currentWeaponIndex = 0;
                this.lastShot = 0;
                this.inVehicle = null;
                this.nearbyInteractable = null;
                this.kills = 0;
                this.deaths = 0;
                this.activePowerUps = {};
                this.shield = false;
                this.damageMultiplier = 1;
                this.score = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.comboTimeout = 5; // seconds to maintain combo
                this.artilleryCharge = 0;
                this.maxArtilleryCharge = 3; // 3 seconds max charge
                this.isChargingArtillery = false;
            }

            update(deltaTime) {
                // Handle interaction (vehicle exit) BEFORE early return
                if (keys[this.controls.interact] && !this.interactPressed) {
                    this.interact();
                    this.interactPressed = true;
                }
                if (!keys[this.controls.interact]) {
                    this.interactPressed = false;
                }

                // Handle shooting from vehicles
                const currentTime = Date.now();
                if (this.inVehicle) {
                    this.inVehicle.update(this.controls, deltaTime);
                    this.x = this.inVehicle.x;
                    this.y = this.inVehicle.y - this.height;

                    // Tank artillery charging mechanic
                    if (this.inVehicle.vehicleType === 'tank') {
                        if (keys[this.controls.shoot]) {
                            this.isChargingArtillery = true;
                            this.artilleryCharge = Math.min(this.artilleryCharge + deltaTime, this.maxArtilleryCharge);
                        } else if (this.isChargingArtillery) {
                            // Release - fire artillery
                            this.shootFromVehicle();
                            this.isChargingArtillery = false;
                            this.artilleryCharge = 0;
                        }
                    } else {
                        // Other vehicles - normal shooting
                        if (keys[this.controls.shoot]) {
                            if (this.weapon.automatic || !this.lastShotPressed) {
                                if (currentTime - this.lastShot > 200) { // Vehicle fire rate
                                    this.shootFromVehicle();
                                    this.lastShot = currentTime;
                                }
                            }
                            this.lastShotPressed = true;
                        } else {
                            this.lastShotPressed = false;
                        }
                    }

                    // Reload in vehicle
                    if (keys[this.controls.reload] && !this.reloadPressed) {
                        if (this.weapon.ammo < this.weapon.maxAmmo && this.weapon.maxAmmo !== Infinity) {
                            this.weapon.ammo = this.weapon.maxAmmo;
                            playPickupSound();
                        }
                        this.reloadPressed = true;
                    }
                    if (!keys[this.controls.reload]) {
                        this.reloadPressed = false;
                    }

                    return;
                }

                // Movement
                const moveSpeed = this.activePowerUps['speed'] ? MOVE_SPEED * 1.5 : MOVE_SPEED;
                if (keys[this.controls.left]) {
                    this.vx = -moveSpeed;
                    this.facing = -1;
                }
                if (keys[this.controls.right]) {
                    this.vx = moveSpeed;
                    this.facing = 1;
                }

                // Apply friction
                if (!keys[this.controls.left] && !keys[this.controls.right]) {
                    this.vx *= 0.8;
                }

                // Jumping and climbing
                if (keys[this.controls.jump]) {
                    if (this.onLadder) {
                        this.vy = -5;
                        this.grounded = false;
                    } else if (this.grounded) {
                        this.vy = JUMP_FORCE;
                        this.grounded = false;
                        playJumpSound();
                    }
                }

                // Crouching
                this.crouching = keys[this.controls.crouch] && this.grounded;

                // Gravity
                if (!this.onLadder) {
                    this.vy += GRAVITY;
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Ground collision
                this.grounded = false;
                this.onLadder = false;

                // Check platforms
                for (let platform of platforms) {
                    if (this.y + this.height >= platform.y &&
                        this.y + this.height <= platform.y + 20 &&
                        this.x + this.width > platform.x &&
                        this.x < platform.x + platform.width &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height;
                        this.vy = 0;
                        this.grounded = true;
                    }
                }

                // Check ladders
                for (let ladder of ladders) {
                    if (this.x + this.width > ladder.x &&
                        this.x < ladder.x + ladder.width &&
                        this.y + this.height > ladder.y &&
                        this.y < ladder.y + ladder.height) {
                        this.onLadder = true;
                        if (keys[this.controls.jump] || keys[this.controls.crouch]) {
                            this.vy *= 0.8;
                        } else {
                            this.vy = 0;
                        }
                    }
                }

                // Boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > WORLD_WIDTH) this.x = WORLD_WIDTH - this.width;
                if (this.y + this.height > WORLD_HEIGHT) {
                    this.y = WORLD_HEIGHT - this.height;
                    this.vy = 0;
                    this.grounded = true;
                }

                // Shooting (when not in vehicle)
                const fireRate = this.activePowerUps['rapid'] ? this.weapon.fireRate * 0.5 : this.weapon.fireRate;
                if (keys[this.controls.shoot]) {
                    if (this.weapon.automatic || !this.lastShotPressed) {
                        if (currentTime - this.lastShot > fireRate && this.weapon.ammo > 0) {
                            this.shoot();
                            this.lastShot = currentTime;
                        }
                    }
                    this.lastShotPressed = true;
                } else {
                    this.lastShotPressed = false;
                }

                // Weapon switch
                if (keys[this.controls.switch] && !this.switchPressed) {
                    this.currentWeaponIndex = (this.currentWeaponIndex + 1) % this.inventory.length;
                    this.weapon = {...this.inventory[this.currentWeaponIndex]};
                    this.switchPressed = true;
                }
                if (!keys[this.controls.switch]) {
                    this.switchPressed = false;
                }

                // Reload
                if (keys[this.controls.reload] && !this.reloadPressed) {
                    if (this.weapon.ammo < this.weapon.maxAmmo && this.weapon.maxAmmo !== Infinity) {
                        this.weapon.ammo = this.weapon.maxAmmo;
                        playPickupSound();
                    }
                    this.reloadPressed = true;
                }
                if (!keys[this.controls.reload]) {
                    this.reloadPressed = false;
                }

                // Check nearby interactables
                this.checkNearbyInteractables();

                // Weapon pickups
                for (let weapon of weapons) {
                    if (weapon.active && this.collidesWith(weapon)) {
                        this.pickupWeapon(weapon);
                    }
                }

                // Health pickups
                for (let health of healthPickups) {
                    if (health.active && this.collidesWith(health)) {
                        this.health = Math.min(this.health + health.amount, this.maxHealth);
                        health.active = false;
                        playPickupSound();
                        addKillMessage(`${this.name} restored ${health.amount} health!`);
                    }
                }

                // Ammo pickups
                for (let ammo of ammoPickups) {
                    if (ammo.active && this.collidesWith(ammo)) {
                        // Refill all weapons
                        for (let weapon of this.inventory) {
                            weapon.ammo = weapon.maxAmmo;
                        }
                        this.weapon.ammo = this.weapon.maxAmmo;
                        ammo.active = false;
                        playPickupSound();
                        addKillMessage(`${this.name} refilled ammo!`);
                    }
                }

                // Power-ups
                for (let powerUp of powerUps) {
                    if (powerUp.active && this.collidesWith(powerUp)) {
                        this.activatePowerUp(powerUp);
                        powerUp.active = false;
                    }
                }

                // Update active power-ups
                for (let type in this.activePowerUps) {
                    this.activePowerUps[type] -= deltaTime;
                    if (this.activePowerUps[type] <= 0) {
                        this.deactivatePowerUp(type);
                        delete this.activePowerUps[type];
                    }
                }

                // Update combo timer
                if (this.combo > 0) {
                    this.comboTimer -= deltaTime;
                    if (this.comboTimer <= 0) {
                        this.combo = 0;
                    }
                }
            }

            shoot() {
                if (this.weapon.ammo === 0 && this.weapon.ammo !== Infinity) return;

                const bulletX = this.x + (this.facing > 0 ? this.width : 0);
                const bulletY = this.y + this.height / 2;

                if (this.weapon.isGrenade) {
                    // Throw grenade with arc
                    bullets.push(new Grenade(
                        bulletX,
                        bulletY,
                        this.facing * this.weapon.throwSpeed,
                        -8, // Upward throw
                        this.weapon,
                        this
                    ));
                    playExplosionSound();
                } else if (this.weapon.name === 'SHOTGUN') {
                    // Shotgun fires multiple pellets
                    for (let i = 0; i < this.weapon.pellets; i++) {
                        const spread = (Math.random() - 0.5) * this.weapon.spread;
                        bullets.push(new Bullet(
                            bulletX,
                            bulletY,
                            this.facing * this.weapon.bulletSpeed,
                            spread,
                            this.weapon,
                            this
                        ));
                    }
                } else if (this.weapon.flame) {
                    // Flamethrower fires stream of particles
                    for (let i = 0; i < 3; i++) {
                        const spread = (Math.random() - 0.5) * this.weapon.spread;
                        const spreadY = (Math.random() - 0.5) * this.weapon.spread;
                        bullets.push(new Bullet(
                            bulletX,
                            bulletY,
                            this.facing * this.weapon.bulletSpeed + spread,
                            spreadY,
                            this.weapon,
                            this
                        ));
                    }
                } else {
                    bullets.push(new Bullet(
                        bulletX,
                        bulletY,
                        this.facing * this.weapon.bulletSpeed,
                        0,
                        this.weapon,
                        this
                    ));
                }

                if (this.weapon.ammo !== Infinity) {
                    this.weapon.ammo--;
                }

                playShootSound(this.weapon.name);

                // Recoil
                this.vx -= this.facing * 2;
            }

            shootFromVehicle() {
                if (this.inVehicle.vehicleType === 'tank') {
                    // Tank fires artillery with arc based on charge
                    const bulletX = this.inVehicle.x + this.inVehicle.width;
                    const bulletY = this.inVehicle.y + 20;

                    // Calculate velocity based on charge (0-3 seconds)
                    const chargePercent = this.artilleryCharge / this.maxArtilleryCharge;
                    const minSpeed = 15;
                    const maxSpeed = 30;
                    const speed = minSpeed + (maxSpeed - minSpeed) * chargePercent;

                    // Arc angle based on charge (45-75 degrees)
                    const minAngle = 45 * Math.PI / 180;
                    const maxAngle = 75 * Math.PI / 180;
                    const angle = minAngle + (maxAngle - minAngle) * chargePercent;

                    const vx = Math.cos(angle) * speed;
                    const vy = -Math.sin(angle) * speed; // Negative for upward

                    // Tank cannon - explosive rounds
                    const cannonWeapon = {
                        name: 'TANK_CANNON',
                        damage: 50 + chargePercent * 30, // More damage with charge
                        bulletSpeed: speed,
                        bulletSize: 10,
                        color: '#ff6600',
                        explosive: true,
                        explosionRadius: 80 + chargePercent * 40,
                        gravity: true // Artillery rounds affected by gravity
                    };

                    bullets.push(new ArtilleryShell(
                        bulletX,
                        bulletY,
                        vx,
                        vy,
                        cannonWeapon,
                        this
                    ));

                    playShootSound('ROCKET');
                    this.inVehicle.vx -= 3 + chargePercent * 5; // More recoil with charge
                } else if (this.inVehicle.vehicleType === 'jeep') {
                    // Jeep has mounted machine gun
                    const bulletX = this.inVehicle.x + this.inVehicle.width / 2;
                    const bulletY = this.inVehicle.y + 10;

                    bullets.push(new Bullet(
                        bulletX,
                        bulletY,
                        15,
                        (Math.random() - 0.5) * 2,
                        {
                            name: 'MOUNTED_GUN',
                            damage: 18,
                            bulletSpeed: 15,
                            bulletSize: 5,
                            color: '#ffaa00'
                        },
                        this
                    ));

                    playShootSound('RIFLE');
                } else if (this.inVehicle.vehicleType === 'helicopter') {
                    // Helicopter machine gun
                    const bulletX = this.inVehicle.x + this.inVehicle.width / 2;
                    const bulletY = this.inVehicle.y + this.inVehicle.height;

                    bullets.push(new Bullet(
                        bulletX,
                        bulletY,
                        this.vx * 0.5, // Inherit some vehicle velocity
                        12, // Downward
                        {
                            name: 'HELI_GUN',
                            damage: 20,
                            bulletSpeed: 12,
                            bulletSize: 5,
                            color: '#ffaa00'
                        },
                        this
                    ));

                    playShootSound('RIFLE');
                } else if (this.inVehicle.vehicleType === 'airplane') {
                    // Airplane forward guns
                    const bulletX = this.inVehicle.x + this.inVehicle.width;
                    const bulletY = this.inVehicle.y + this.inVehicle.height / 2;

                    // Twin guns
                    for (let i = -1; i <= 1; i += 2) {
                        bullets.push(new Bullet(
                            bulletX,
                            bulletY + i * 15,
                            20, // Fast forward
                            0,
                            {
                                name: 'PLANE_GUN',
                                damage: 22,
                                bulletSpeed: 20,
                                bulletSize: 6,
                                color: '#ff8800'
                            },
                            this
                        ));
                    }

                    playShootSound('RIFLE');
                }
            }

            pickupWeapon(weaponPickup) {
                const newWeapon = {...weaponPickup.type};

                // Check if already have this weapon
                let hasWeapon = false;
                for (let i = 0; i < this.inventory.length; i++) {
                    if (this.inventory[i].name === newWeapon.name) {
                        // Refill ammo
                        this.inventory[i].ammo = newWeapon.maxAmmo;
                        hasWeapon = true;
                        break;
                    }
                }

                if (!hasWeapon) {
                    this.inventory.push(newWeapon);
                    this.currentWeaponIndex = this.inventory.length - 1;
                    this.weapon = {...newWeapon};
                }

                weaponPickup.active = false;
                playPickupSound();
            }

            checkNearbyInteractables() {
                this.nearbyInteractable = null;

                // Check vehicles
                for (let vehicle of vehicles) {
                    if (Math.abs(this.x - vehicle.x) < 100 && Math.abs(this.y - vehicle.y) < 100) {
                        this.nearbyInteractable = vehicle;
                        return;
                    }
                }

                // Check structures
                for (let structure of structures) {
                    if (Math.abs(this.x - structure.x) < 100 && Math.abs(this.y - structure.y) < 100) {
                        this.nearbyInteractable = structure;
                        return;
                    }
                }
            }

            interact() {
                if (this.inVehicle) {
                    // Exit vehicle
                    this.inVehicle = null;
                    playPickupSound();
                } else if (this.nearbyInteractable) {
                    if (this.nearbyInteractable.type === 'vehicle') {
                        // Enter vehicle
                        this.inVehicle = this.nearbyInteractable;
                        playPickupSound();
                    } else if (this.nearbyInteractable.type === 'turret') {
                        // Use turret
                        this.nearbyInteractable.fire(this);
                    }
                }
            }

            activatePowerUp(powerUp) {
                this.activePowerUps[powerUp.type] = powerUp.duration;
                playPickupSound();
                addKillMessage(`${this.name} activated ${powerUp.name}!`);

                if (powerUp.type === 'speed') {
                    // Speed boost already handled in movement
                } else if (powerUp.type === 'shield') {
                    this.shield = true;
                } else if (powerUp.type === 'damage') {
                    this.damageMultiplier = 2;
                } else if (powerUp.type === 'rapid') {
                    // Rapid fire handled in shooting
                }
            }

            deactivatePowerUp(type) {
                if (type === 'shield') {
                    this.shield = false;
                } else if (type === 'damage') {
                    this.damageMultiplier = 1;
                }
                addKillMessage(`${this.name}'s power-up expired!`);
            }

            collidesWith(obj) {
                return this.x < obj.x + obj.width &&
                       this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height &&
                       this.y + this.height > obj.y;
            }

            takeDamage(damage, attacker) {
                // Apply shield protection
                if (this.shield) {
                    damage *= 0.3; // Shield reduces damage by 70%
                }

                // Apply attacker's damage multiplier
                if (attacker && attacker.damageMultiplier) {
                    damage *= attacker.damageMultiplier;
                }

                this.health -= damage;
                playHitSound();

                if (this.health <= 0) {
                    this.die(attacker);
                }

                // Screen shake effect
                createHitParticles(this.x + this.width/2, this.y + this.height/2);
            }

            die(killer) {
                this.health = 0;
                this.deaths++;

                // Reset combo
                this.combo = 0;
                this.comboTimer = 0;

                if (killer) {
                    killer.kills++;

                    // Increase combo
                    killer.combo++;
                    killer.comboTimer = killer.comboTimeout;

                    // Award score with combo multiplier
                    const comboMultiplier = Math.min(killer.combo, 10); // Max 10x
                    const scoreGained = 100 * comboMultiplier;
                    killer.score += scoreGained;

                    if (killer.combo > 1) {
                        addKillMessage(`${killer.name} eliminated ${this.name}! ${killer.combo}x COMBO! +${scoreGained} points`);
                    } else {
                        addKillMessage(`${killer.name} eliminated ${this.name}! +${scoreGained} points`);
                    }
                }

                createExplosion(this.x + this.width/2, this.y + this.height/2, 30);
                playExplosionSound();

                // Check for game over
                if (this.deaths >= 5) {
                    endGame();
                } else {
                    // Respawn after delay
                    setTimeout(() => this.respawn(), 3000);
                }
            }

            respawn() {
                this.health = this.maxHealth;
                this.x = this === player1 ? 100 : canvas.width - 100;
                this.y = 100;
                this.vx = 0;
                this.vy = 0;
                this.weapon = {...WEAPON_TYPES.PISTOL};
                this.inventory = [WEAPON_TYPES.PISTOL];
                this.currentWeaponIndex = 0;
                this.inVehicle = null;
            }

            draw() {
                if (this.health <= 0) return;

                if (this.inVehicle) return; // Don't draw player when in vehicle

                const drawX = this.x - camera.x;
                const drawY = this.y - camera.y;

                ctx.save();

                // Crouching
                let drawHeight = this.height;
                let adjustedDrawY = drawY;
                if (this.crouching) {
                    drawHeight = this.height * 0.6;
                    adjustedDrawY = drawY + this.height * 0.4;
                }

                // Shield effect
                if (this.shield) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(drawX + this.width/2, adjustedDrawY + drawHeight/2, this.width/2 + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Speed boost effect
                if (this.activePowerUps['speed']) {
                    ctx.strokeStyle = '#00ccff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.globalAlpha = 0.3 - i * 0.1;
                        ctx.strokeRect(drawX - i * 5 * this.facing, adjustedDrawY, this.width, drawHeight);
                    }
                    ctx.globalAlpha = 1;
                }

                // Damage boost glow
                if (this.activePowerUps['damage']) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff0000';
                }

                // Artillery charge indicator (when in tank)
                if (this.inVehicle && this.inVehicle.vehicleType === 'tank' && this.isChargingArtillery) {
                    const chargePercent = this.artilleryCharge / this.maxArtilleryCharge;
                    const barWidth = 100;
                    const barHeight = 10;
                    const barX = this.inVehicle.x - camera.x + (this.inVehicle.width - barWidth) / 2;
                    const barY = this.inVehicle.y - camera.y - 30;

                    // Charge bar background
                    ctx.fillStyle = '#222';
                    ctx.fillRect(barX, barY, barWidth, barHeight);

                    // Charge bar fill
                    ctx.fillStyle = chargePercent < 0.33 ? '#ffaa00' : chargePercent < 0.67 ? '#ff6600' : '#ff0000';
                    ctx.fillRect(barX, barY, barWidth * chargePercent, barHeight);

                    // Border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }

                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(drawX, adjustedDrawY, this.width, drawHeight);

                // Outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(drawX, adjustedDrawY, this.width, drawHeight);

                ctx.shadowBlur = 0;

                // Head
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(drawX + this.width/2, adjustedDrawY + 10, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Weapon
                ctx.fillStyle = '#333';
                const weaponLength = 20;
                const weaponX = drawX + (this.facing > 0 ? this.width : 0);
                const weaponY = adjustedDrawY + drawHeight / 2;
                ctx.fillRect(
                    weaponX,
                    weaponY - 2,
                    weaponLength * this.facing,
                    4
                );

                // Rapid fire indicator
                if (this.activePowerUps['rapid']) {
                    ctx.fillStyle = '#ff00ff';
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(
                        weaponX,
                        weaponY - 4,
                        weaponLength * this.facing * 1.2,
                        8
                    );
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, weapon, owner) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.weapon = weapon;
                this.owner = owner;
                this.radius = weapon.bulletSize;
                this.damage = weapon.damage;
                this.color = weapon.color;
                this.life = 3;
            }

            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;

                // Hit detection
                const targets = [player1, player2];
                for (let target of targets) {
                    if (target !== this.owner && target.health > 0 && !target.inVehicle) {
                        const dx = this.x - (target.x + target.width/2);
                        const dy = this.y - (target.y + target.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance < this.radius + target.width/2) {
                            target.takeDamage(this.damage, this.owner);

                            if (this.weapon.explosive) {
                                createExplosion(this.x, this.y, this.weapon.explosionRadius);
                                playExplosionSound();
                            }

                            return true; // Bullet hit
                        }
                    }
                }

                // Check vehicle hits
                for (let vehicle of vehicles) {
                    if (this.x > vehicle.x && this.x < vehicle.x + vehicle.width &&
                        this.y > vehicle.y && this.y < vehicle.y + vehicle.height) {

                        if (this.weapon.explosive) {
                            createExplosion(this.x, this.y, this.weapon.explosionRadius);
                            playExplosionSound();
                        }
                        return true;
                    }
                }

                // Check destructible object hits
                for (let obj of destructibles) {
                    if (!obj.destroyed &&
                        this.x > obj.x && this.x < obj.x + obj.width &&
                        this.y > obj.y && this.y < obj.y + obj.height) {

                        obj.takeDamage(this.damage);

                        if (this.weapon.explosive) {
                            createExplosion(this.x, this.y, this.weapon.explosionRadius);
                            playExplosionSound();

                            // Damage nearby destructibles
                            for (let nearObj of destructibles) {
                                if (!nearObj.destroyed && nearObj !== obj) {
                                    const dx = this.x - (nearObj.x + nearObj.width/2);
                                    const dy = this.y - (nearObj.y + nearObj.height/2);
                                    const distance = Math.sqrt(dx*dx + dy*dy);
                                    if (distance < this.weapon.explosionRadius) {
                                        nearObj.takeDamage(this.damage * 0.5);
                                    }
                                }
                            }
                        }
                        return true;
                    }
                }

                // Out of bounds or lifetime expired
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return true; // Remove bullet
                }

                return false;
            }

            draw() {
                const drawX = this.x - camera.x;
                const drawY = this.y - camera.y;

                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(drawX, drawY, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Trail
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(drawX, drawY);
                ctx.lineTo(drawX - this.vx * 2, drawY - this.vy * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        // Artillery Shell class (for tank artillery)
        class ArtilleryShell {
            constructor(x, y, vx, vy, weapon, owner) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.weapon = weapon;
                this.owner = owner;
                this.radius = weapon.bulletSize;
                this.damage = weapon.damage;
                this.color = weapon.color;
                this.rotation = 0;
                this.trail = [];
            }

            update(deltaTime) {
                // Apply gravity
                this.vy += GRAVITY * 0.8;
                this.x += this.vx;
                this.y += this.vy;

                // Rotation based on velocity
                this.rotation = Math.atan2(this.vy, this.vx);

                // Add to trail
                this.trail.push({x: this.x, y: this.y, life: 0.5});
                if (this.trail.length > 20) this.trail.shift();

                // Update trail
                for (let i = this.trail.length - 1; i >= 0; i--) {
                    this.trail[i].life -= deltaTime;
                    if (this.trail[i].life <= 0) {
                        this.trail.splice(i, 1);
                    }
                }

                // Hit detection
                const targets = [player1, player2];
                for (let target of targets) {
                    if (target !== this.owner && target.health > 0 && !target.inVehicle) {
                        const dx = this.x - (target.x + target.width/2);
                        const dy = this.y - (target.y + target.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance < this.radius + target.width/2) {
                            this.explode();
                            return true;
                        }
                    }
                }

                // Check destructible object hits
                for (let obj of destructibles) {
                    if (!obj.destroyed &&
                        this.x > obj.x && this.x < obj.x + obj.width &&
                        this.y > obj.y && this.y < obj.y + obj.height) {
                        this.explode();
                        obj.takeDamage(this.damage);
                        return true;
                    }
                }

                // Ground/platform collision
                if (this.y + this.radius >= WORLD_HEIGHT - 50) {
                    this.explode();
                    return true;
                }

                for (let platform of platforms) {
                    if (this.y + this.radius >= platform.y &&
                        this.y - this.radius <= platform.y + 20 &&
                        this.x > platform.x &&
                        this.x < platform.x + platform.width) {
                        this.explode();
                        return true;
                    }
                }

                // Out of bounds
                if (this.x < 0 || this.x > WORLD_WIDTH || this.y > WORLD_HEIGHT + 100) {
                    return true;
                }

                return false;
            }

            explode() {
                createExplosion(this.x, this.y, this.weapon.explosionRadius);
                playExplosionSound();

                // Damage all entities in radius
                const targets = [player1, player2];
                for (let target of targets) {
                    if (target !== this.owner && target.health > 0) {
                        const dx = this.x - (target.x + target.width/2);
                        const dy = this.y - (target.y + target.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance < this.weapon.explosionRadius) {
                            const damageMultiplier = 1 - (distance / this.weapon.explosionRadius);
                            const damage = this.damage * damageMultiplier;
                            target.takeDamage(damage, this.owner);
                        }
                    }
                }

                // Damage destructibles in radius
                for (let obj of destructibles) {
                    if (!obj.destroyed) {
                        const dx = this.x - (obj.x + obj.width/2);
                        const dy = this.y - (obj.y + obj.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance < this.weapon.explosionRadius) {
                            obj.takeDamage(this.damage * 0.7);
                        }
                    }
                }
            }

            draw() {
                // Draw smoke trail
                for (let i = 0; i < this.trail.length; i++) {
                    const t = this.trail[i];
                    ctx.fillStyle = `rgba(100, 100, 100, ${t.life})`;
                    ctx.beginPath();
                    ctx.arc(t.x - camera.x, t.y - camera.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw shell
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.rotation);

                ctx.fillStyle = this.color;
                ctx.fillRect(-this.radius, -this.radius/2, this.radius * 2, this.radius);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.radius, -this.radius/2, this.radius * 2, this.radius);

                ctx.restore();

                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.radius/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Grenade class
        class Grenade {
            constructor(x, y, vx, vy, weapon, owner) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.weapon = weapon;
                this.owner = owner;
                this.radius = weapon.bulletSize;
                this.damage = weapon.damage;
                this.color = weapon.color;
                this.fuseTime = 2.5; // Explodes after 2.5 seconds
                this.bounced = false;
            }

            update(deltaTime) {
                // Apply gravity
                this.vy += GRAVITY;
                this.x += this.vx;
                this.y += this.vy;

                // Reduce fuse time
                this.fuseTime -= deltaTime;

                // Check ground collision (bounce once)
                if (this.y + this.radius >= canvas.height - 50) {
                    if (!this.bounced) {
                        this.y = canvas.height - 50 - this.radius;
                        this.vy = -this.vy * 0.5; // Bounce with energy loss
                        this.vx *= 0.7;
                        this.bounced = true;
                        playHitSound();
                    } else {
                        // Second hit = explode
                        this.explode();
                        return true;
                    }
                }

                // Check platform collisions
                for (let platform of platforms) {
                    if (this.y + this.radius >= platform.y &&
                        this.y - this.radius <= platform.y + platform.height &&
                        this.x + this.radius > platform.x &&
                        this.x - this.radius < platform.x + platform.width &&
                        this.vy > 0) {
                        if (!this.bounced) {
                            this.y = platform.y - this.radius;
                            this.vy = -this.vy * 0.5;
                            this.vx *= 0.7;
                            this.bounced = true;
                            playHitSound();
                        } else {
                            this.explode();
                            return true;
                        }
                    }
                }

                // Fuse expired
                if (this.fuseTime <= 0) {
                    this.explode();
                    return true;
                }

                // Out of bounds
                if (this.x < 0 || this.x > canvas.width || this.y > canvas.height + 100) {
                    return true;
                }

                return false;
            }

            explode() {
                createExplosion(this.x, this.y, this.weapon.explosionRadius);
                playExplosionSound();

                // Damage players in radius
                const targets = [player1, player2];
                for (let target of targets) {
                    if (target !== this.owner && target.health > 0) {
                        const dx = this.x - (target.x + target.width/2);
                        const dy = this.y - (target.y + target.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance < this.weapon.explosionRadius) {
                            const damageMultiplier = 1 - (distance / this.weapon.explosionRadius);
                            const damage = this.damage * damageMultiplier;
                            target.takeDamage(damage, this.owner);
                        }
                    }
                }
            }

            draw() {
                // Grenade body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Fuse indicator (flashing when about to explode)
                if (this.fuseTime < 1) {
                    const flash = Math.sin(this.fuseTime * 20) > 0;
                    if (flash) {
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - this.radius, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Trail
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.vx, this.y - this.vy);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        // Vehicle class
        class Vehicle {
            constructor(x, y, vehicleType) {
                this.x = x;
                this.y = y;
                this.type = 'vehicle';
                this.vehicleType = vehicleType;
                this.vx = 0;
                this.vy = 0;
                this.isFlying = false;

                if (vehicleType === 'tank') {
                    this.width = 80;
                    this.height = 60;
                    this.color = '#4a6741';
                    this.maxSpeed = 3;
                    this.isFlying = false;
                } else if (vehicleType === 'jeep') {
                    this.width = 70;
                    this.height = 40;
                    this.color = '#8b7355';
                    this.maxSpeed = 7;
                    this.isFlying = false;
                } else if (vehicleType === 'helicopter') {
                    this.width = 90;
                    this.height = 50;
                    this.color = '#2a4a2a';
                    this.maxSpeed = 6;
                    this.isFlying = true;
                    this.rotorAngle = 0;
                    this.hoverStrength = 0.5;
                } else if (vehicleType === 'airplane') {
                    this.width = 100;
                    this.height = 40;
                    this.color = '#5a7a9a';
                    this.maxSpeed = 10;
                    this.isFlying = true;
                    this.tilt = 0;
                    this.minAltitude = 100;
                }
            }

            update(controls, deltaTime) {
                if (this.vehicleType === 'helicopter') {
                    // Helicopter controls
                    if (keys[controls.left]) {
                        this.vx = -this.maxSpeed;
                    }
                    if (keys[controls.right]) {
                        this.vx = this.maxSpeed;
                    }
                    if (keys[controls.jump]) { // Up
                        this.vy = -this.maxSpeed;
                    }
                    if (keys[controls.crouch]) { // Down
                        this.vy = this.maxSpeed * 0.7;
                    }

                    // Hover damping
                    this.vx *= 0.92;
                    this.vy *= 0.92;

                    // Rotor animation
                    this.rotorAngle += 0.5;

                } else if (this.vehicleType === 'airplane') {
                    // Airplane controls - always moving forward
                    const baseSpeed = this.maxSpeed * 0.7;
                    this.vx = baseSpeed;

                    if (keys[controls.left]) {
                        this.vx -= 2;
                        this.tilt = -0.2;
                    } else if (keys[controls.right]) {
                        this.vx += 2;
                        this.tilt = 0.2;
                    } else {
                        this.tilt *= 0.9;
                    }

                    if (keys[controls.jump]) { // Climb
                        this.vy = -4;
                    } else if (keys[controls.crouch]) { // Dive
                        this.vy = 3;
                    } else {
                        this.vy *= 0.95; // Auto-level
                    }

                    // Maintain minimum altitude
                    if (this.y > WORLD_HEIGHT - this.minAltitude) {
                        this.vy = -2;
                    }

                } else {
                    // Ground vehicles
                    if (keys[controls.left]) {
                        this.vx = -this.maxSpeed;
                    }
                    if (keys[controls.right]) {
                        this.vx = this.maxSpeed;
                    }

                    this.vx *= 0.9;
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > WORLD_WIDTH) this.x = WORLD_WIDTH - this.width;

                if (this.isFlying) {
                    if (this.y < 0) this.y = 0;
                    if (this.y + this.height > WORLD_HEIGHT) this.y = WORLD_HEIGHT - this.height;
                }
            }

            draw() {
                const drawX = this.x - camera.x;
                const drawY = this.y - camera.y;

                ctx.fillStyle = this.color;
                ctx.fillRect(drawX, drawY, this.width, this.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeRect(drawX, drawY, this.width, this.height);

                if (this.vehicleType === 'tank') {
                    // Turret
                    ctx.fillStyle = '#3a5631';
                    ctx.fillRect(drawX + 20, drawY - 15, 40, 20);

                    // Cannon
                    ctx.fillStyle = '#2a4621';
                    ctx.fillRect(drawX + 60, drawY - 5, 30, 8);

                    // Tracks
                    ctx.fillStyle = '#222';
                    ctx.fillRect(drawX, drawY + this.height - 10, this.width, 10);
                } else if (this.vehicleType === 'jeep') {
                    // Windshield
                    ctx.fillStyle = '#4a8090';
                    ctx.fillRect(drawX + 10, drawY + 5, 30, 20);

                    // Wheels
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(drawX + 15, drawY + this.height, 8, 0, Math.PI * 2);
                    ctx.arc(drawX + 55, drawY + this.height, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.vehicleType === 'helicopter') {
                    // Main body
                    ctx.fillStyle = this.color;
                    ctx.fillRect(drawX + 10, drawY + 20, 70, 30);

                    // Cockpit
                    ctx.fillStyle = '#4a8090';
                    ctx.fillRect(drawX + 20, drawY + 22, 30, 20);

                    // Tail
                    ctx.fillStyle = this.color;
                    ctx.fillRect(drawX + 70, drawY + 30, 20, 10);

                    // Main rotor
                    ctx.save();
                    ctx.translate(drawX + 45, drawY + 15);
                    ctx.rotate(this.rotorAngle);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(-40, 0);
                    ctx.lineTo(40, 0);
                    ctx.stroke();
                    ctx.restore();

                    // Tail rotor
                    ctx.save();
                    ctx.translate(drawX + 90, drawY + 35);
                    ctx.rotate(this.rotorAngle * 2);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, 8);
                    ctx.stroke();
                    ctx.restore();

                    // Skids
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(drawX + 15, drawY + 55);
                    ctx.lineTo(drawX + 75, drawY + 55);
                    ctx.stroke();

                } else if (this.vehicleType === 'airplane') {
                    // Fuselage
                    ctx.save();
                    ctx.translate(drawX + this.width/2, drawY + this.height/2);
                    ctx.rotate(this.tilt);

                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.width/2, -10, this.width, 20);

                    // Wings
                    ctx.fillStyle = '#4a6a8a';
                    ctx.fillRect(-20, -30, 40, 60);

                    // Cockpit
                    ctx.fillStyle = '#4a8090';
                    ctx.fillRect(this.width/2 - 30, -8, 20, 16);

                    // Nose
                    ctx.fillStyle = '#3a5a7a';
                    ctx.beginPath();
                    ctx.moveTo(this.width/2, -5);
                    ctx.lineTo(this.width/2 + 15, 0);
                    ctx.lineTo(this.width/2, 5);
                    ctx.fill();

                    // Tail fin
                    ctx.fillStyle = '#4a6a8a';
                    ctx.fillRect(-this.width/2 - 5, -15, 10, 30);

                    ctx.restore();

                    // Propeller (spinning)
                    ctx.save();
                    ctx.translate(drawX + this.width/2 + 15, drawY + this.height/2);
                    ctx.rotate(this.rotorAngle || Date.now() * 0.05);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(-12, 0);
                    ctx.lineTo(12, 0);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                }
            }
        }

        // Structure class (turrets, cannons)
        class Structure {
            constructor(x, y, structureType) {
                this.x = x;
                this.y = y;
                this.type = 'turret';
                this.structureType = structureType;
                this.width = 50;
                this.height = 50;
                this.lastFire = 0;
            }

            fire(player) {
                const currentTime = Date.now();
                if (currentTime - this.lastFire < 500) return;

                const bulletX = this.x + this.width / 2;
                const bulletY = this.y + this.height / 2;

                bullets.push(new Bullet(
                    bulletX,
                    bulletY,
                    player.facing * 20,
                    0,
                    WEAPON_TYPES.RIFLE,
                    player
                ));

                this.lastFire = currentTime;
                playShootSound('RIFLE');
            }

            draw() {
                const drawX = this.x - camera.x;
                const drawY = this.y - camera.y;

                // Base
                ctx.fillStyle = '#555';
                ctx.fillRect(drawX, drawY, this.width, this.height);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 3;
                ctx.strokeRect(drawX, drawY, this.width, this.height);

                // Barrel
                ctx.fillStyle = '#333';
                ctx.fillRect(drawX + this.width, drawY + this.height/2 - 5, 40, 10);
            }
        }

        // Weapon pickup class
        class WeaponPickup {
            constructor(x, y, weaponType) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 20;
                this.type = weaponType;
                this.active = true;
            }

            draw() {
                if (!this.active) return;

                const drawX = this.x - camera.x;
                const drawY = this.y - camera.y;

                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(drawX, drawY, this.width, this.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(drawX, drawY, this.width, this.height);

                // Icon
                ctx.fillStyle = '#000';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type.icon, drawX + this.width/2, drawY + this.height/2 + 5);

                // Floating animation
                this.y += Math.sin(Date.now() * 0.003) * 0.1;
            }
        }

        // Health pickup class
        class HealthPickup {
            constructor(x, y, amount = 50) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.amount = amount;
                this.active = true;
                this.floatOffset = 0;
            }

            draw() {
                if (!this.active) return;

                this.floatOffset += 0.05;
                const floatY = this.y + Math.sin(this.floatOffset) * 5;

                // Health cross
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(this.x + 8, this.y, 9, 25);
                ctx.fillRect(this.x, this.y + 8, 25, 9);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x + 8, floatY, 9, 25);
                ctx.strokeRect(this.x, floatY + 8, 25, 9);

                // Glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff3333';
                ctx.strokeRect(this.x, floatY, this.width, this.height);
                ctx.shadowBlur = 0;
            }
        }

        // Ammo pickup class
        class AmmoPickup {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 20;
                this.active = true;
                this.floatOffset = 0;
            }

            draw() {
                if (!this.active) return;

                this.floatOffset += 0.05;
                const floatY = this.y + Math.sin(this.floatOffset) * 5;

                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(this.x, floatY, this.width, this.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, floatY, this.width, this.height);

                // Ammo icon
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('AMMO', this.x + this.width/2, floatY + this.height/2 + 4);
            }
        }

        // Power-up class
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.type = type; // 'speed', 'shield', 'damage', 'rapid'
                this.active = true;
                this.floatOffset = 0;
                this.duration = 10; // seconds

                // Set colors and icons based on type
                if (type === 'speed') {
                    this.color = '#00ccff';
                    this.icon = '⚡';
                    this.name = 'SPEED BOOST';
                } else if (type === 'shield') {
                    this.color = '#00ff00';
                    this.icon = '🛡';
                    this.name = 'SHIELD';
                } else if (type === 'damage') {
                    this.color = '#ff0000';
                    this.icon = '💪';
                    this.name = 'DAMAGE 2X';
                } else if (type === 'rapid') {
                    this.color = '#ff00ff';
                    this.icon = '🔥';
                    this.name = 'RAPID FIRE';
                }
            }

            draw() {
                if (!this.active) return;

                this.floatOffset += 0.08;
                const floatY = this.y + Math.sin(this.floatOffset) * 8;

                // Outer glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, floatY + this.height/2, this.width/2 + 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

                // Power-up body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, floatY + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Icon
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.icon, this.x + this.width/2, floatY + this.height/2 + 7);
            }
        }

        // Destructible object class
        class DestructibleObject {
            constructor(x, y, width, height, type = 'crate') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.health = 100;
                this.maxHealth = 100;
                this.destroyed = false;
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.destroyed = true;
                    createExplosion(this.x + this.width/2, this.y + this.height/2, 40);
                    playExplosionSound();
                    return true;
                }
                return false;
            }

            draw() {
                if (this.destroyed) return;

                if (this.type === 'crate') {
                    // Wooden crate
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);

                    // Wood planks
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width/3, this.y);
                    ctx.lineTo(this.x + this.width/3, this.y + this.height);
                    ctx.moveTo(this.x + 2*this.width/3, this.y);
                    ctx.lineTo(this.x + 2*this.width/3, this.y + this.height);
                    ctx.stroke();
                } else if (this.type === 'barrel') {
                    // Explosive barrel
                    ctx.fillStyle = '#666';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);

                    // Warning symbol
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', this.x + this.width/2, this.y + this.height/2 + 7);
                }

                // Health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.width;
                    const barHeight = 5;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y - 10, barWidth, barHeight);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x, this.y - 10, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
        }

        // Particle effects
        function createExplosion(x, y, radius) {
            const numParticles = 20;
            for (let i = 0; i < numParticles; i++) {
                const angle = (i / numParticles) * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: `rgb(255, ${Math.floor(Math.random() * 100)}, 0)`,
                    size: 5 + Math.random() * 5
                });
            }
        }

        function createHitParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 0.5,
                    color: '#ff0000',
                    size: 3
                });
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += GRAVITY * 0.5;
                p.life -= deltaTime;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // Initialize game
        function initGame() {
            // Create players
            player1 = new Player(100, 100, '#00ff00', {
                left: 'a',
                right: 'd',
                jump: 'w',
                crouch: 's',
                shoot: ' ',
                switch: 'q',
                reload: 'r',
                interact: 'e'
            }, 'PLAYER 1');

            player2 = new Player(canvas.width - 100, 100, '#ff0000', {
                left: 'arrowleft',
                right: 'arrowright',
                jump: 'arrowup',
                crouch: 'arrowdown',
                shoot: 'shift',
                switch: 'control',
                reload: '0',
                interact: 'enter'
            }, 'PLAYER 2');

            // Create platforms - Much larger map
            platforms = [
                { x: 0, y: WORLD_HEIGHT - 50, width: WORLD_WIDTH, height: 50 }, // Ground

                // Left side
                { x: 200, y: 1100, width: 300, height: 20 },
                { x: 100, y: 900, width: 200, height: 20 },
                { x: 350, y: 700, width: 250, height: 20 },
                { x: 150, y: 500, width: 200, height: 20 },
                { x: 400, y: 300, width: 180, height: 20 },

                // Center-left
                { x: 700, y: 1000, width: 300, height: 20 },
                { x: 650, y: 800, width: 200, height: 20 },
                { x: 800, y: 600, width: 250, height: 20 },
                { x: 700, y: 400, width: 200, height: 20 },
                { x: 850, y: 200, width: 180, height: 20 },

                // Center
                { x: 1400, y: 1100, width: 400, height: 20 },
                { x: 1300, y: 900, width: 300, height: 20 },
                { x: 1500, y: 700, width: 250, height: 20 },
                { x: 1350, y: 500, width: 300, height: 20 },
                { x: 1600, y: 300, width: 200, height: 20 },

                // Center-right
                { x: 2100, y: 1000, width: 300, height: 20 },
                { x: 2200, y: 800, width: 250, height: 20 },
                { x: 2050, y: 600, width: 200, height: 20 },
                { x: 2300, y: 400, width: 250, height: 20 },
                { x: 2150, y: 200, width: 200, height: 20 },

                // Right side
                { x: 2700, y: 1100, width: 300, height: 20 },
                { x: 2800, y: 900, width: 250, height: 20 },
                { x: 2650, y: 700, width: 300, height: 20 },
                { x: 2900, y: 500, width: 200, height: 20 },
                { x: 2750, y: 300, width: 250, height: 20 },

                // High platforms
                { x: 600, y: 150, width: 200, height: 20 },
                { x: 1750, y: 100, width: 250, height: 20 },
                { x: 2800, y: 150, width: 200, height: 20 }
            ];

            // Create ladders - More across the map
            ladders = [
                // Left
                { x: 150, y: 500, width: 30, height: 400 },
                { x: 350, y: 700, width: 30, height: 400 },
                { x: 500, y: 300, width: 30, height: 400 },

                // Center-left
                { x: 700, y: 400, width: 30, height: 600 },
                { x: 850, y: 600, width: 30, height: 400 },

                // Center
                { x: 1350, y: 500, width: 30, height: 600 },
                { x: 1600, y: 300, width: 30, height: 400 },
                { x: 1750, y: 100, width: 30, height: 600 },

                // Center-right
                { x: 2100, y: 600, width: 30, height: 400 },
                { x: 2300, y: 400, width: 30, height: 600 },

                // Right
                { x: 2700, y: 700, width: 30, height: 400 },
                { x: 2900, y: 500, width: 30, height: 500 },
                { x: 3050, y: 300, width: 30, height: 700 }
            ];

            // Create vehicles - Ground and air
            vehicles = [
                // Ground vehicles
                new Vehicle(300, WORLD_HEIGHT - 110, 'tank'),
                new Vehicle(900, WORLD_HEIGHT - 90, 'jeep'),
                new Vehicle(1600, WORLD_HEIGHT - 110, 'tank'),
                new Vehicle(2400, WORLD_HEIGHT - 90, 'jeep'),
                new Vehicle(3000, WORLD_HEIGHT - 110, 'tank'),

                // Helicopters
                new Vehicle(600, 400, 'helicopter'),
                new Vehicle(1750, 300, 'helicopter'),
                new Vehicle(2800, 500, 'helicopter'),

                // Airplanes
                new Vehicle(400, 200, 'airplane'),
                new Vehicle(1900, 250, 'airplane'),
                new Vehicle(3100, 300, 'airplane')
            ];

            // Create structures - Turrets across the map
            structures = [
                new Structure(500, WORLD_HEIGHT - 100, 'turret'),
                new Structure(1200, 1050, 'turret'),
                new Structure(850, 150, 'turret'),
                new Structure(1800, 650, 'turret'),
                new Structure(2300, 350, 'turret'),
                new Structure(2900, WORLD_HEIGHT - 100, 'turret'),
                new Structure(3200, 250, 'turret')
            ];

            // Create weapon pickups - Spread across the map
            weapons = [
                // Left side
                new WeaponPickup(250, 850, WEAPON_TYPES.RIFLE),
                new WeaponPickup(350, 650, WEAPON_TYPES.SHOTGUN),
                new WeaponPickup(150, 450, WEAPON_TYPES.SNIPER),
                new WeaponPickup(450, 250, WEAPON_TYPES.GRENADE),

                // Center-left
                new WeaponPickup(750, 950, WEAPON_TYPES.MACHINE_GUN),
                new WeaponPickup(800, 550, WEAPON_TYPES.LASER),
                new WeaponPickup(850, 150, WEAPON_TYPES.ROCKET),

                // Center
                new WeaponPickup(1400, 1050, WEAPON_TYPES.RIFLE),
                new WeaponPickup(1500, 650, WEAPON_TYPES.FLAMETHROWER),
                new WeaponPickup(1600, 250, WEAPON_TYPES.SHOTGUN),
                new WeaponPickup(1750, 50, WEAPON_TYPES.SNIPER),

                // Center-right
                new WeaponPickup(2100, 950, WEAPON_TYPES.MACHINE_GUN),
                new WeaponPickup(2200, 750, WEAPON_TYPES.ROCKET),
                new WeaponPickup(2300, 350, WEAPON_TYPES.LASER),

                // Right side
                new WeaponPickup(2700, 1050, WEAPON_TYPES.SHOTGUN),
                new WeaponPickup(2800, 850, WEAPON_TYPES.GRENADE),
                new WeaponPickup(2900, 450, WEAPON_TYPES.FLAMETHROWER),
                new WeaponPickup(3100, 250, WEAPON_TYPES.RIFLE)
            ];

            // Create health pickups - Spread across the map
            healthPickups = [
                new HealthPickup(200, 1050, 50),
                new HealthPickup(350, 850, 30),
                new HealthPickup(700, 900, 50),
                new HealthPickup(800, 550, 75),
                new HealthPickup(1400, 1050, 50),
                new HealthPickup(1500, 650, 30),
                new HealthPickup(1750, 50, 75),
                new HealthPickup(2100, 950, 50),
                new HealthPickup(2300, 350, 30),
                new HealthPickup(2800, 850, 50),
                new HealthPickup(3000, WORLD_HEIGHT - 100, 75),
                new HealthPickup(1750, 700, 30)
            ];

            // Create ammo pickups - Spread across the map
            ammoPickups = [
                new AmmoPickup(300, 1050),
                new AmmoPickup(450, 650),
                new AmmoPickup(800, 950),
                new AmmoPickup(650, 750),
                new AmmoPickup(1300, 850),
                new AmmoPickup(1600, 650),
                new AmmoPickup(1800, 250),
                new AmmoPickup(2050, 550),
                new AmmoPickup(2400, 900),
                new AmmoPickup(2700, 1050),
                new AmmoPickup(2900, 650),
                new AmmoPickup(3200, 450)
            ];

            // Create power-ups - Spread across the map
            powerUps = [
                new PowerUp(250, 450, 'speed'),
                new PowerUp(500, 250, 'shield'),
                new PowerUp(850, 550, 'damage'),
                new PowerUp(700, 350, 'rapid'),
                new PowerUp(1350, 450, 'speed'),
                new PowerUp(1750, 250, 'shield'),
                new PowerUp(2150, 150, 'damage'),
                new PowerUp(2300, 750, 'rapid'),
                new PowerUp(2750, 250, 'speed'),
                new PowerUp(3000, 450, 'shield')
            ];

            // Create destructible objects - Spread across the map
            destructibles = [
                // Left
                new DestructibleObject(250, WORLD_HEIGHT - 100, 50, 50, 'crate'),
                new DestructibleObject(350, WORLD_HEIGHT - 100, 50, 50, 'barrel'),
                new DestructibleObject(200, 1050, 50, 50, 'crate'),
                new DestructibleObject(300, 850, 50, 50, 'barrel'),
                new DestructibleObject(400, 650, 50, 50, 'crate'),

                // Center-left
                new DestructibleObject(700, WORLD_HEIGHT - 100, 50, 50, 'barrel'),
                new DestructibleObject(800, 950, 50, 50, 'crate'),
                new DestructibleObject(750, 750, 50, 50, 'barrel'),
                new DestructibleObject(850, 550, 50, 50, 'crate'),

                // Center
                new DestructibleObject(1400, 1050, 50, 50, 'crate'),
                new DestructibleObject(1500, WORLD_HEIGHT - 100, 50, 50, 'barrel'),
                new DestructibleObject(1600, 850, 50, 50, 'crate'),
                new DestructibleObject(1700, 650, 50, 50, 'barrel'),
                new DestructibleObject(1750, 450, 50, 50, 'crate'),

                // Center-right
                new DestructibleObject(2100, 950, 50, 50, 'barrel'),
                new DestructibleObject(2200, 750, 50, 50, 'crate'),
                new DestructibleObject(2300, WORLD_HEIGHT - 100, 50, 50, 'barrel'),
                new DestructibleObject(2400, 550, 50, 50, 'crate'),

                // Right
                new DestructibleObject(2700, 1050, 50, 50, 'crate'),
                new DestructibleObject(2800, WORLD_HEIGHT - 100, 50, 50, 'barrel'),
                new DestructibleObject(2900, 850, 50, 50, 'crate'),
                new DestructibleObject(3000, 650, 50, 50, 'barrel'),
                new DestructibleObject(3100, 450, 50, 50, 'crate'),
                new DestructibleObject(3200, WORLD_HEIGHT - 100, 50, 50, 'barrel')
            ];
        }

        // Update camera
        function updateCamera() {
            // Follow midpoint between players
            const midX = (player1.x + player2.x) / 2;
            const midY = (player1.y + player2.y) / 2;

            camera.targetX = midX - VIEWPORT_WIDTH / 2;
            camera.targetY = midY - VIEWPORT_HEIGHT / 2;

            // Smoothly move camera
            camera.x += (camera.targetX - camera.x) * camera.smoothing;
            camera.y += (camera.targetY - camera.y) * camera.smoothing;

            // Clamp camera to world bounds
            camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - VIEWPORT_WIDTH));
            camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - VIEWPORT_HEIGHT));
        }

        // Update game
        function update(deltaTime) {
            if (!gameActive) return;

            player1.update(deltaTime);
            player2.update(deltaTime);

            // Update camera
            updateCamera();

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (bullets[i].update(deltaTime)) {
                    bullets.splice(i, 1);
                }
            }

            // Update particles
            updateParticles(deltaTime);

            // Respawn pickups
            for (let weapon of weapons) {
                if (!weapon.active && !weapon.respawnTimer) {
                    weapon.respawnTimer = setTimeout(() => {
                        weapon.active = true;
                        weapon.respawnTimer = null;
                    }, 15000);
                }
            }

            for (let health of healthPickups) {
                if (!health.active && !health.respawnTimer) {
                    health.respawnTimer = setTimeout(() => {
                        health.active = true;
                        health.respawnTimer = null;
                    }, 20000);
                }
            }

            for (let ammo of ammoPickups) {
                if (!ammo.active && !ammo.respawnTimer) {
                    ammo.respawnTimer = setTimeout(() => {
                        ammo.active = true;
                        ammo.respawnTimer = null;
                    }, 18000);
                }
            }

            for (let powerUp of powerUps) {
                if (!powerUp.active && !powerUp.respawnTimer) {
                    powerUp.respawnTimer = setTimeout(() => {
                        powerUp.active = true;
                        powerUp.respawnTimer = null;
                    }, 30000);
                }
            }
        }

        // Draw game
        function draw() {
            // Background
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground/sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87ceeb');
            gradient.addColorStop(0.7, '#c9e4ff');
            gradient.addColorStop(1, '#8b7355');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw platforms with camera offset
            ctx.fillStyle = '#654321';
            for (let platform of platforms) {
                const drawX = platform.x - camera.x;
                const drawY = platform.y - camera.y;
                ctx.fillRect(drawX, drawY, platform.width, platform.height);
                ctx.strokeStyle = '#4a3319';
                ctx.lineWidth = 2;
                ctx.strokeRect(drawX, drawY, platform.width, platform.height);
            }

            // Draw ladders with camera offset
            ctx.strokeStyle = '#8b7355';
            ctx.lineWidth = 3;
            for (let ladder of ladders) {
                const drawX = ladder.x - camera.x;
                const drawY = ladder.y - camera.y;
                for (let y = 0; y < ladder.height; y += 15) {
                    ctx.beginPath();
                    ctx.moveTo(drawX, drawY + y);
                    ctx.lineTo(drawX + ladder.width, drawY + y);
                    ctx.stroke();
                }
                ctx.strokeRect(drawX, drawY, ladder.width, ladder.height);
            }

            // Draw structures
            for (let structure of structures) {
                structure.draw();
            }

            // Draw destructible objects
            for (let obj of destructibles) {
                obj.draw();
            }

            // Draw vehicles
            for (let vehicle of vehicles) {
                vehicle.draw();
            }

            // Draw health pickups
            for (let health of healthPickups) {
                health.draw();
            }

            // Draw ammo pickups
            for (let ammo of ammoPickups) {
                ammo.draw();
            }

            // Draw power-ups
            for (let powerUp of powerUps) {
                powerUp.draw();
            }

            // Draw weapon pickups
            for (let weapon of weapons) {
                weapon.draw();
            }

            // Draw bullets
            for (let bullet of bullets) {
                bullet.draw();
            }

            // Draw particles
            drawParticles();

            // Draw players
            player1.draw();
            player2.draw();

            // Draw interaction prompts with camera offset
            if (player1.nearbyInteractable) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('[E] Interact', player1.x - camera.x + player1.width/2, player1.y - camera.y - 10);
            }
            if (player2.nearbyInteractable) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('[ENTER] Interact', player2.x - camera.x + player2.width/2, player2.y - camera.y - 10);
            }
        }

        // Update HUD
        function updateHUD() {
            // Player 1
            const p1HealthPercent = (player1.health / player1.maxHealth) * 100;
            document.getElementById('p1HealthBar').style.width = p1HealthPercent + '%';
            document.getElementById('p1HealthText').textContent = `${Math.max(0, Math.floor(player1.health))} / ${player1.maxHealth}`;
            document.getElementById('p1WeaponIcon').textContent = player1.weapon.icon;
            document.getElementById('p1WeaponName').textContent = player1.weapon.name;

            if (player1.weapon.maxAmmo === Infinity) {
                document.getElementById('p1AmmoBar').style.width = '100%';
                document.getElementById('p1AmmoText').textContent = '∞';
            } else {
                const p1AmmoPercent = (player1.weapon.ammo / player1.weapon.maxAmmo) * 100;
                document.getElementById('p1AmmoBar').style.width = p1AmmoPercent + '%';
                document.getElementById('p1AmmoText').textContent = `${player1.weapon.ammo} / ${player1.weapon.maxAmmo}`;
            }

            if (player1.inVehicle) {
                document.getElementById('p1Vehicle').style.display = 'block';
                document.getElementById('p1Vehicle').textContent = `IN ${player1.inVehicle.vehicleType.toUpperCase()}`;
            } else {
                document.getElementById('p1Vehicle').style.display = 'none';
            }

            document.getElementById('p1Score').textContent = player1.score;
            document.getElementById('p1Combo').textContent = player1.combo;

            // Player 2
            const p2HealthPercent = (player2.health / player2.maxHealth) * 100;
            document.getElementById('p2HealthBar').style.width = p2HealthPercent + '%';
            document.getElementById('p2HealthText').textContent = `${Math.max(0, Math.floor(player2.health))} / ${player2.maxHealth}`;
            document.getElementById('p2WeaponIcon').textContent = player2.weapon.icon;
            document.getElementById('p2WeaponName').textContent = player2.weapon.name;

            if (player2.weapon.maxAmmo === Infinity) {
                document.getElementById('p2AmmoBar').style.width = '100%';
                document.getElementById('p2AmmoText').textContent = '∞';
            } else {
                const p2AmmoPercent = (player2.weapon.ammo / player2.weapon.maxAmmo) * 100;
                document.getElementById('p2AmmoBar').style.width = p2AmmoPercent + '%';
                document.getElementById('p2AmmoText').textContent = `${player2.weapon.ammo} / ${player2.weapon.maxAmmo}`;
            }

            if (player2.inVehicle) {
                document.getElementById('p2Vehicle').style.display = 'block';
                document.getElementById('p2Vehicle').textContent = `IN ${player2.inVehicle.vehicleType.toUpperCase()}`;
            } else {
                document.getElementById('p2Vehicle').style.display = 'none';
            }

            document.getElementById('p2Score').textContent = player2.score;
            document.getElementById('p2Combo').textContent = player2.combo;
        }

        // Kill feed
        function addKillMessage(message) {
            const feed = document.getElementById('killFeed');
            const msg = document.createElement('div');
            msg.className = 'kill-message';
            msg.textContent = message;
            feed.appendChild(msg);

            setTimeout(() => msg.remove(), 4000);
        }

        // Menu functions
        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            initGame();
            gameActive = true;
        }

        function endGame() {
            gameActive = false;

            const screen = document.getElementById('gameOverScreen');
            const title = document.getElementById('gameOverTitle');
            const winnerText = document.getElementById('winnerText');
            const stats = document.getElementById('finalStatsDisplay');

            let winner, winnerColor;
            if (player1.kills > player2.kills) {
                winner = 'PLAYER 1 WINS!';
                winnerColor = '#00ff00';
            } else if (player2.kills > player1.kills) {
                winner = 'PLAYER 2 WINS!';
                winnerColor = '#ff0000';
            } else {
                winner = 'DRAW!';
                winnerColor = '#ffaa00';
            }

            title.style.color = winnerColor;
            winnerText.textContent = winner;
            winnerText.style.color = winnerColor;

            stats.innerHTML = `
                <div class="stat-line">
                    <span>Player 1 Score:</span>
                    <span style="color: #00ff00">${player1.score}</span>
                </div>
                <div class="stat-line">
                    <span>Player 1 Kills:</span>
                    <span style="color: #00ff00">${player1.kills}</span>
                </div>
                <div class="stat-line">
                    <span>Player 1 Deaths:</span>
                    <span style="color: #00ff00">${player1.deaths}</span>
                </div>
                <hr style="margin: 15px 0; border-color: #444;">
                <div class="stat-line">
                    <span>Player 2 Score:</span>
                    <span style="color: #ff0000">${player2.score}</span>
                </div>
                <div class="stat-line">
                    <span>Player 2 Kills:</span>
                    <span style="color: #ff0000">${player2.kills}</span>
                </div>
                <div class="stat-line">
                    <span>Player 2 Deaths:</span>
                    <span style="color: #ff0000">${player2.deaths}</span>
                </div>
            `;

            screen.classList.add('show');
        }

        function backToMenu() {
            document.getElementById('gameOverScreen').classList.remove('show');
            document.getElementById('menu').classList.remove('hidden');

            // Reset
            bullets = [];
            particles = [];
            weapons = [];
            vehicles = [];
            structures = [];
            platforms = [];
            ladders = [];
            healthPickups = [];
            ammoPickups = [];
            powerUps = [];
            destructibles = [];
        }

        // Game loop
        let lastTime = performance.now();

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            update(deltaTime);
            draw();
            updateHUD();
        }

        // Start
        gameLoop();
    </script>
</body>
</html>
