<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Counter-Strike: de_dust2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            color: white;
        }

        /* CS-Style Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
        }

        .crosshair-line {
            position: absolute;
            background: rgba(0, 255, 0, 0.8);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        .crosshair-top {
            width: 2px;
            height: 8px;
            left: 19px;
            top: 6px;
        }

        .crosshair-bottom {
            width: 2px;
            height: 8px;
            left: 19px;
            bottom: 6px;
        }

        .crosshair-left {
            width: 8px;
            height: 2px;
            left: 6px;
            top: 19px;
        }

        .crosshair-right {
            width: 8px;
            height: 2px;
            right: 6px;
            top: 19px;
        }

        /* CS-Style HUD */
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.85));
            padding: 15px 20px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 3px;
            min-width: 280px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .stat-icon {
            font-size: 20px;
            margin-right: 10px;
            width: 25px;
        }

        .health-display {
            display: flex;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
        }

        .ammo-display {
            display: flex;
            align-items: center;
            font-size: 28px;
            font-weight: bold;
            color: #ffaa00;
        }

        .ammo-mag {
            font-size: 36px;
            margin-right: 5px;
        }

        .ammo-reserve {
            font-size: 20px;
            color: #999;
        }

        .score-display {
            font-size: 18px;
            color: #00ff00;
            font-weight: bold;
        }

        .enemy-display {
            font-size: 18px;
            color: #ff6600;
            font-weight: bold;
        }

        /* Weapon Name */
        #weaponName {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 10, 0.95));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }

        #startScreen h1 {
            font-size: 64px;
            margin-bottom: 5px;
            color: #ff6600;
            text-shadow: 0 0 30px #ff6600, 0 0 60px #ff3300;
            font-family: 'Impact', sans-serif;
            letter-spacing: 4px;
        }

        #startScreen h2 {
            font-size: 36px;
            margin-bottom: 40px;
            color: #ffaa00;
            font-family: 'Impact', sans-serif;
        }

        #startScreen p {
            font-size: 18px;
            margin: 8px 0;
            color: #ccc;
        }

        #startButton {
            margin-top: 50px;
            padding: 20px 60px;
            font-size: 26px;
            background: linear-gradient(135deg, #ff6600, #ff3300);
            color: #fff;
            border: 2px solid #ffaa00;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            font-weight: bold;
            font-family: 'Impact', sans-serif;
            text-transform: uppercase;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(255, 102, 0, 0.5);
        }

        #startButton:hover {
            background: linear-gradient(135deg, #ff8833, #ff4422);
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(255, 102, 0, 0.8);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(30, 10, 10, 0.95));
            padding: 50px 60px;
            border: 3px solid #ff0000;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 300;
            pointer-events: all;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
        }

        #gameOver h2 {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #ff0000;
            font-family: 'Impact', sans-serif;
        }

        #gameOver p {
            font-size: 24px;
            color: white;
            margin: 15px 0;
        }

        #restartButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 22px;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            color: white;
            border: 2px solid #ff4444;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Impact', sans-serif;
            transition: all 0.3s ease;
        }

        #restartButton:hover {
            background: linear-gradient(135deg, #ff4444, #ff0000);
            transform: scale(1.05);
        }

        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            display: none;
            pointer-events: none;
        }

        #hitMarker::before,
        #hitMarker::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background: #fff;
            top: 50%;
            left: 0;
            box-shadow: 0 0 10px #fff;
        }

        #hitMarker::before {
            transform: rotate(45deg);
        }

        #hitMarker::after {
            transform: rotate(-45deg);
        }

        .controls-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 20, 0.8));
            padding: 15px 20px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 3px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .controls-info div {
            margin: 4px 0;
            color: #ccc;
        }

        .controls-info strong {
            color: #00ff00;
        }

        #killFeed {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #fff;
            display: none;
            animation: fadeOut 3s forwards;
        }

        @keyframes fadeOut {
            0%, 80% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="crosshair">
                <div class="crosshair-line crosshair-top"></div>
                <div class="crosshair-line crosshair-bottom"></div>
                <div class="crosshair-line crosshair-left"></div>
                <div class="crosshair-line crosshair-right"></div>
            </div>
            <div id="hitMarker"></div>
            <div id="killFeed"></div>

            <div id="stats">
                <div class="stat-row">
                    <span class="stat-icon">‚ù§Ô∏è</span>
                    <div class="health-display" id="healthValue">100</div>
                </div>
                <div class="stat-row">
                    <span class="stat-icon">üî´</span>
                    <div class="ammo-display">
                        <span class="ammo-mag" id="ammoMag">30</span>
                        <span class="ammo-reserve" id="ammoReserve">/ 90</span>
                    </div>
                </div>
                <div class="stat-row">
                    <span class="stat-icon">‚≠ê</span>
                    <div class="score-display" id="scoreValue">Score: 0</div>
                </div>
                <div class="stat-row">
                    <span class="stat-icon">‚ò†Ô∏è</span>
                    <div class="enemy-display" id="enemyValue">Enemies: 0</div>
                </div>
            </div>

            <div id="weaponName">AK-47</div>

            <div class="controls-info">
                <div><strong>CONTROLS</strong></div>
                <div>W/A/S/D - Move</div>
                <div>SHIFT - Sprint</div>
                <div>SPACE - Jump</div>
                <div>MOUSE - Aim</div>
                <div>LEFT CLICK - Shoot</div>
                <div>R - Reload</div>
                <div>ESC - Unlock Mouse</div>
            </div>

            <div id="gameOver">
                <h2>TERRORISTS WIN</h2>
                <p id="finalScore">Final Score: 0</p>
                <button id="restartButton" onclick="location.reload()">RESTART MISSION</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>COUNTER-STRIKE</h1>
            <h2>DE_DUST2</h2>
            <p>Mission: Eliminate all 8 terrorists</p>
            <p>Classic CS map with realistic bullet physics</p>
            <p>‚ö†Ô∏è Bullets travel - you can dodge them!</p>
            <button id="startButton">Enter Combat</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game configuration
        const config = {
            player: {
                health: 100,
                speed: 0.18,
                sprintSpeed: 0.32,
                jumpPower: 0.35,
                height: 1.7,
                gravity: 0.025,
                damage: 35
            },
            weapon: {
                magazineSize: 30,
                totalAmmo: 90,
                reloadTime: 2500,
                fireRate: 120,
                bulletSpeed: 1.2, // Bullets travel at this speed
                bulletLifetime: 3000 // Bullets disappear after 3 seconds
            },
            bot: {
                count: 8,
                health: 100,
                speed: 0.09,
                damage: 18,
                shootRange: 40,
                detectionRange: 50,
                shootInterval: 1800,
                bulletSpeed: 0.9, // Bot bullets are slightly slower
                accuracy: 0.25 // Higher = less accurate
            }
        };

        // Game state
        let scene, camera, renderer;
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isSprinting = false;
        let canJump = false;
        let isReloading = false;
        let canShoot = true;
        let gameStarted = false;
        let pointerLocked = false;

        // Camera rotation
        let yaw = 0;
        let pitch = 0;

        // Game stats
        let health = config.player.health;
        let ammo = config.weapon.magazineSize;
        let reserveAmmo = config.weapon.totalAmmo;
        let score = 0;

        // Objects
        let bots = [];
        let bullets = []; // Now we track actual bullet objects!
        let walls = [];
        let playerCollisionObjects = [];

        // Raycaster for shooting
        const raycaster = new THREE.Raycaster();

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 130);

            // Camera (player view)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-40, config.player.height, -40); // CT Spawn

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffee, 0.95);
            sunLight.position.set(60, 100, 40);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -80;
            sunLight.shadow.camera.right = 80;
            sunLight.shadow.camera.top = 80;
            sunLight.shadow.camera.bottom = -80;
            scene.add(sunLight);

            // Create authentic de_dust2 map
            createDust2Map();

            // Create bots
            createBots();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
            document.addEventListener('mousemove', onMouseMove);
            document.getElementById('startButton').addEventListener('click', startGame);

            // Pointer lock
            renderer.domElement.addEventListener('click', () => {
                if (gameStarted && !pointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === renderer.domElement;
            });

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createDust2Map() {
            // Ground with texture-like appearance
            const groundGeometry = new THREE.PlaneGeometry(150, 150);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xC9A876,
                roughness: 0.95,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Materials with better CS-like colors
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0xB89968,
                roughness: 0.9,
                metalness: 0.1
            });
            const darkWallMat = new THREE.MeshStandardMaterial({
                color: 0x8B7355,
                roughness: 0.95,
                metalness: 0.05
            });
            const doorMat = new THREE.MeshStandardMaterial({
                color: 0x6B4423,
                roughness: 0.7,
                metalness: 0.2
            });

            // === OUTER BOUNDARIES ===
            createWall(-70, 0, 0, 2, 12, 140, wallMat);
            createWall(70, 0, 0, 2, 12, 140, wallMat);
            createWall(0, 0, -70, 140, 12, 2, wallMat);
            createWall(0, 0, 70, 140, 12, 2, wallMat);

            // === CT SPAWN ===
            createBox(-50, 0.5, -50, 3, 1, 3, 0x8B6914);
            createBox(-45, 0.5, -55, 2, 1, 2, 0x654321);
            createBox(-55, 0.75, -48, 2.5, 1.5, 2.5, 0x704214);

            // === T SPAWN ===
            createBox(50, 0.5, 50, 3, 1, 3, 0x8B6914);
            createBox(55, 0.5, 45, 2, 1, 2, 0x654321);
            createBox(48, 0.75, 55, 2.5, 1.5, 2.5, 0x704214);

            // === LONG A CORRIDOR ===
            createWall(-25, 0, -35, 2, 7, 45, darkWallMat);
            createWall(-15, 0, -35, 2, 7, 45, darkWallMat);

            // THE FAMOUS CAR
            createBox(-20, 0.9, -25, 3.2, 1.8, 5.5, 0x2F4F4F);
            createBox(-20, 0.3, -27.5, 2.8, 0.6, 1.2, 0x0a0a0a);
            createBox(-20, 0.3, -22.5, 2.8, 0.6, 1.2, 0x0a0a0a);
            // Car windows
            createBox(-20, 1.3, -25, 2.8, 0.6, 3, 0x1a3a3a);

            // Long A boxes
            createBox(-20, 1, -45, 2.5, 2, 2.5, 0x8B6914);
            createBox(-17, 0.5, -50, 2, 1, 2, 0x654321);
            createBox(-23, 0.75, -42, 2, 1.5, 2, 0x704214);

            // === SHORT A / CATWALK ===
            createWall(5, 0, -35, 16, 2.5, 22, wallMat);
            createWall(5, 1.8, -35, 2, 1.2, 22, darkWallMat);
            createBox(8, 1.8, -28, 2, 1, 2, 0x654321);

            // === A SITE ===
            createWall(-5, 0, -5, 22, 3.5, 22, darkWallMat);

            // A site boxes (ninja spot, default, etc)
            createBox(0, 2.5, 0, 3, 2, 3, 0x8B6914);
            createBox(-8, 2.5, -2, 2.5, 2, 2.5, 0x654321);
            createBox(5, 2.5, -8, 2.5, 2, 2.5, 0x704214);
            createBox(-10, 1.8, 5, 3, 3.6, 2, 0x696969);
            createBox(3, 2, -4, 2, 2, 2, 0x5a4a2a);

            // === MID ===
            createWall(0, 0, 15, 2, 6, 10, doorMat);
            createWall(0, 0, 5, 2, 6, 10, doorMat);

            createBox(-8, 1, 10, 2.5, 2, 2.5, 0x8B6914);
            createBox(8, 0.5, 8, 2, 1, 2, 0x654321);
            createBox(-4, 0.75, 18, 2.5, 1.5, 2.5, 0x704214);

            createWall(15, 0, 25, 2, 6, 18, darkWallMat);

            // === B TUNNELS ===
            createWall(30, 0, 20, 28, 6, 2, wallMat);
            createWall(30, 0, 10, 28, 6, 2, wallMat);
            createWall(30, 0, 35, 28, 6, 2, wallMat);
            createWall(30, 0, 45, 28, 6, 2, wallMat);

            createBox(35, 1, 15, 2.5, 2, 2.5, 0x654321);
            createBox(25, 0.5, 40, 2, 1, 2, 0x8B6914);
            createBox(38, 0.75, 38, 2, 1.5, 2, 0x704214);

            // === B SITE ===
            createWall(45, 0, 20, 2, 7, 32, darkWallMat);
            createWall(30, 0, 5, 32, 7, 2, darkWallMat);

            // B window
            createWall(42, 0, 8, 9, 3, 7, wallMat);

            // B site boxes
            createBox(35, 1, 15, 3.5, 2, 3.5, 0x8B6914);
            createBox(40, 1.5, 22, 2.5, 3, 2.5, 0x654321);
            createBox(48, 0.5, 12, 2, 1, 2, 0x696969);
            createBox(32, 1, 25, 2.5, 2, 2.5, 0x704214);
            createBox(36, 0.75, 10, 2, 1.5, 2, 0x5a4a2a);

            // === ADDITIONAL COVER ===
            createBox(-5, 0.5, 20, 2, 1, 2, 0x696969);
            createBox(3, 1, 25, 2.5, 2, 2.5, 0x8B6914);
            createBox(-20, 0.5, 30, 2, 1, 2, 0x654321);
            createBox(-10, 1, 40, 2.5, 2, 2.5, 0x8B6914);
            createBox(10, 0.5, -10, 2, 1, 2, 0x696969);
            createBox(-30, 1, 0, 2.5, 2, 2.5, 0x654321);
            createBox(0, 1.5, -20, 3, 3, 2, 0x704214);
        }

        function createWall(x, y, z, width, height, depth, material) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y + height / 2, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
            playerCollisionObjects.push(wall);
        }

        function createBox(x, y, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.85,
                metalness: 0.1
            });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x, y + height / 2, z);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            walls.push(box);
            playerCollisionObjects.push(box);
        }

        function createBots() {
            const spawnPoints = [
                { x: 50, z: 50 },
                { x: 45, z: 55 },
                { x: 35, z: 15 },
                { x: 40, z: 22 },
                { x: 30, z: 15 },
                { x: -20, z: -30 },
                { x: 5, z: -35 },
                { x: 0, z: 0 }
            ];

            for (let i = 0; i < config.bot.count; i++) {
                const spawn = spawnPoints[i];
                const bot = createBot(spawn.x, spawn.z);
                bots.push(bot);
            }

            updateBotsUI();
        }

        function createBot(x, z) {
            const group = new THREE.Group();

            // Body - more detailed
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.6, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xbb3333,
                roughness: 0.8,
                metalness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xdd8866,
                roughness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.85;
            head.castShadow = true;
            group.add(head);

            // Weapon
            const weaponGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.9);
            const weaponMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.5,
                metalness: 0.7
            });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(0.35, 0.9, -0.3);
            weapon.castShadow = true;
            group.add(weapon);

            group.position.set(x, 0, z);

            const bot = {
                mesh: group,
                health: config.bot.health,
                lastShot: 0,
                wanderAngle: Math.random() * Math.PI * 2,
                state: 'patrol'
            };

            scene.add(group);
            return bot;
        }

        // BULLET PHYSICS - This is the key change!
        function createBullet(position, direction, speed, damage, isPlayerBullet = true) {
            const geometry = new THREE.SphereGeometry(0.08, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: isPlayerBullet ? 0xffff00 : 0xff6600,
                emissive: isPlayerBullet ? 0xffff00 : 0xff6600,
                emissiveIntensity: 2
            });
            const bulletMesh = new THREE.Mesh(geometry, material);
            bulletMesh.position.copy(position);
            scene.add(bulletMesh);

            // Tracer line
            const tracerGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const tracerMaterial = new THREE.MeshBasicMaterial({
                color: isPlayerBullet ? 0xffff00 : 0xff8800,
                transparent: true,
                opacity: 0.6
            });
            const tracer = new THREE.Mesh(tracerGeometry, tracerMaterial);
            bulletMesh.add(tracer);
            tracer.rotation.x = Math.PI / 2;
            tracer.position.z = -0.25;

            const bullet = {
                mesh: bulletMesh,
                velocity: direction.multiplyScalar(speed),
                damage: damage,
                isPlayerBullet: isPlayerBullet,
                lifetime: 0,
                maxLifetime: config.weapon.bulletLifetime
            };

            bullets.push(bullet);
            return bullet;
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.lifetime += delta * 1000;

                // Remove old bullets
                if (bullet.lifetime > bullet.maxLifetime) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                    continue;
                }

                // Move bullet
                const movement = bullet.velocity.clone().multiplyScalar(delta);
                bullet.mesh.position.add(movement);

                // Point tracer in direction of travel
                const direction = bullet.velocity.clone().normalize();
                bullet.mesh.lookAt(bullet.mesh.position.clone().add(direction));

                // Check collisions
                const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);

                // Check wall collisions
                for (let wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    if (bulletBox.intersectsBox(wallBox)) {
                        // Bullet hit wall
                        createImpactEffect(bullet.mesh.position);
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);
                        break;
                    }
                }

                if (bullets[i]) { // If bullet still exists
                    // Check bot hits (for player bullets)
                    if (bullet.isPlayerBullet) {
                        for (let j = bots.length - 1; j >= 0; j--) {
                            const bot = bots[j];
                            const botBox = new THREE.Box3().setFromObject(bot.mesh);
                            if (bulletBox.intersectsBox(botBox)) {
                                // Hit bot!
                                bot.health -= bullet.damage;
                                showHitMarker();
                                createImpactEffect(bullet.mesh.position, true);

                                if (bot.health <= 0) {
                                    scene.remove(bot.mesh);
                                    bots.splice(j, 1);
                                    score += 100;
                                    updateScoreUI();
                                    updateBotsUI();
                                    showKillFeed();

                                    if (bots.length === 0) {
                                        victory();
                                    }
                                }

                                scene.remove(bullet.mesh);
                                bullets.splice(i, 1);
                                break;
                            }
                        }
                    }
                    // Check player hits (for bot bullets)
                    else {
                        const playerBox = new THREE.Box3().setFromCenterAndSize(
                            camera.position,
                            new THREE.Vector3(0.6, config.player.height, 0.6)
                        );
                        if (bulletBox.intersectsBox(playerBox)) {
                            takeDamage(bullet.damage);
                            scene.remove(bullet.mesh);
                            bullets.splice(i, 1);
                        }
                    }
                }
            }
        }

        function createImpactEffect(position, isBlood = false) {
            const light = new THREE.PointLight(
                isBlood ? 0xff0000 : 0xffaa00,
                3,
                5
            );
            light.position.copy(position);
            scene.add(light);
            setTimeout(() => scene.remove(light), 100);

            // Spark particles
            for (let i = 0; i < (isBlood ? 8 : 5); i++) {
                const geometry = new THREE.SphereGeometry(0.05, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: isBlood ? 0xff0000 : 0xffaa00
                });
                const spark = new THREE.Mesh(geometry, material);
                spark.position.copy(position);

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.3
                );

                scene.add(spark);

                let life = 0;
                const animate = () => {
                    life += 0.016;
                    if (life > 0.5) {
                        scene.remove(spark);
                        return;
                    }
                    spark.position.add(vel);
                    vel.y -= 0.02;
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        function updateBots(delta) {
            const playerPos = camera.position.clone();

            bots.forEach((bot, index) => {
                const botPos = bot.mesh.position;
                const distanceToPlayer = botPos.distanceTo(playerPos);

                if (distanceToPlayer < config.bot.detectionRange) {
                    const direction = new THREE.Vector3().subVectors(playerPos, botPos).normalize();
                    const ray = new THREE.Raycaster(botPos.clone().setY(1.5), direction);
                    const intersects = ray.intersectObjects(walls);

                    const hasLineOfSight = intersects.length === 0 || intersects[0].distance > distanceToPlayer;

                    if (hasLineOfSight) {
                        bot.state = 'chase';
                        bot.mesh.lookAt(new THREE.Vector3(playerPos.x, botPos.y, playerPos.z));

                        if (distanceToPlayer > config.bot.shootRange * 0.7) {
                            const moveDir = new THREE.Vector3()
                                .subVectors(playerPos, botPos)
                                .normalize();

                            const newPos = botPos.clone().add(
                                moveDir.multiplyScalar(config.bot.speed)
                            );

                            if (!checkBotCollision(newPos)) {
                                bot.mesh.position.copy(newPos);
                            }
                        }

                        if (distanceToPlayer < config.bot.shootRange) {
                            const now = Date.now();
                            if (now - bot.lastShot > config.bot.shootInterval) {
                                botShoot(bot);
                                bot.lastShot = now;
                            }
                        }
                    } else {
                        patrol(bot);
                    }
                } else {
                    patrol(bot);
                }
            });
        }

        function patrol(bot) {
            bot.state = 'patrol';
            const botPos = bot.mesh.position;

            bot.wanderAngle += (Math.random() - 0.5) * 0.2;

            const direction = new THREE.Vector3(
                Math.cos(bot.wanderAngle),
                0,
                Math.sin(bot.wanderAngle)
            );

            const newPos = botPos.clone().add(
                direction.multiplyScalar(config.bot.speed * 0.4)
            );

            if (!checkBotCollision(newPos)) {
                bot.mesh.position.copy(newPos);
                bot.mesh.lookAt(newPos.clone().add(direction));
            } else {
                bot.wanderAngle += Math.PI / 3 + Math.random() * Math.PI / 3;
            }
        }

        function checkBotCollision(newPos) {
            const botBox = new THREE.Box3().setFromCenterAndSize(
                newPos,
                new THREE.Vector3(0.8, 1.5, 0.5)
            );

            for (let obj of playerCollisionObjects) {
                const objBox = new THREE.Box3().setFromObject(obj);
                if (botBox.intersectsBox(objBox)) {
                    return true;
                }
            }
            return false;
        }

        function botShoot(bot) {
            const direction = new THREE.Vector3()
                .subVectors(camera.position, bot.mesh.position)
                .normalize();

            // Add inaccuracy
            direction.x += (Math.random() - 0.5) * config.bot.accuracy;
            direction.y += (Math.random() - 0.5) * config.bot.accuracy;
            direction.z += (Math.random() - 0.5) * config.bot.accuracy;
            direction.normalize();

            // Create bullet projectile
            const bulletStart = bot.mesh.position.clone();
            bulletStart.y += 1.5;

            createBullet(
                bulletStart,
                direction,
                config.bot.bulletSpeed,
                config.bot.damage,
                false
            );

            // Muzzle flash
            createMuzzleFlash(bulletStart);
        }

        function createMuzzleFlash(position) {
            const flash = new THREE.PointLight(0xffaa00, 3, 8);
            flash.position.copy(position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameStarted = true;
            renderer.domElement.requestPointerLock();
        }

        function onKeyDown(event) {
            if (!gameStarted) return;

            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    event.preventDefault();
                    if (canJump) playerVelocity.y = config.player.jumpPower;
                    break;
                case 'ShiftLeft': isSprinting = true; break;
                case 'KeyR': reload(); break;
                case 'Escape': document.exitPointerLock(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSprinting = false; break;
            }
        }

        function onMouseMove(event) {
            if (!gameStarted || !pointerLocked) return;

            const sensitivity = 0.002;
            yaw -= event.movementX * sensitivity;
            pitch -= event.movementY * sensitivity;

            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        }

        function onMouseClick(event) {
            if (!gameStarted) return;
            if (event.button === 0 && pointerLocked) {
                shoot();
            }
        }

        function shoot() {
            if (!canShoot || isReloading || ammo <= 0) return;

            ammo--;
            updateAmmoUI();
            canShoot = false;

            setTimeout(() => canShoot = true, config.weapon.fireRate);

            // Create bullet projectile
            const bulletStart = camera.position.clone();
            bulletStart.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.5));

            const direction = camera.getWorldDirection(new THREE.Vector3());

            createBullet(
                bulletStart,
                direction,
                config.weapon.bulletSpeed,
                config.player.damage,
                true
            );

            // Muzzle flash
            createMuzzleFlash(bulletStart);

            if (ammo === 0 && reserveAmmo > 0) {
                setTimeout(() => reload(), 500);
            }
        }

        function reload() {
            if (isReloading || reserveAmmo <= 0 || ammo === config.weapon.magazineSize) return;

            isReloading = true;
            setTimeout(() => {
                const ammoNeeded = config.weapon.magazineSize - ammo;
                const ammoToReload = Math.min(ammoNeeded, reserveAmmo);
                ammo += ammoToReload;
                reserveAmmo -= ammoToReload;
                isReloading = false;
                updateAmmoUI();
            }, config.weapon.reloadTime);
        }

        function takeDamage(damage) {
            health -= damage;
            if (health < 0) health = 0;
            updateHealthUI();

            // Flash red
            renderer.domElement.style.border = '8px solid red';
            setTimeout(() => renderer.domElement.style.border = 'none', 150);

            if (health <= 0) {
                gameOver();
            }
        }

        function showHitMarker() {
            const marker = document.getElementById('hitMarker');
            marker.style.display = 'block';
            setTimeout(() => marker.style.display = 'none', 150);
        }

        function showKillFeed() {
            const feed = document.getElementById('killFeed');
            feed.textContent = 'üíÄ ENEMY ELIMINATED üíÄ';
            feed.style.display = 'block';
            setTimeout(() => feed.style.display = 'none', 3000);
        }

        function updateHealthUI() {
            document.getElementById('healthValue').textContent = Math.ceil(health);
        }

        function updateAmmoUI() {
            document.getElementById('ammoMag').textContent = ammo;
            document.getElementById('ammoReserve').textContent = '/ ' + reserveAmmo;
        }

        function updateScoreUI() {
            document.getElementById('scoreValue').textContent = 'Score: ' + score;
        }

        function updateBotsUI() {
            document.getElementById('enemyValue').textContent = 'Enemies: ' + bots.length;
        }

        function gameOver() {
            document.getElementById('gameOver').querySelector('h2').textContent = 'TERRORISTS WIN';
            document.getElementById('finalScore').textContent = 'Final Score: ' + score;
            document.getElementById('gameOver').style.display = 'block';
            document.exitPointerLock();
            gameStarted = false;
        }

        function victory() {
            score += 1000;
            updateScoreUI();
            document.getElementById('gameOver').querySelector('h2').textContent = 'COUNTER-TERRORISTS WIN';
            document.getElementById('gameOver').querySelector('h2').style.color = '#00ff00';
            document.getElementById('finalScore').textContent = 'MISSION COMPLETE!\nFinal Score: ' + score;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('gameOver').style.borderColor = '#00ff00';
            document.exitPointerLock();
            gameStarted = false;
        }

        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                newPos,
                new THREE.Vector3(0.6, config.player.height, 0.6)
            );

            for (let obj of playerCollisionObjects) {
                const objBox = new THREE.Box3().setFromObject(obj);
                if (playerBox.intersectsBox(objBox)) {
                    return true;
                }
            }
            return false;
        }

        function updatePlayer() {
            if (!gameStarted) return;

            // Apply gravity
            playerVelocity.y -= config.player.gravity;

            const newPos = camera.position.clone();
            newPos.y += playerVelocity.y;

            // Check ground collision
            if (newPos.y <= config.player.height) {
                newPos.y = config.player.height;
                playerVelocity.y = 0;
                canJump = true;
            } else {
                canJump = false;
            }

            camera.position.y = newPos.y;

            // Movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize();

            const moveDir = new THREE.Vector3();

            if (moveForward) moveDir.add(direction);
            if (moveBackward) moveDir.sub(direction);
            if (moveLeft) moveDir.sub(right);
            if (moveRight) moveDir.add(right);

            if (moveDir.length() > 0) {
                moveDir.normalize();
                const speed = isSprinting ? config.player.sprintSpeed : config.player.speed;
                const nextPos = camera.position.clone().add(
                    moveDir.multiplyScalar(speed)
                );

                if (!checkCollision(nextPos)) {
                    camera.position.x = nextPos.x;
                    camera.position.z = nextPos.z;
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            const delta = (time - lastTime) / 1000;
            lastTime = time;

            updatePlayer();
            if (gameStarted) {
                updateBots(delta);
                updateBullets(delta);
            }

            renderer.render(scene, camera);
        }

        // Initialize game
        init();
    </script>
</body>
</html>
