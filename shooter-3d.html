<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Counter-Strike: de_dust2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            color: white;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        #crosshair::before {
            width: 2px;
            height: 12px;
            left: 14px;
            top: 3px;
        }

        #crosshair::after {
            width: 12px;
            height: 2px;
            left: 3px;
            top: 14px;
        }

        .crosshair-dot {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ff00;
            left: 14px;
            top: 14px;
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            min-width: 220px;
            font-size: 16px;
        }

        .stat-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            color: #aaa;
            margin-right: 15px;
        }

        .stat-value {
            color: #00ff00;
            font-weight: bold;
            font-size: 18px;
        }

        .health-value { color: #ff4444; }
        .ammo-value { color: #ffaa00; }
        .score-value { color: #44ff44; }

        .health-bar-container {
            background: #222;
            height: 12px;
            border: 1px solid #555;
            margin-top: 5px;
            position: relative;
            width: 100%;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            transition: width 0.3s ease;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }

        #startScreen h1 {
            font-size: 56px;
            margin-bottom: 10px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
        }

        #startScreen h2 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #ffaa00;
        }

        #startScreen p {
            font-size: 18px;
            margin: 8px 0;
            color: #aaa;
        }

        #startButton {
            margin-top: 40px;
            padding: 18px 50px;
            font-size: 24px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        #startButton:hover {
            background: #44ff44;
            transform: scale(1.1);
            box-shadow: 0 0 30px #00ff00;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border: 3px solid #ff0000;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 300;
            pointer-events: all;
        }

        #gameOver h2 {
            font-size: 42px;
            color: #ff0000;
            margin-bottom: 25px;
            text-shadow: 0 0 20px #ff0000;
        }

        #gameOver p {
            font-size: 22px;
            color: white;
            margin: 12px 0;
        }

        #restartButton {
            margin-top: 25px;
            padding: 12px 35px;
            font-size: 20px;
            background: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        #restartButton:hover {
            background: #ff4444;
        }

        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            display: none;
            pointer-events: none;
        }

        #hitMarker::before,
        #hitMarker::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background: #ff0000;
            top: 50%;
            left: 0;
        }

        #hitMarker::before {
            transform: rotate(45deg);
        }

        #hitMarker::after {
            transform: rotate(-45deg);
        }

        .controls-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            font-size: 14px;
        }

        .controls-info div {
            margin: 4px 0;
            color: #aaa;
        }

        .controls-info strong {
            color: #00ff00;
        }

        #locationLabel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -200%);
            font-size: 24px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 2px 2px 4px #000;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="crosshair">
                <div class="crosshair-dot"></div>
            </div>
            <div id="hitMarker"></div>
            <div id="locationLabel"></div>
            <div id="stats">
                <div class="stat-item">
                    <span class="stat-label">HEALTH:</span>
                    <span class="stat-value health-value" id="healthValue">100</span>
                </div>
                <div class="health-bar-container">
                    <div class="health-bar" id="healthBar" style="width: 100%"></div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">AMMO:</span>
                    <span class="stat-value ammo-value" id="ammoValue">30/90</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">SCORE:</span>
                    <span class="stat-value score-value" id="scoreValue">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ENEMIES:</span>
                    <span class="stat-value" id="botsValue">0</span>
                </div>
            </div>

            <div class="controls-info">
                <div><strong>CONTROLS</strong></div>
                <div>W/A/S/D - Move</div>
                <div>Mouse - Look Around</div>
                <div>SPACE - Jump</div>
                <div>LEFT CLICK - Shoot</div>
                <div>R - Reload</div>
                <div>ESC - Unlock Mouse</div>
            </div>

            <div id="gameOver">
                <h2>GAME OVER</h2>
                <p id="finalScore">Final Score: 0</p>
                <button id="restartButton" onclick="location.reload()">RESTART</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>COUNTER-STRIKE</h1>
            <h2>de_dust2</h2>
            <p>Eliminate all 10 terrorists to win!</p>
            <p>Classic map layout with all iconic locations</p>
            <p>Long A • Short A • Mid • B Tunnels • Both Sites</p>
            <button id="startButton">Start Mission</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game configuration
        const config = {
            player: {
                health: 100,
                speed: 0.2,
                sprintSpeed: 0.35,
                jumpPower: 0.35,
                height: 1.7,
                gravity: 0.025,
                damage: 34
            },
            weapon: {
                magazineSize: 30,
                totalAmmo: 90,
                reloadTime: 2000,
                fireRate: 100
            },
            bot: {
                count: 10,
                health: 100,
                speed: 0.1,
                damage: 20,
                shootRange: 35,
                detectionRange: 45,
                shootInterval: 1200,
                accuracy: 0.15
            }
        };

        // Game state
        let scene, camera, renderer;
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isSprinting = false;
        let canJump = false;
        let isReloading = false;
        let canShoot = true;
        let gameStarted = false;
        let pointerLocked = false;

        // Camera rotation
        let yaw = 0;
        let pitch = 0;

        // Game stats
        let health = config.player.health;
        let ammo = config.weapon.magazineSize;
        let reserveAmmo = config.weapon.totalAmmo;
        let score = 0;

        // Objects
        let bots = [];
        let walls = [];
        let playerCollisionObjects = [];

        // Raycaster for shooting
        const raycaster = new THREE.Raycaster();

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 120);

            // Camera (player view)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-40, config.player.height, -40); // CT Spawn

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffdd, 0.9);
            sunLight.position.set(60, 100, 40);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -80;
            sunLight.shadow.camera.right = 80;
            sunLight.shadow.camera.top = 80;
            sunLight.shadow.camera.bottom = -80;
            scene.add(sunLight);

            // Create authentic de_dust2 map
            createDust2Map();

            // Create bots
            createBots();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
            document.addEventListener('mousemove', onMouseMove);
            document.getElementById('startButton').addEventListener('click', startGame);

            // Pointer lock
            renderer.domElement.addEventListener('click', () => {
                if (gameStarted && !pointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === renderer.domElement;
            });

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createDust2Map() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(150, 150);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xD2B48C,
                roughness: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Materials
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xC4A777, roughness: 0.9 });
            const darkWallMat = new THREE.MeshStandardMaterial({ color: 0x9B8B6B, roughness: 0.9 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });

            // === OUTER BOUNDARIES ===
            createWall(-70, 0, 0, 2, 10, 140, wallMat); // West wall
            createWall(70, 0, 0, 2, 10, 140, wallMat);  // East wall
            createWall(0, 0, -70, 140, 10, 2, wallMat); // North wall
            createWall(0, 0, 70, 140, 10, 2, wallMat);  // South wall

            // === CT SPAWN (bottom-left) ===
            createBox(-50, 0.5, -50, 3, 1, 3, 0x8B4513);
            createBox(-45, 0.5, -55, 2, 1, 2, 0x654321);

            // === T SPAWN (top-right) ===
            createBox(50, 0.5, 50, 3, 1, 3, 0x8B4513);
            createBox(55, 0.5, 45, 2, 1, 2, 0x654321);

            // === LONG A CORRIDOR ===
            // Long A walls
            createWall(-25, 0, -35, 2, 6, 40, darkWallMat); // Left wall
            createWall(-15, 0, -35, 2, 6, 40, darkWallMat); // Right wall

            // The famous CAR on Long A
            createBox(-20, 0.8, -25, 3, 1.6, 5, 0x2F4F4F);
            createBox(-20, 0.3, -27, 2.5, 0.6, 1, 0x1a1a1a); // wheels
            createBox(-20, 0.3, -23, 2.5, 0.6, 1, 0x1a1a1a);

            // Long A boxes
            createBox(-20, 1, -45, 2.5, 2, 2.5, 0x8B4513);
            createBox(-17, 0.5, -50, 2, 1, 2, 0x654321);

            // === SHORT A / CATWALK ===
            // Elevated platform
            createWall(5, 0, -35, 15, 2, 20, wallMat); // Platform base
            createWall(5, 1.5, -35, 2, 1, 20, darkWallMat); // Railing

            // === A SITE ===
            // A site platform (iconic elevated area)
            createWall(-5, 0, -5, 20, 3, 20, darkWallMat);

            // A site boxes
            createBox(0, 2.5, 0, 3, 2, 3, 0x8B4513);
            createBox(-8, 2.5, -2, 2.5, 2, 2.5, 0x654321);
            createBox(5, 2.5, -8, 2, 2, 2, 0x8B4513);

            // A site cover
            createBox(-10, 1.5, 5, 3, 3, 2, 0x696969);

            // === MID ===
            // Mid doors structure
            createWall(0, 0, 15, 2, 5, 8, doorMat);
            createWall(0, 0, 5, 2, 5, 8, doorMat);

            // Mid boxes
            createBox(-8, 1, 10, 2.5, 2, 2.5, 0x8B4513);
            createBox(8, 0.5, 8, 2, 1, 2, 0x654321);

            // Mid to B connector wall
            createWall(15, 0, 25, 2, 5, 15, darkWallMat);

            // === B TUNNELS ===
            // Upper tunnel
            createWall(30, 0, 20, 25, 5, 2, wallMat);
            createWall(30, 0, 10, 25, 5, 2, wallMat);

            // Lower tunnel
            createWall(30, 0, 35, 25, 5, 2, wallMat);
            createWall(30, 0, 45, 25, 5, 2, wallMat);

            // Tunnel boxes
            createBox(35, 1, 15, 2, 2, 2, 0x654321);
            createBox(25, 0.5, 40, 2, 1, 2, 0x8B4513);

            // === B SITE ===
            // B site walls
            createWall(45, 0, 20, 2, 6, 30, darkWallMat);
            createWall(30, 0, 5, 30, 6, 2, darkWallMat);

            // B site platform/window
            createWall(42, 0, 8, 8, 2.5, 6, wallMat);

            // B site boxes and cover
            createBox(35, 1, 15, 3, 2, 3, 0x8B4513);
            createBox(40, 1.5, 22, 2.5, 3, 2.5, 0x654321);
            createBox(48, 0.5, 12, 2, 1, 2, 0x696969);
            createBox(32, 1, 25, 2.5, 2, 2.5, 0x8B4513);

            // === ADDITIONAL COVER & DETAILS ===
            // Mid to A connector boxes
            createBox(-5, 0.5, 20, 2, 1, 2, 0x696969);
            createBox(3, 1, 25, 2.5, 2, 2.5, 0x8B4513);

            // CT to B route boxes
            createBox(-20, 0.5, 30, 2, 1, 2, 0x654321);
            createBox(-10, 1, 40, 2.5, 2, 2.5, 0x8B4513);

            // Random cover throughout map
            createBox(10, 0.5, -10, 2, 1, 2, 0x696969);
            createBox(-30, 1, 0, 2.5, 2, 2.5, 0x654321);
            createBox(0, 1.5, -20, 3, 3, 2, 0x8B4513);
        }

        function createWall(x, y, z, width, height, depth, material) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y + height / 2, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
            playerCollisionObjects.push(wall);
        }

        function createBox(x, y, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x, y + height / 2, z);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            walls.push(box);
            playerCollisionObjects.push(box);
        }

        function createBots() {
            // Spawn bots at terrorist positions
            const spawnPoints = [
                { x: 50, z: 50 },   // T spawn
                { x: 45, z: 55 },
                { x: 35, z: 15 },   // B site
                { x: 40, z: 22 },
                { x: 48, z: 12 },
                { x: 30, z: 15 },   // B tunnels
                { x: 35, z: 40 },
                { x: -20, z: -30 }, // Long A
                { x: 5, z: -35 },   // Short A
                { x: 0, z: 0 }      // A site
            ];

            for (let i = 0; i < config.bot.count; i++) {
                const spawn = spawnPoints[i];
                const bot = createBot(spawn.x, spawn.z);
                bots.push(bot);
            }

            updateBotsUI();
        }

        function createBot(x, z) {
            const group = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xcc3333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.75;
            head.castShadow = true;
            group.add(head);

            // Weapon indicator
            const weaponGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.8);
            const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(0.3, 0.8, -0.3);
            weapon.castShadow = true;
            group.add(weapon);

            group.position.set(x, 0, z);

            const bot = {
                mesh: group,
                health: config.bot.health,
                lastShot: 0,
                wanderAngle: Math.random() * Math.PI * 2,
                state: 'patrol',
                stuckTimer: 0,
                lastPosition: new THREE.Vector3(x, 0, z)
            };

            scene.add(group);
            return bot;
        }

        function updateBots(delta) {
            const playerPos = camera.position.clone();

            bots.forEach((bot, index) => {
                const botPos = bot.mesh.position;
                const distanceToPlayer = botPos.distanceTo(playerPos);

                // Check if player is in range and line of sight
                if (distanceToPlayer < config.bot.detectionRange) {
                    // Raycast to check line of sight
                    const direction = new THREE.Vector3().subVectors(playerPos, botPos).normalize();
                    const ray = new THREE.Raycaster(botPos.clone().setY(1.5), direction);
                    const intersects = ray.intersectObjects(walls);

                    const hasLineOfSight = intersects.length === 0 || intersects[0].distance > distanceToPlayer;

                    if (hasLineOfSight) {
                        bot.state = 'chase';

                        // Face player
                        bot.mesh.lookAt(new THREE.Vector3(playerPos.x, botPos.y, playerPos.z));

                        // Move towards player if not too close
                        if (distanceToPlayer > config.bot.shootRange * 0.6) {
                            const moveDir = new THREE.Vector3()
                                .subVectors(playerPos, botPos)
                                .normalize();

                            const newPos = botPos.clone().add(
                                moveDir.multiplyScalar(config.bot.speed)
                            );

                            if (!checkBotCollision(newPos)) {
                                bot.mesh.position.copy(newPos);
                            }
                        }

                        // Shoot at player
                        if (distanceToPlayer < config.bot.shootRange) {
                            const now = Date.now();
                            if (now - bot.lastShot > config.bot.shootInterval) {
                                botShoot(bot);
                                bot.lastShot = now;
                            }
                        }
                    } else {
                        patrol(bot);
                    }
                } else {
                    patrol(bot);
                }
            });
        }

        function patrol(bot) {
            bot.state = 'patrol';
            const botPos = bot.mesh.position;

            bot.wanderAngle += (Math.random() - 0.5) * 0.2;

            const direction = new THREE.Vector3(
                Math.cos(bot.wanderAngle),
                0,
                Math.sin(bot.wanderAngle)
            );

            const newPos = botPos.clone().add(
                direction.multiplyScalar(config.bot.speed * 0.4)
            );

            if (!checkBotCollision(newPos)) {
                bot.mesh.position.copy(newPos);
                bot.mesh.lookAt(newPos.clone().add(direction));
            } else {
                bot.wanderAngle += Math.PI / 3 + Math.random() * Math.PI / 3;
            }
        }

        function checkBotCollision(newPos) {
            const botBox = new THREE.Box3().setFromCenterAndSize(
                newPos,
                new THREE.Vector3(0.8, 1.5, 0.5)
            );

            for (let obj of playerCollisionObjects) {
                const objBox = new THREE.Box3().setFromObject(obj);
                if (botBox.intersectsBox(objBox)) {
                    return true;
                }
            }
            return false;
        }

        function botShoot(bot) {
            const direction = new THREE.Vector3()
                .subVectors(camera.position, bot.mesh.position)
                .normalize();

            // Add inaccuracy
            direction.x += (Math.random() - 0.5) * config.bot.accuracy;
            direction.y += (Math.random() - 0.5) * config.bot.accuracy;
            direction.z += (Math.random() - 0.5) * config.bot.accuracy;
            direction.normalize();

            // Muzzle flash
            createMuzzleFlash(bot.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)));

            // Check if hit player
            const rayOrigin = bot.mesh.position.clone();
            rayOrigin.y += 1.5;

            const ray = new THREE.Raycaster(rayOrigin, direction, 0, config.bot.shootRange);
            const intersects = ray.intersectObjects(walls);

            const distToPlayer = rayOrigin.distanceTo(camera.position);

            if (intersects.length === 0 || intersects[0].distance > distToPlayer) {
                if (distToPlayer < config.bot.shootRange) {
                    takeDamage(config.bot.damage);
                }
            }
        }

        function createMuzzleFlash(position) {
            const flash = new THREE.PointLight(0xffaa00, 2, 5);
            flash.position.copy(position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameStarted = true;
            renderer.domElement.requestPointerLock();
        }

        function onKeyDown(event) {
            if (!gameStarted) return;

            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    event.preventDefault();
                    if (canJump) playerVelocity.y = config.player.jumpPower;
                    break;
                case 'ShiftLeft': isSprinting = true; break;
                case 'KeyR': reload(); break;
                case 'Escape': document.exitPointerLock(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSprinting = false; break;
            }
        }

        function onMouseMove(event) {
            if (!gameStarted || !pointerLocked) return;

            const sensitivity = 0.002;
            yaw -= event.movementX * sensitivity;
            pitch -= event.movementY * sensitivity;

            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        }

        function onMouseClick(event) {
            if (!gameStarted) return;
            if (event.button === 0 && pointerLocked) {
                shoot();
            }
        }

        function shoot() {
            if (!canShoot || isReloading || ammo <= 0) return;

            ammo--;
            updateAmmoUI();
            canShoot = false;

            setTimeout(() => canShoot = true, config.weapon.fireRate);

            // Muzzle flash
            const flashPos = camera.position.clone();
            flashPos.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.5));
            createMuzzleFlash(flashPos);

            // Raycasting for hit detection
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects([...walls, ...bots.map(b => b.mesh)], true);

            if (intersects.length > 0) {
                const hit = intersects[0];

                // Check if we hit a bot
                for (let i = bots.length - 1; i >= 0; i--) {
                    const bot = bots[i];
                    if (bot.mesh === hit.object.parent || bot.mesh.children.includes(hit.object)) {
                        showHitMarker();
                        bot.health -= config.player.damage;

                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots.splice(i, 1);
                            score += 100;
                            updateScoreUI();
                            updateBotsUI();

                            if (bots.length === 0) {
                                victory();
                            }
                        }
                        break;
                    }
                }
            }

            if (ammo === 0 && reserveAmmo > 0) {
                setTimeout(() => reload(), 500);
            }
        }

        function reload() {
            if (isReloading || reserveAmmo <= 0 || ammo === config.weapon.magazineSize) return;

            isReloading = true;
            setTimeout(() => {
                const ammoNeeded = config.weapon.magazineSize - ammo;
                const ammoToReload = Math.min(ammoNeeded, reserveAmmo);
                ammo += ammoToReload;
                reserveAmmo -= ammoToReload;
                isReloading = false;
                updateAmmoUI();
            }, config.weapon.reloadTime);
        }

        function takeDamage(damage) {
            health -= damage;
            if (health < 0) health = 0;
            updateHealthUI();

            // Flash red
            renderer.domElement.style.border = '5px solid red';
            setTimeout(() => renderer.domElement.style.border = 'none', 100);

            if (health <= 0) {
                gameOver();
            }
        }

        function showHitMarker() {
            const marker = document.getElementById('hitMarker');
            marker.style.display = 'block';
            setTimeout(() => marker.style.display = 'none', 150);
        }

        function updateHealthUI() {
            document.getElementById('healthValue').textContent = Math.ceil(health);
            document.getElementById('healthBar').style.width = health + '%';
        }

        function updateAmmoUI() {
            document.getElementById('ammoValue').textContent = ammo + '/' + reserveAmmo;
        }

        function updateScoreUI() {
            document.getElementById('scoreValue').textContent = score;
        }

        function updateBotsUI() {
            document.getElementById('botsValue').textContent = bots.length;
        }

        function gameOver() {
            document.getElementById('finalScore').textContent = 'Final Score: ' + score;
            document.getElementById('gameOver').style.display = 'block';
            document.exitPointerLock();
            gameStarted = false;
        }

        function victory() {
            score += 1000;
            updateScoreUI();
            setTimeout(() => {
                alert('TERRORISTS ELIMINATED!\n\nCOUNTER-TERRORISTS WIN!\n\nFinal Score: ' + score);
                location.reload();
            }, 500);
        }

        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                newPos,
                new THREE.Vector3(0.6, config.player.height, 0.6)
            );

            for (let obj of playerCollisionObjects) {
                const objBox = new THREE.Box3().setFromObject(obj);
                if (playerBox.intersectsBox(objBox)) {
                    return true;
                }
            }
            return false;
        }

        function updatePlayer() {
            if (!gameStarted) return;

            // Apply gravity
            playerVelocity.y -= config.player.gravity;

            const newPos = camera.position.clone();
            newPos.y += playerVelocity.y;

            // Check ground collision
            if (newPos.y <= config.player.height) {
                newPos.y = config.player.height;
                playerVelocity.y = 0;
                canJump = true;
            } else {
                canJump = false;
            }

            camera.position.y = newPos.y;

            // Movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize();

            const moveDir = new THREE.Vector3();

            if (moveForward) moveDir.add(direction);
            if (moveBackward) moveDir.sub(direction);
            if (moveLeft) moveDir.sub(right);
            if (moveRight) moveDir.add(right);

            if (moveDir.length() > 0) {
                moveDir.normalize();
                const speed = isSprinting ? config.player.sprintSpeed : config.player.speed;
                const nextPos = camera.position.clone().add(
                    moveDir.multiplyScalar(speed)
                );

                if (!checkCollision(nextPos)) {
                    camera.position.x = nextPos.x;
                    camera.position.z = nextPos.z;
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            const delta = (time - lastTime) / 1000;
            lastTime = time;

            updatePlayer();
            if (gameStarted) {
                updateBots(delta);
            }

            renderer.render(scene, camera);
        }

        // Initialize game
        init();
    </script>
</body>
</html>
