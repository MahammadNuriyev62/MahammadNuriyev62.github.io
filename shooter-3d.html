<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shooter - Dust Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            color: white;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            min-width: 200px;
        }

        .stat-item {
            margin: 5px 0;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            color: #aaa;
            margin-right: 15px;
        }

        .stat-value {
            color: #0f0;
            font-weight: bold;
            font-size: 18px;
        }

        .health-value { color: #ff4444; }
        .ammo-value { color: #ffaa00; }
        .score-value { color: #44ff44; }

        .bar-container {
            background: #222;
            height: 10px;
            border: 1px solid #555;
            margin-top: 5px;
            position: relative;
            width: 150px;
        }

        .bar {
            height: 100%;
            transition: width 0.3s ease;
        }

        .health-bar {
            background: linear-gradient(90deg, #ff0000, #00ff00);
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }

        #startScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }

        #startScreen p {
            font-size: 18px;
            margin: 10px 0;
            color: #aaa;
        }

        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 24px;
            background: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.3s ease;
        }

        #startButton:hover {
            background: #ff4444;
            transform: scale(1.1);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 3px solid #ff0000;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 300;
        }

        #gameOver h2 {
            font-size: 36px;
            color: #ff0000;
            margin-bottom: 20px;
        }

        #gameOver p {
            font-size: 20px;
            color: white;
            margin: 10px 0;
        }

        #restartButton {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
        }

        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            display: none;
            pointer-events: none;
        }

        #hitMarker::before,
        #hitMarker::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 2px;
            background: #ff0000;
            top: 50%;
            left: 0;
        }

        #hitMarker::before {
            transform: rotate(45deg);
        }

        #hitMarker::after {
            transform: rotate(-45deg);
        }

        .controls-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            font-size: 14px;
        }

        .controls-info div {
            margin: 3px 0;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="crosshair"></div>
            <div id="hitMarker"></div>
            <div id="stats">
                <div class="stat-item">
                    <span class="stat-label">Health:</span>
                    <span class="stat-value health-value" id="healthValue">100</span>
                </div>
                <div class="bar-container">
                    <div class="bar health-bar" id="healthBar" style="width: 100%"></div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Ammo:</span>
                    <span class="stat-value ammo-value" id="ammoValue">30/90</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Score:</span>
                    <span class="stat-value score-value" id="scoreValue">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Bots:</span>
                    <span class="stat-value" id="botsValue">0</span>
                </div>
            </div>

            <div class="controls-info">
                <div><strong>Controls:</strong></div>
                <div>WASD - Move</div>
                <div>Mouse - Look</div>
                <div>Space - Jump</div>
                <div>Left Click - Shoot</div>
                <div>R - Reload</div>
            </div>

            <div id="gameOver">
                <h2>GAME OVER</h2>
                <p id="finalScore">Final Score: 0</p>
                <button id="restartButton" onclick="location.reload()">Restart</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>DUST ARENA</h1>
            <p>Eliminate all enemy bots to win!</p>
            <p>Watch out - they shoot back!</p>
            <button id="startButton">START GAME</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game configuration
        const config = {
            player: {
                health: 100,
                speed: 0.15,
                jumpPower: 0.3,
                height: 1.7,
                gravity: 0.02,
                damage: 34
            },
            weapon: {
                magazineSize: 30,
                totalAmmo: 90,
                reloadTime: 2000,
                fireRate: 100
            },
            bot: {
                count: 8,
                health: 100,
                speed: 0.08,
                damage: 15,
                shootRange: 30,
                detectionRange: 40,
                shootInterval: 1500
            }
        };

        // Game state
        let scene, camera, renderer;
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let isReloading = false;
        let canShoot = true;
        let gameStarted = false;

        // Game stats
        let health = config.player.health;
        let ammo = config.weapon.magazineSize;
        let reserveAmmo = config.weapon.totalAmmo;
        let score = 0;

        // Objects
        let bots = [];
        let bullets = [];
        let walls = [];

        // Raycaster for shooting
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0);

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

            // Camera (player view)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, config.player.height, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffcc, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);

            // Create de_dust2 inspired map
            createMap();

            // Create bots
            createBots();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onMouseClick);
            document.getElementById('startButton').addEventListener('click', startGame);

            // Pointer lock
            renderer.domElement.addEventListener('click', () => {
                if (gameStarted) {
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('mousemove', onMouseMove);

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createMap() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xD2B48C,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Wall material (sandy color like dust2)
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xC4A777,
                roughness: 0.9
            });

            const darkWallMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B7355,
                roughness: 0.9
            });

            // Outer walls
            createWall(-50, 0, 0, 100, 8, 1, wallMaterial); // Left
            createWall(50, 0, 0, 100, 8, 1, wallMaterial);  // Right
            createWall(0, 0, -50, 1, 8, 100, wallMaterial); // Back
            createWall(0, 0, 50, 1, 8, 100, wallMaterial);  // Front

            // Central plaza structure (inspired by dust2 middle area)
            createWall(-15, 0, 0, 30, 6, 1, darkWallMaterial);
            createWall(15, 0, 0, 30, 6, 1, darkWallMaterial);
            createWall(0, 0, -15, 1, 6, 30, darkWallMaterial);

            // Long corridor (inspired by long A)
            createWall(-30, 0, -30, 1, 5, 30, wallMaterial);
            createWall(-20, 0, -30, 1, 5, 30, wallMaterial);

            // Tunnel area
            createWall(25, 0, 25, 15, 4, 1, darkWallMaterial);
            createWall(25, 0, 35, 15, 4, 1, darkWallMaterial);

            // Cover boxes/crates
            createBox(-5, 1, -5, 2, 2, 2, 0x8B4513);
            createBox(8, 1, 8, 2, 2, 2, 0x8B4513);
            createBox(-20, 1, 20, 3, 2, 3, 0x654321);
            createBox(20, 1, -20, 2, 3, 2, 0x654321);
            createBox(0, 1, 30, 4, 2, 4, 0x8B4513);
            createBox(35, 1, 0, 2, 2, 2, 0x654321);
            createBox(-35, 1, -10, 3, 2, 3, 0x8B4513);

            // Additional cover
            createBox(-10, 0.5, 25, 2, 1, 2, 0x696969);
            createBox(15, 0.5, -25, 2, 1, 2, 0x696969);
            createBox(-25, 0.5, -5, 2, 1, 2, 0x696969);
        }

        function createWall(x, y, z, width, height, depth, material) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y + height / 2, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            walls.push(wall);
        }

        function createBox(x, y, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x, y + height / 2, z);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            walls.push(box);
        }

        function createBots() {
            const spawnPoints = [
                { x: -35, z: -35 },
                { x: 35, z: -35 },
                { x: -35, z: 35 },
                { x: 35, z: 35 },
                { x: -25, z: 0 },
                { x: 25, z: 0 },
                { x: 0, z: -25 },
                { x: 0, z: 25 }
            ];

            for (let i = 0; i < config.bot.count; i++) {
                const spawn = spawnPoints[i];
                const bot = createBot(spawn.x, spawn.z);
                bots.push(bot);
            }

            updateBotsUI();
        }

        function createBot(x, z) {
            const group = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.75;
            head.castShadow = true;
            group.add(head);

            group.position.set(x, 0, z);

            const bot = {
                mesh: group,
                health: config.bot.health,
                lastShot: 0,
                target: new THREE.Vector3(),
                wanderAngle: Math.random() * Math.PI * 2,
                state: 'patrol' // patrol, chase, shoot
            };

            scene.add(group);
            return bot;
        }

        function updateBots(delta) {
            const playerPos = camera.position.clone();

            bots.forEach((bot, index) => {
                const botPos = bot.mesh.position;
                const distanceToPlayer = botPos.distanceTo(playerPos);

                // Check if player is in range
                if (distanceToPlayer < config.bot.detectionRange) {
                    bot.state = 'chase';

                    // Face player
                    bot.mesh.lookAt(playerPos);

                    // Move towards player if not too close
                    if (distanceToPlayer > config.bot.shootRange * 0.5) {
                        const direction = new THREE.Vector3()
                            .subVectors(playerPos, botPos)
                            .normalize();

                        const newPos = botPos.clone().add(
                            direction.multiplyScalar(config.bot.speed)
                        );

                        // Check collision with walls
                        if (!checkBotCollision(newPos, bot)) {
                            bot.mesh.position.copy(newPos);
                        }
                    }

                    // Shoot at player
                    if (distanceToPlayer < config.bot.shootRange) {
                        const now = Date.now();
                        if (now - bot.lastShot > config.bot.shootInterval) {
                            botShoot(bot);
                            bot.lastShot = now;
                        }
                    }
                } else {
                    // Patrol behavior
                    bot.state = 'patrol';
                    bot.wanderAngle += (Math.random() - 0.5) * 0.1;

                    const direction = new THREE.Vector3(
                        Math.cos(bot.wanderAngle),
                        0,
                        Math.sin(bot.wanderAngle)
                    );

                    const newPos = botPos.clone().add(
                        direction.multiplyScalar(config.bot.speed * 0.5)
                    );

                    if (!checkBotCollision(newPos, bot)) {
                        bot.mesh.position.copy(newPos);
                        bot.mesh.lookAt(newPos.add(direction));
                    } else {
                        bot.wanderAngle += Math.PI / 2;
                    }
                }
            });
        }

        function checkBotCollision(newPos, bot) {
            for (let wall of walls) {
                const botBox = new THREE.Box3().setFromCenterAndSize(
                    newPos,
                    new THREE.Vector3(0.8, 1.5, 0.5)
                );
                const wallBox = new THREE.Box3().setFromObject(wall);

                if (botBox.intersectsBox(wallBox)) {
                    return true;
                }
            }
            return false;
        }

        function botShoot(bot) {
            const direction = new THREE.Vector3()
                .subVectors(camera.position, bot.mesh.position)
                .normalize();

            // Add some inaccuracy
            direction.x += (Math.random() - 0.5) * 0.2;
            direction.y += (Math.random() - 0.5) * 0.2;
            direction.z += (Math.random() - 0.5) * 0.2;
            direction.normalize();

            // Create bullet tracer
            createBulletTracer(bot.mesh.position.clone(), direction);

            // Check if hit player (simplified raycast)
            const rayOrigin = bot.mesh.position.clone();
            rayOrigin.y += 1.5;

            const ray = new THREE.Raycaster(rayOrigin, direction);
            const intersects = ray.intersectObjects(walls);

            // If no wall blocking, check distance to player
            if (intersects.length === 0 || intersects[0].distance > rayOrigin.distanceTo(camera.position)) {
                const distToPlayer = rayOrigin.distanceTo(camera.position);
                if (distToPlayer < config.bot.shootRange) {
                    // Hit player!
                    takeDamage(config.bot.damage);
                }
            }
        }

        function createBulletTracer(start, direction) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                start,
                start.clone().add(direction.multiplyScalar(50))
            ]);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
            const line = new THREE.Line(geometry, material);
            scene.add(line);

            setTimeout(() => scene.remove(line), 100);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameStarted = true;
            renderer.domElement.requestPointerLock();
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) playerVelocity.y = config.player.jumpPower; break;
                case 'KeyR': reload(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement) {
                camera.rotation.y -= event.movementX * 0.002;
                camera.rotation.x -= event.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function onMouseClick(event) {
            if (gameStarted && document.pointerLockElement === renderer.domElement) {
                shoot();
            }
        }

        function shoot() {
            if (!canShoot || isReloading || ammo <= 0) return;

            ammo--;
            updateAmmoUI();
            canShoot = false;

            setTimeout(() => canShoot = true, config.weapon.fireRate);

            // Raycasting for hit detection
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...walls, ...bots.map(b => b.mesh)], true);

            if (intersects.length > 0) {
                const hit = intersects[0].object;

                // Check if we hit a bot
                for (let i = bots.length - 1; i >= 0; i--) {
                    const bot = bots[i];
                    if (bot.mesh === hit.parent || bot.mesh.children.includes(hit)) {
                        showHitMarker();
                        bot.health -= config.player.damage;

                        if (bot.health <= 0) {
                            scene.remove(bot.mesh);
                            bots.splice(i, 1);
                            score += 100;
                            updateScoreUI();
                            updateBotsUI();

                            if (bots.length === 0) {
                                victory();
                            }
                        }
                        break;
                    }
                }
            }

            if (ammo === 0 && reserveAmmo > 0) {
                setTimeout(() => reload(), 500);
            }
        }

        function reload() {
            if (isReloading || reserveAmmo <= 0 || ammo === config.weapon.magazineSize) return;

            isReloading = true;
            setTimeout(() => {
                const ammoNeeded = config.weapon.magazineSize - ammo;
                const ammoToReload = Math.min(ammoNeeded, reserveAmmo);
                ammo += ammoToReload;
                reserveAmmo -= ammoToReload;
                isReloading = false;
                updateAmmoUI();
            }, config.weapon.reloadTime);
        }

        function takeDamage(damage) {
            health -= damage;
            if (health < 0) health = 0;
            updateHealthUI();

            if (health <= 0) {
                gameOver();
            }
        }

        function showHitMarker() {
            const marker = document.getElementById('hitMarker');
            marker.style.display = 'block';
            setTimeout(() => marker.style.display = 'none', 100);
        }

        function updateHealthUI() {
            document.getElementById('healthValue').textContent = Math.ceil(health);
            document.getElementById('healthBar').style.width = health + '%';
        }

        function updateAmmoUI() {
            document.getElementById('ammoValue').textContent = ammo + '/' + reserveAmmo;
        }

        function updateScoreUI() {
            document.getElementById('scoreValue').textContent = score;
        }

        function updateBotsUI() {
            document.getElementById('botsValue').textContent = bots.length;
        }

        function gameOver() {
            document.getElementById('finalScore').textContent = 'Final Score: ' + score;
            document.getElementById('gameOver').style.display = 'block';
            document.exitPointerLock();
        }

        function victory() {
            score += 1000; // Bonus for winning
            updateScoreUI();
            setTimeout(() => {
                alert('VICTORY! All bots eliminated!\nFinal Score: ' + score);
                location.reload();
            }, 500);
        }

        function checkCollision(newPos) {
            for (let wall of walls) {
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    newPos,
                    new THREE.Vector3(0.5, config.player.height, 0.5)
                );
                const wallBox = new THREE.Box3().setFromObject(wall);

                if (playerBox.intersectsBox(wallBox)) {
                    return true;
                }
            }
            return false;
        }

        function updatePlayer() {
            // Apply gravity
            playerVelocity.y -= config.player.gravity;

            const newPos = camera.position.clone();
            newPos.y += playerVelocity.y;

            // Check ground collision
            if (newPos.y <= config.player.height) {
                newPos.y = config.player.height;
                playerVelocity.y = 0;
                canJump = true;
            } else {
                canJump = false;
            }

            camera.position.y = newPos.y;

            // Movement
            const direction = new THREE.Vector3();
            const right = new THREE.Vector3();

            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            right.crossVectors(camera.up, direction).normalize();

            const moveDir = new THREE.Vector3();

            if (moveForward) moveDir.add(direction);
            if (moveBackward) moveDir.sub(direction);
            if (moveLeft) moveDir.add(right);
            if (moveRight) moveDir.sub(right);

            if (moveDir.length() > 0) {
                moveDir.normalize();
                const nextPos = camera.position.clone().add(
                    moveDir.multiplyScalar(config.player.speed)
                );

                if (!checkCollision(nextPos)) {
                    camera.position.x = nextPos.x;
                    camera.position.z = nextPos.z;
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            const delta = (time - lastTime) / 1000;
            lastTime = time;

            if (gameStarted) {
                updatePlayer();
                updateBots(delta);
            }

            renderer.render(scene, camera);
        }

        // Initialize game
        init();
    </script>
</body>
</html>
