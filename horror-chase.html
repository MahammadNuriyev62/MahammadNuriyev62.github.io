<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDNIGHT CHASE - Horror Survival Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: none;
        }

        /* Custom cursor for horror effect */
        #cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #ff0000;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.1s;
        }

        #cursor.survivor {
            border-color: #00ff88;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Vignette effect */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.8) 100%);
            opacity: 0.6;
        }

        /* Player HUD */
        .player-hud {
            position: absolute;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid;
            min-width: 350px;
            backdrop-filter: blur(10px);
        }

        .maniac-hud {
            top: 20px;
            left: 20px;
            border-color: #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .survivor-hud {
            top: 20px;
            right: 20px;
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .player-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 10px currentColor;
            letter-spacing: 2px;
        }

        .maniac-hud .player-title {
            color: #ff0000;
        }

        .survivor-hud .player-title {
            color: #00ff88;
        }

        /* Stamina bar */
        .stamina-container {
            background: #1a1a1a;
            height: 30px;
            border: 2px solid #333;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }

        .stamina-bar {
            height: 100%;
            transition: width 0.2s ease;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            box-shadow: 0 0 20px currentColor;
        }

        .stamina-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
        }

        .stat-item {
            margin: 8px 0;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            color: #aaa;
            text-transform: uppercase;
            font-size: 14px;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 18px;
        }

        /* Timer */
        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px 40px;
            border: 3px solid #00d4ff;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.6);
        }

        .timer-label {
            color: #00d4ff;
            font-size: 16px;
            margin-bottom: 5px;
            letter-spacing: 3px;
        }

        .timer-value {
            color: #fff;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #00d4ff;
            letter-spacing: 2px;
        }

        .timer-value.warning {
            color: #ff0000;
            animation: pulseTimer 0.5s infinite;
        }

        @keyframes pulseTimer {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Heartbeat indicator */
        #heartbeat {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 60px;
            color: #ff0000;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 30px #ff0000;
        }

        #heartbeat.active {
            animation: heartbeat 1s infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: translateX(-50%) scale(1); opacity: 0.3; }
            50% { transform: translateX(-50%) scale(1.3); opacity: 1; }
        }

        /* Action notifications */
        #notifications {
            position: absolute;
            top: 140px;
            right: 20px;
            max-width: 400px;
        }

        .notification {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 20px;
            margin: 10px 0;
            border-left: 5px solid;
            animation: slideIn 0.3s ease, fadeOut 0.5s ease 3.5s;
            font-size: 16px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .notification.maniac {
            border-color: #ff0000;
            color: #ff0000;
        }

        .notification.survivor {
            border-color: #00ff88;
            color: #00ff88;
        }

        .notification.info {
            border-color: #00d4ff;
            color: #00d4ff;
        }

        @keyframes slideIn {
            from { transform: translateX(500px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: translateX(500px); }
        }

        /* Proximity warning */
        #proximityWarning {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 40%, rgba(255, 0, 0, 0.3) 100%);
            opacity: 0;
            transition: opacity 0.5s;
        }

        #proximityWarning.active {
            opacity: 1;
        }

        /* Menu */
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 1000;
            pointer-events: all;
            overflow-y: auto;
            padding: 30px 20px;
        }

        #menu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 60px;
            font-weight: bold;
            color: #ff0000;
            margin-bottom: 10px;
            margin-top: 20px;
            text-shadow: 0 0 50px #ff0000, 0 0 100px #ff0000;
            letter-spacing: 5px;
            animation: glitchTitle 3s infinite;
        }

        @keyframes glitchTitle {
            0%, 90%, 100% { transform: translate(0); }
            91% { transform: translate(-5px, 2px); }
            92% { transform: translate(5px, -2px); }
            93% { transform: translate(-2px, -5px); }
        }

        .menu-subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 20px;
            letter-spacing: 3px;
        }

        .menu-section {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            margin: 10px;
            border: 2px solid #ff0000;
            max-width: 600px;
            width: 100%;
        }

        .menu-section-title {
            color: #ff0000;
            font-size: 20px;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .difficulty-buttons {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-btn {
            background: transparent;
            border: 3px solid #666;
            color: #666;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .difficulty-btn.selected,
        .difficulty-btn:hover {
            border-color: #ff0000;
            color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            transform: scale(1.05);
        }

        .difficulty-btn.easy.selected,
        .difficulty-btn.easy:hover {
            border-color: #00ff88;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .difficulty-btn.hard.selected,
        .difficulty-btn.hard:hover {
            border-color: #ff0000;
            color: #ff0000;
        }

        .time-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
        }

        .time-btn {
            background: #1a0000;
            border: 2px solid #ff0000;
            color: #ff0000;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        .time-btn:hover {
            background: #ff0000;
            color: #000;
            transform: scale(1.1);
        }

        .time-display {
            font-size: 36px;
            color: #fff;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
        }

        .start-button {
            background: transparent;
            border: 4px solid #ff0000;
            color: #ff0000;
            padding: 15px 50px;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            margin-top: 20px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
        }

        .start-button:hover {
            background: #ff0000;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 60px rgba(255, 0, 0, 0.8);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
            margin-bottom: 30px;
            max-width: 800px;
            width: 100%;
        }

        .controls-section {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border: 2px solid;
        }

        .controls-section.maniac {
            border-color: #ff0000;
        }

        .controls-section.survivor {
            border-color: #00ff88;
        }

        .controls-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .controls-section.maniac .controls-title {
            color: #ff0000;
        }

        .controls-section.survivor .controls-title {
            color: #00ff88;
        }

        .control-item {
            margin: 8px 0;
            font-size: 14px;
            color: #ccc;
            display: flex;
            justify-content: space-between;
        }

        .control-key {
            background: #222;
            padding: 3px 8px;
            border-radius: 3px;
            color: #fff;
            font-weight: bold;
        }

        /* Game Over Screen */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            pointer-events: all;
        }

        #gameOver.show {
            display: flex;
        }

        .game-over-title {
            font-size: 100px;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 0 0 50px currentColor;
            letter-spacing: 5px;
        }

        .game-over-title.survivor-win {
            color: #00ff88;
        }

        .game-over-title.maniac-win {
            color: #ff0000;
        }

        .game-over-subtitle {
            font-size: 32px;
            margin-bottom: 50px;
            color: #aaa;
        }

        .game-stats {
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 3px solid #333;
            margin: 20px;
            min-width: 500px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 20px;
        }

        .menu-button {
            background: transparent;
            border: 3px solid #ff0000;
            color: #ff0000;
            padding: 15px 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            margin: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-button:hover {
            background: #ff0000;
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
        }

        /* Hiding indicator */
        #hidingIndicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px 40px;
            border: 3px solid #00ff88;
            font-size: 24px;
            color: #00ff88;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        #hidingIndicator.show {
            display: block;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: translateX(-50%) scale(1); }
            50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
        }

        /* Screen shake */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-10px, 5px); }
            20% { transform: translate(10px, -5px); }
            30% { transform: translate(-10px, -5px); }
            40% { transform: translate(10px, 5px); }
            50% { transform: translate(-10px, 5px); }
            60% { transform: translate(10px, -5px); }
            70% { transform: translate(-10px, -5px); }
            80% { transform: translate(10px, 5px); }
            90% { transform: translate(-10px, 5px); }
        }

        .screen-shake {
            animation: shake 0.5s;
        }

        /* Blood effect */
        #bloodEffect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 0%, #ff0000 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #bloodEffect.show {
            opacity: 0.6;
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            border: 5px solid #333;
            border-top: 5px solid #ff0000;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .menu-title {
                font-size: 40px;
            }

            .menu-subtitle {
                font-size: 14px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .difficulty-btn {
                padding: 10px 20px;
                font-size: 14px;
            }

            .start-button {
                font-size: 20px;
                padding: 12px 30px;
            }

            .menu-section {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="cursor"></div>

    <div id="hud">
        <div class="vignette"></div>

        <!-- Maniac HUD -->
        <div class="player-hud maniac-hud">
            <div class="player-title">THE MANIAC</div>
            <div class="stamina-container">
                <div class="stamina-bar" id="maniacStamina" style="width: 100%"></div>
                <div class="stamina-text">RAGE</div>
            </div>
            <div class="stat-item">
                <span class="stat-label">Status:</span>
                <span class="stat-value" id="maniacStatus">HUNTING</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Speed:</span>
                <span class="stat-value" id="maniacSpeed">NORMAL</span>
            </div>
        </div>

        <!-- Survivor HUD -->
        <div class="player-hud survivor-hud">
            <div class="player-title">SURVIVOR</div>
            <div class="stamina-container">
                <div class="stamina-bar" id="survivorStamina" style="width: 100%"></div>
                <div class="stamina-text">STAMINA</div>
            </div>
            <div class="stat-item">
                <span class="stat-label">Traps:</span>
                <span class="stat-value" id="trapsCount">3</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Status:</span>
                <span class="stat-value" id="survivorStatus">RUNNING</span>
            </div>
        </div>

        <!-- Timer -->
        <div id="timer">
            <div class="timer-label">TIME TO SURVIVE</div>
            <div class="timer-value" id="timerValue">5:00</div>
        </div>

        <!-- Heartbeat -->
        <div id="heartbeat">♥</div>

        <!-- Hiding Indicator -->
        <div id="hidingIndicator">
            <div>HIDDEN</div>
            <div style="font-size: 14px; margin-top: 5px;">Press SHIFT to exit</div>
        </div>

        <!-- Notifications -->
        <div id="notifications"></div>

        <!-- Proximity Warning -->
        <div id="proximityWarning"></div>

        <!-- Blood Effect -->
        <div id="bloodEffect"></div>
    </div>

    <!-- Menu -->
    <div id="menu">
        <div class="menu-title">MIDNIGHT CHASE</div>
        <div class="menu-subtitle">A Two-Player Horror Experience</div>

        <div class="menu-section">
            <div class="menu-section-title">DIFFICULTY</div>
            <div class="difficulty-buttons">
                <button class="difficulty-btn easy" onclick="setDifficulty('easy')">EASY</button>
                <button class="difficulty-btn selected" onclick="setDifficulty('normal')">NORMAL</button>
                <button class="difficulty-btn hard" onclick="setDifficulty('hard')">HARD</button>
                <button class="difficulty-btn hard" onclick="setDifficulty('nightmare')">NIGHTMARE</button>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-section-title">SURVIVAL TIME</div>
            <div class="time-selector">
                <button class="time-btn" onclick="adjustTime(-1)">-</button>
                <div class="time-display" id="timeDisplay">5:00</div>
                <button class="time-btn" onclick="adjustTime(1)">+</button>
            </div>
            <div style="text-align: center; color: #666; margin-top: 10px; font-size: 14px;">
                (1-10 minutes)
            </div>
        </div>

        <button class="start-button" onclick="startGame()">START GAME</button>

        <div class="controls-grid">
            <div class="controls-section maniac">
                <div class="controls-title">MANIAC CONTROLS</div>
                <div class="control-item">
                    <span>Move</span>
                    <span class="control-key">W A S D</span>
                </div>
                <div class="control-item">
                    <span>Sprint</span>
                    <span class="control-key">SHIFT</span>
                </div>
                <div class="control-item">
                    <span>Attack</span>
                    <span class="control-key">SPACE</span>
                </div>
                <div class="control-item">
                    <span>Break Door</span>
                    <span class="control-key">E</span>
                </div>
            </div>

            <div class="controls-section survivor">
                <div class="controls-title">SURVIVOR CONTROLS</div>
                <div class="control-item">
                    <span>Move</span>
                    <span class="control-key">↑ ↓ ← →</span>
                </div>
                <div class="control-item">
                    <span>Sprint</span>
                    <span class="control-key">ENTER</span>
                </div>
                <div class="control-item">
                    <span>Hide/Interact</span>
                    <span class="control-key">R-SHIFT</span>
                </div>
                <div class="control-item">
                    <span>Place Trap</span>
                    <span class="control-key">R-CTRL</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameOver">
        <div class="game-over-title" id="gameOverTitle">GAME OVER</div>
        <div class="game-over-subtitle" id="gameOverSubtitle"></div>
        <div class="game-stats" id="gameStats"></div>
        <div>
            <button class="menu-button" onclick="backToMenu()">BACK TO MENU</button>
            <button class="menu-button" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer;
        let maniac, survivor;
        let obstacles = [];
        let hidingSpots = [];
        let doors = [];
        let traps = [];
        let gameActive = false;
        let gameTime = 300; // seconds
        let selectedDifficulty = 'normal';
        let selectedTime = 300;

        // Player states
        let maniacState = {
            stamina: 100,
            maxStamina: 100,
            speed: 10,
            baseSpeed: 10,
            rageMode: false,
            canAttack: true,
            lastAttack: 0
        };

        let survivorState = {
            stamina: 100,
            maxStamina: 100,
            speed: 9,
            baseSpeed: 9,
            isHiding: false,
            trapsRemaining: 3,
            isNearInteractable: false,
            currentHidingSpot: null
        };

        // Audio System
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let heartbeatInterval = null;

        // Sound effects
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playFootstep(isManiac) {
            playSound(isManiac ? 80 : 120, 0.05, 'sine', 0.15);
        }

        function playHeartbeatSound() {
            playSound(60, 0.3, 'sine', 0.4);
            setTimeout(() => playSound(65, 0.2, 'sine', 0.3), 150);
        }

        function playScreamSound() {
            playSound(800, 0.3, 'sawtooth', 0.5);
            setTimeout(() => playSound(600, 0.3, 'sawtooth', 0.4), 100);
            setTimeout(() => playSound(400, 0.5, 'sawtooth', 0.3), 200);
        }

        function playDoorSound() {
            playSound(200, 0.3, 'square', 0.3);
            setTimeout(() => playSound(150, 0.2, 'square', 0.2), 150);
        }

        function playTrapSound() {
            playSound(1000, 0.1, 'square', 0.4);
            setTimeout(() => playSound(300, 0.3, 'sawtooth', 0.3), 100);
        }

        function playHideSound() {
            playSound(300, 0.2, 'sine', 0.2);
        }

        function playChaseMusic() {
            // Tension music simulation
            const notes = [220, 247, 277, 294];
            let index = 0;
            const interval = setInterval(() => {
                if (!gameActive || !maniacState.rageMode) {
                    clearInterval(interval);
                    return;
                }
                playSound(notes[index], 0.3, 'triangle', 0.15);
                index = (index + 1) % notes.length;
            }, 400);
        }

        function startHeartbeat(distance) {
            if (heartbeatInterval) clearInterval(heartbeatInterval);

            const heartbeat = document.getElementById('heartbeat');

            if (distance > 20) {
                heartbeat.classList.remove('active');
                return;
            }

            heartbeat.classList.add('active');
            const interval = Math.max(300, distance * 50);

            heartbeatInterval = setInterval(() => {
                if (!gameActive || survivorState.isHiding) {
                    heartbeat.classList.remove('active');
                    clearInterval(heartbeatInterval);
                    return;
                }
                playHeartbeatSound();
            }, interval);
        }

        // Input handling
        let keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Mouse tracking for custom cursor
        let mouseX = 0, mouseY = 0;
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            const cursor = document.getElementById('cursor');
            cursor.style.left = mouseX + 'px';
            cursor.style.top = mouseY + 'px';
        });

        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Brighter ambient lighting for gameplay visibility
            const ambientLight = new THREE.AmbientLight(0x666677, 1.2);
            scene.add(ambientLight);

            // Main directional light (much brighter)
            const dirLight = new THREE.DirectionalLight(0xaabbcc, 1.5);
            dirLight.position.set(20, 40, 20);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -60;
            dirLight.shadow.camera.right = 60;
            dirLight.shadow.camera.top = 60;
            dirLight.shadow.camera.bottom = -60;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Atmospheric colored lights
            const redLight = new THREE.PointLight(0xff3333, 2.0, 50);
            redLight.position.set(-30, 10, -30);
            scene.add(redLight);

            const greenLight = new THREE.PointLight(0x00ff88, 1.5, 50);
            greenLight.position.set(30, 10, 30);
            scene.add(greenLight);

            // Multiple overhead lights for even coverage
            const topLight1 = new THREE.PointLight(0x8899bb, 1.5, 70);
            topLight1.position.set(0, 30, 0);
            scene.add(topLight1);

            const topLight2 = new THREE.PointLight(0x8899bb, 1.0, 60);
            topLight2.position.set(-25, 25, -25);
            scene.add(topLight2);

            const topLight3 = new THREE.PointLight(0x8899bb, 1.0, 60);
            topLight3.position.set(25, 25, 25);
            scene.add(topLight3);

            createArena();
            createCharacters();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);
        }

        function createArena() {
            // Floor (brighter for visibility)
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3e,
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid for atmosphere (brighter)
            const gridHelper = new THREE.GridHelper(100, 50, 0x444466, 0x2a2a3e);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Create maze-like structure (brighter walls)
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a5e,
                roughness: 0.8,
                metalness: 0.2
            });

            const createWall = (width, height, depth, x, y, z, isDoor = false) => {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = isDoor ?
                    new THREE.MeshStandardMaterial({
                        color: 0x4a2c2a,
                        roughness: 0.9,
                        metalness: 0.1
                    }) : wallMaterial;

                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(x, y, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);

                if (!isDoor) {
                    obstacles.push(wall);
                } else {
                    wall.isLocked = false;
                    wall.health = 100;
                    doors.push(wall);

                    // Add door indicator
                    const indicatorGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const indicatorMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff88,
                        transparent: true,
                        opacity: 0.5
                    });
                    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                    indicator.position.set(x, height + 1, z);
                    scene.add(indicator);
                    wall.indicator = indicator;
                }
                return wall;
            };

            // Boundary walls
            createWall(100, 8, 2, 0, 4, -50);
            createWall(100, 8, 2, 0, 4, 50);
            createWall(2, 8, 100, -50, 4, 0);
            createWall(2, 8, 100, 50, 4, 0);

            // Interior walls creating rooms and corridors
            createWall(30, 6, 2, -20, 3, -20);
            createWall(30, 6, 2, 20, 3, 20);
            createWall(2, 6, 30, -10, 3, -30);
            createWall(2, 6, 30, 10, 3, 30);

            // Doors in walls
            createWall(8, 6, 2, 0, 3, 0, true);
            createWall(2, 6, 8, 25, 3, 0, true);
            createWall(2, 6, 8, -25, 3, 0, true);

            // Create rooms with hiding spots
            createRoom(-30, -30, 15, 15);
            createRoom(30, -30, 15, 15);
            createRoom(-30, 30, 15, 15);
            createRoom(30, 30, 15, 15);

            // Central area obstacles
            for (let i = 0; i < 12; i++) {
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                if (Math.abs(x) > 5 && Math.abs(z) > 5) {
                    const size = 2 + Math.random() * 4;
                    createWall(size, 4, size, x, 2, z);
                }
            }

            // Add atmospheric particles (dust/fog)
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = Math.random() * 20;
                positions[i + 2] = (Math.random() - 0.5) * 100;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x666666,
                size: 0.2,
                transparent: true,
                opacity: 0.3
            });

            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }

        function createRoom(centerX, centerZ, width, depth) {
            // Create hiding spots in room
            const spotTypes = ['locker', 'table', 'crate'];
            const spotType = spotTypes[Math.floor(Math.random() * spotTypes.length)];

            const hidingSpot = createHidingSpot(
                centerX + (Math.random() - 0.5) * width * 0.5,
                centerZ + (Math.random() - 0.5) * depth * 0.5,
                spotType
            );
            hidingSpots.push(hidingSpot);
        }

        function createHidingSpot(x, z, type) {
            let geometry, material, height = 3;
            const color = 0x2a2a3e;

            switch(type) {
                case 'locker':
                    geometry = new THREE.BoxGeometry(3, 5, 2);
                    height = 2.5;
                    break;
                case 'table':
                    geometry = new THREE.BoxGeometry(4, 1.5, 2);
                    height = 0.75;
                    break;
                case 'crate':
                    geometry = new THREE.BoxGeometry(3, 3, 3);
                    height = 1.5;
                    break;
            }

            material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.8,
                metalness: 0.2
            });

            const spot = new THREE.Mesh(geometry, material);
            spot.position.set(x, height, z);
            spot.castShadow = true;
            spot.receiveShadow = true;
            spot.spotType = type;
            scene.add(spot);

            // Add glow indicator
            const indicatorGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const indicatorMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.6
            });
            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            indicator.position.set(x, height * 2 + 1, z);
            scene.add(indicator);
            spot.indicator = indicator;

            // Animate indicator
            let glowDirection = 1;
            setInterval(() => {
                indicator.material.opacity += 0.02 * glowDirection;
                if (indicator.material.opacity >= 0.8 || indicator.material.opacity <= 0.3) {
                    glowDirection *= -1;
                }
            }, 50);

            return spot;
        }

        function createCharacters() {
            // Maniac (Player 1) - Red, menacing
            const maniacGeometry = new THREE.BoxGeometry(2, 3, 2);
            const maniacMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                roughness: 0.3,
                metalness: 0.7
            });
            maniac = new THREE.Mesh(maniacGeometry, maniacMaterial);
            maniac.position.set(-40, 1.5, 0);
            maniac.castShadow = true;
            scene.add(maniac);

            // Maniac's eyes (menacing glow)
            const eyeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.5, 0.5, 1);
            maniac.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.5, 0.5, 1);
            maniac.add(rightEye);

            // Maniac's light
            const maniacLight = new THREE.PointLight(0xff0000, 2, 15);
            maniac.add(maniacLight);

            // Survivor (Player 2) - Green, smaller
            const survivorGeometry = new THREE.BoxGeometry(1.5, 2.5, 1.5);
            const survivorMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.3,
                roughness: 0.6,
                metalness: 0.4
            });
            survivor = new THREE.Mesh(survivorGeometry, survivorMaterial);
            survivor.position.set(40, 1.25, 0);
            survivor.castShadow = true;
            scene.add(survivor);

            // Survivor's flashlight
            const survivorLight = new THREE.SpotLight(0x00ff88, 1, 20, Math.PI / 6, 0.5);
            survivorLight.position.set(0, 0, 2);
            survivorLight.target = survivor;
            survivor.add(survivorLight);

            // Add velocity
            maniac.velocity = new THREE.Vector3();
            survivor.velocity = new THREE.Vector3();

            // Add rotation tracking
            maniac.rotation.y = Math.PI / 2;
            survivor.rotation.y = -Math.PI / 2;
        }

        function updateManiac(deltaTime) {
            if (!gameActive || !maniac) return;

            const speed = maniacState.speed * deltaTime;
            const sprintMultiplier = (keys['shift'] || keys['ShiftLeft']) && maniacState.stamina > 0 ? 1.5 : 1;
            let moving = false;

            // Movement
            if (keys['w']) {
                maniac.position.x += Math.sin(maniac.rotation.y) * speed * sprintMultiplier;
                maniac.position.z += Math.cos(maniac.rotation.y) * speed * sprintMultiplier;
                moving = true;
            }
            if (keys['s']) {
                maniac.position.x -= Math.sin(maniac.rotation.y) * speed * sprintMultiplier;
                maniac.position.z -= Math.cos(maniac.rotation.y) * speed * sprintMultiplier;
                moving = true;
            }
            if (keys['a']) {
                maniac.rotation.y += 2.5 * deltaTime;
            }
            if (keys['d']) {
                maniac.rotation.y -= 2.5 * deltaTime;
            }

            // Stamina management (rage mode)
            if (moving && sprintMultiplier > 1) {
                maniacState.stamina = Math.max(0, maniacState.stamina - 30 * deltaTime);
                if (moving && Math.random() < 0.1) playFootstep(true);
            } else {
                maniacState.stamina = Math.min(maniacState.maxStamina, maniacState.stamina + 20 * deltaTime);
            }

            // Check rage mode activation
            const distToSurvivor = maniac.position.distanceTo(survivor.position);
            if (distToSurvivor < 15 && !maniacState.rageMode) {
                maniacState.rageMode = true;
                maniacState.speed = maniacState.baseSpeed * 1.3;
                showNotification('MANIAC ENRAGED!', 'maniac');
                playChaseMusic();
                document.getElementById('maniacSpeed').textContent = 'ENRAGED';
                maniac.material.emissiveIntensity = 1.0;
            } else if (distToSurvivor > 25 && maniacState.rageMode) {
                maniacState.rageMode = false;
                maniacState.speed = maniacState.baseSpeed;
                document.getElementById('maniacSpeed').textContent = 'NORMAL';
                maniac.material.emissiveIntensity = 0.5;
            }

            // Attack
            if (keys[' '] && maniacState.canAttack) {
                const attackDist = maniac.position.distanceTo(survivor.position);
                if (attackDist < 3 && !survivorState.isHiding) {
                    catchSurvivor();
                }
                maniacState.canAttack = false;
                setTimeout(() => maniacState.canAttack = true, 500);
            }

            // Break door
            if (keys['e']) {
                for (let door of doors) {
                    const distToDoor = maniac.position.distanceTo(door.position);
                    if (distToDoor < 4 && door.isLocked) {
                        door.health -= 50 * deltaTime;
                        showNotification('Breaking door...', 'maniac');
                        playSound(150, 0.2, 'sawtooth', 0.3);

                        if (door.health <= 0) {
                            door.isLocked = false;
                            door.material.color.setHex(0x1a1a2e);
                            door.indicator.material.color.setHex(0x00ff88);
                            showNotification('Door broken!', 'maniac');
                            playSound(200, 0.5, 'square', 0.4);
                        }
                    }
                }
            }

            // Boundary check
            maniac.position.x = Math.max(-48, Math.min(48, maniac.position.x));
            maniac.position.z = Math.max(-48, Math.min(48, maniac.position.z));

            checkCollision(maniac);
            updateHUD();
        }

        function updateSurvivor(deltaTime) {
            if (!gameActive || !survivor || survivorState.isHiding) return;

            const speed = survivorState.speed * deltaTime;
            const sprintMultiplier = (keys['enter'] || keys['Enter']) && survivorState.stamina > 10 ? 1.4 : 1;
            let moving = false;

            // Movement
            if (keys['arrowup']) {
                survivor.position.x += Math.sin(survivor.rotation.y) * speed * sprintMultiplier;
                survivor.position.z += Math.cos(survivor.rotation.y) * speed * sprintMultiplier;
                moving = true;
            }
            if (keys['arrowdown']) {
                survivor.position.x -= Math.sin(survivor.rotation.y) * speed * sprintMultiplier;
                survivor.position.z -= Math.cos(survivor.rotation.y) * speed * sprintMultiplier;
                moving = true;
            }
            if (keys['arrowleft']) {
                survivor.rotation.y += 2.5 * deltaTime;
            }
            if (keys['arrowright']) {
                survivor.rotation.y -= 2.5 * deltaTime;
            }

            // Stamina management
            if (moving && sprintMultiplier > 1) {
                survivorState.stamina = Math.max(0, survivorState.stamina - 25 * deltaTime);
                if (Math.random() < 0.08) playFootstep(false);
            } else {
                survivorState.stamina = Math.min(survivorState.maxStamina, survivorState.stamina + 15 * deltaTime);
            }

            // Check proximity to hiding spots
            survivorState.isNearInteractable = false;
            for (let spot of hidingSpots) {
                const dist = survivor.position.distanceTo(spot.position);
                if (dist < 4) {
                    survivorState.isNearInteractable = true;
                    survivorState.nearestSpot = spot;
                    spot.indicator.material.opacity = 0.9;
                } else {
                    spot.indicator.material.opacity = 0.5;
                }
            }

            // Check proximity to doors
            for (let door of doors) {
                const dist = survivor.position.distanceTo(door.position);
                if (dist < 4) {
                    survivorState.isNearInteractable = true;
                    survivorState.nearestDoor = door;
                }
            }

            // Hide/Interact
            if ((keys['shiftright'] || keys['ShiftRight']) && survivorState.isNearInteractable) {
                if (survivorState.nearestSpot) {
                    hide();
                } else if (survivorState.nearestDoor && !survivorState.nearestDoor.isLocked) {
                    lockDoor(survivorState.nearestDoor);
                }
                keys['shiftright'] = false;
                keys['ShiftRight'] = false;
            }

            // Place trap
            if ((keys['controlright'] || keys['ControlRight']) && survivorState.trapsRemaining > 0) {
                placeTrap();
                keys['controlright'] = false;
                keys['ControlRight'] = false;
            }

            // Boundary check
            survivor.position.x = Math.max(-48, Math.min(48, survivor.position.x));
            survivor.position.z = Math.max(-48, Math.min(48, survivor.position.z));

            checkCollision(survivor);

            // Check proximity to maniac for heartbeat
            const distToManiac = survivor.position.distanceTo(maniac.position);
            startHeartbeat(distToManiac);

            // Proximity warning
            const proximityWarning = document.getElementById('proximityWarning');
            if (distToManiac < 10) {
                proximityWarning.classList.add('active');
            } else {
                proximityWarning.classList.remove('active');
            }

            updateHUD();
        }

        function hide() {
            survivorState.isHiding = true;
            survivorState.currentHidingSpot = survivorState.nearestSpot;
            survivor.visible = false;
            showNotification('You are hiding! Press SHIFT to exit', 'survivor');
            playHideSound();
            document.getElementById('hidingIndicator').classList.add('show');
            document.getElementById('survivorStatus').textContent = 'HIDING';

            // Check for exit
            const checkExit = () => {
                if (!survivorState.isHiding) return;

                if (keys['shiftright'] || keys['ShiftRight']) {
                    exitHiding();
                    keys['shiftright'] = false;
                    keys['ShiftRight'] = false;
                } else {
                    requestAnimationFrame(checkExit);
                }
            };
            checkExit();
        }

        function exitHiding() {
            survivorState.isHiding = false;
            survivorState.currentHidingSpot = null;
            survivor.visible = true;
            document.getElementById('hidingIndicator').classList.remove('show');
            document.getElementById('survivorStatus').textContent = 'RUNNING';
            showNotification('You left your hiding spot', 'info');
        }

        function lockDoor(door) {
            door.isLocked = true;
            door.health = 100;
            door.material.color.setHex(0xff6600);
            door.indicator.material.color.setHex(0xff0000);
            showNotification('Door locked!', 'survivor');
            playDoorSound();

            // Auto-unlock after time based on difficulty
            const lockTime = selectedDifficulty === 'easy' ? 30000 :
                           selectedDifficulty === 'normal' ? 20000 :
                           selectedDifficulty === 'hard' ? 10000 : 5000;

            setTimeout(() => {
                if (door.isLocked) {
                    door.isLocked = false;
                    door.material.color.setHex(0x1a1a2e);
                    door.indicator.material.color.setHex(0x00ff88);
                }
            }, lockTime);
        }

        function placeTrap() {
            if (survivorState.trapsRemaining <= 0) return;

            const trapGeometry = new THREE.CylinderGeometry(1, 1, 0.2, 16);
            const trapMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 0.9,
                roughness: 0.3
            });
            const trap = new THREE.Mesh(trapGeometry, trapMaterial);
            trap.position.copy(survivor.position);
            trap.position.y = 0.1;
            trap.castShadow = true;
            trap.receiveShadow = true;
            trap.active = true;

            scene.add(trap);
            traps.push(trap);

            survivorState.trapsRemaining--;
            showNotification('Trap placed!', 'survivor');
            playSound(400, 0.2, 'square', 0.3);
            updateHUD();
        }

        function checkCollision(character) {
            // Character size (half-extents)
            const charHalfSize = character === maniac ? 1.0 : 0.75;

            for (let obstacle of obstacles) {
                // Get obstacle dimensions from geometry
                const obstacleGeometry = obstacle.geometry;
                const obstacleHalfWidth = obstacleGeometry.parameters.width / 2;
                const obstacleHalfDepth = obstacleGeometry.parameters.depth / 2;

                // Calculate distances
                const dx = Math.abs(character.position.x - obstacle.position.x);
                const dz = Math.abs(character.position.z - obstacle.position.z);

                // Check if bounding boxes overlap
                const overlapX = dx < (charHalfSize + obstacleHalfWidth);
                const overlapZ = dz < (charHalfSize + obstacleHalfDepth);

                if (overlapX && overlapZ) {
                    // Collision detected - push character out
                    const overlapAmountX = (charHalfSize + obstacleHalfWidth) - dx;
                    const overlapAmountZ = (charHalfSize + obstacleHalfDepth) - dz;

                    // Push out on the axis with smallest overlap
                    if (overlapAmountX < overlapAmountZ) {
                        // Push out on X axis
                        if (character.position.x < obstacle.position.x) {
                            character.position.x -= overlapAmountX;
                        } else {
                            character.position.x += overlapAmountX;
                        }
                    } else {
                        // Push out on Z axis
                        if (character.position.z < obstacle.position.z) {
                            character.position.z -= overlapAmountZ;
                        } else {
                            character.position.z += overlapAmountZ;
                        }
                    }
                }
            }

            // Check door collision (for both locked and unlocked doors)
            for (let door of doors) {
                const doorGeometry = door.geometry;
                const doorHalfWidth = doorGeometry.parameters.width / 2;
                const doorHalfDepth = doorGeometry.parameters.depth / 2;

                const dx = Math.abs(character.position.x - door.position.x);
                const dz = Math.abs(character.position.z - door.position.z);

                const overlapX = dx < (charHalfSize + doorHalfWidth);
                const overlapZ = dz < (charHalfSize + doorHalfDepth);

                if (overlapX && overlapZ) {
                    // Only block if door is locked
                    if (door.isLocked) {
                        const overlapAmountX = (charHalfSize + doorHalfWidth) - dx;
                        const overlapAmountZ = (charHalfSize + doorHalfDepth) - dz;

                        if (overlapAmountX < overlapAmountZ) {
                            if (character.position.x < door.position.x) {
                                character.position.x -= overlapAmountX;
                            } else {
                                character.position.x += overlapAmountX;
                            }
                        } else {
                            if (character.position.z < door.position.z) {
                                character.position.z -= overlapAmountZ;
                            } else {
                                character.position.z += overlapAmountZ;
                            }
                        }
                    }
                }
            }
        }

        function updateTraps(deltaTime) {
            for (let i = traps.length - 1; i >= 0; i--) {
                const trap = traps[i];
                if (!trap.active) continue;

                // Check if maniac steps on trap
                const dist = maniac.position.distanceTo(trap.position);
                if (dist < 2) {
                    trap.active = false;
                    maniacState.speed *= 0.5;
                    showNotification('MANIAC TRAPPED!', 'survivor');
                    playTrapSound();

                    // Create explosion effect
                    createTrapExplosion(trap.position);

                    // Remove trap
                    scene.remove(trap);
                    traps.splice(i, 1);

                    // Reset speed after duration
                    setTimeout(() => {
                        maniacState.speed = maniacState.baseSpeed;
                        if (maniacState.rageMode) {
                            maniacState.speed *= 1.3;
                        }
                    }, 5000);
                }
            }
        }

        function createTrapExplosion(position) {
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.2, 4, 4);
                const material = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                const particle = new THREE.Mesh(geometry, material);

                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 10
                );

                scene.add(particle);

                // Animate and remove
                let life = 1;
                const animate = () => {
                    life -= 0.02;
                    if (life <= 0) {
                        scene.remove(particle);
                        return;
                    }
                    particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                    particle.velocity.y -= 0.2;
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }

        function catchSurvivor() {
            gameActive = false;
            playScreamSound();
            screenShake();
            showBloodEffect();
            showNotification('SURVIVOR CAUGHT!', 'maniac');
            setTimeout(() => endGame(false), 2000);
        }

        function screenShake() {
            const hud = document.getElementById('hud');
            hud.classList.add('screen-shake');
            setTimeout(() => hud.classList.remove('screen-shake'), 500);
        }

        function showBloodEffect() {
            const blood = document.getElementById('bloodEffect');
            blood.classList.add('show');
            setTimeout(() => blood.classList.remove('show'), 1000);
        }

        function updateTimer(deltaTime) {
            if (!gameActive) return;

            gameTime -= deltaTime;

            if (gameTime <= 0) {
                gameTime = 0;
                endGame(true);
            }

            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            const timerElement = document.getElementById('timerValue');
            timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            if (gameTime <= 30) {
                timerElement.classList.add('warning');
            }
        }

        function updateHUD() {
            // Maniac
            const maniacStaminaPercent = (maniacState.stamina / maniacState.maxStamina) * 100;
            document.getElementById('maniacStamina').style.width = maniacStaminaPercent + '%';
            document.getElementById('maniacStatus').textContent = maniacState.rageMode ? 'ENRAGED' : 'HUNTING';

            // Survivor
            const survivorStaminaPercent = (survivorState.stamina / survivorState.maxStamina) * 100;
            document.getElementById('survivorStamina').style.width = survivorStaminaPercent + '%';
            document.getElementById('trapsCount').textContent = survivorState.trapsRemaining;
        }

        function showNotification(message, type) {
            const notifications = document.getElementById('notifications');
            const notif = document.createElement('div');
            notif.className = `notification ${type}`;
            notif.textContent = message;
            notifications.appendChild(notif);

            setTimeout(() => {
                notif.remove();
            }, 4000);
        }

        // Game loop
        let lastTime = performance.now();

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (gameActive) {
                updateManiac(deltaTime);
                updateSurvivor(deltaTime);
                updateTraps(deltaTime);
                updateTimer(deltaTime);

                // Dynamic camera
                const midpoint = new THREE.Vector3();
                midpoint.addVectors(maniac.position, survivor.position).multiplyScalar(0.5);

                const distance = maniac.position.distanceTo(survivor.position);
                const cameraHeight = 30 + distance * 0.5;
                const cameraDistance = 25 + distance * 0.3;

                camera.position.x = midpoint.x * 0.2;
                camera.position.y = cameraHeight;
                camera.position.z = midpoint.z * 0.2 + cameraDistance;
                camera.lookAt(midpoint.x, 0, midpoint.z);
            }

            renderer.render(scene, camera);
        }

        // Menu functions
        function setDifficulty(difficulty) {
            selectedDifficulty = difficulty;

            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');

            // Adjust game parameters based on difficulty
            switch(difficulty) {
                case 'easy':
                    maniacState.baseSpeed = 8;
                    survivorState.baseSpeed = 10;
                    survivorState.trapsRemaining = 5;
                    break;
                case 'normal':
                    maniacState.baseSpeed = 10;
                    survivorState.baseSpeed = 9;
                    survivorState.trapsRemaining = 3;
                    break;
                case 'hard':
                    maniacState.baseSpeed = 12;
                    survivorState.baseSpeed = 9;
                    survivorState.trapsRemaining = 2;
                    break;
                case 'nightmare':
                    maniacState.baseSpeed = 14;
                    survivorState.baseSpeed = 8;
                    survivorState.trapsRemaining = 1;
                    break;
            }
        }

        function adjustTime(delta) {
            selectedTime = Math.max(60, Math.min(600, selectedTime + delta * 60));
            const minutes = Math.floor(selectedTime / 60);
            const seconds = selectedTime % 60;
            document.getElementById('timeDisplay').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startGame() {
            gameTime = selectedTime;
            gameActive = true;

            // Reset states
            maniacState = {
                stamina: 100,
                maxStamina: 100,
                speed: maniacState.baseSpeed,
                baseSpeed: maniacState.baseSpeed,
                rageMode: false,
                canAttack: true,
                lastAttack: 0
            };

            survivorState.stamina = 100;
            survivorState.isHiding = false;
            survivorState.currentHidingSpot = null;

            // Reset positions
            maniac.position.set(-40, 1.5, 0);
            maniac.visible = true;
            survivor.position.set(40, 1.25, 0);
            survivor.visible = true;

            // Clear traps
            traps.forEach(trap => scene.remove(trap));
            traps = [];

            // Reset doors
            doors.forEach(door => {
                door.isLocked = false;
                door.health = 100;
                door.material.color.setHex(0x4a2c2a);
                door.indicator.material.color.setHex(0x00ff88);
            });

            // Update cursor
            document.getElementById('cursor').classList.remove('survivor');

            document.getElementById('menu').classList.add('hidden');
            document.getElementById('gameOver').classList.remove('show');

            updateHUD();
            showNotification('SURVIVE FOR ' + Math.floor(gameTime / 60) + ' MINUTES!', 'info');
        }

        function endGame(survivorWon) {
            gameActive = false;

            const gameOver = document.getElementById('gameOver');
            const title = document.getElementById('gameOverTitle');
            const subtitle = document.getElementById('gameOverSubtitle');
            const stats = document.getElementById('gameStats');

            if (survivorWon) {
                title.textContent = 'SURVIVOR WINS!';
                title.className = 'game-over-title survivor-win';
                subtitle.textContent = 'You managed to survive!';
                playSound(800, 1, 'sine', 0.3);
            } else {
                title.textContent = 'MANIAC WINS!';
                title.className = 'game-over-title maniac-win';
                subtitle.textContent = 'The survivor was caught...';
                playScreamSound();
            }

            const timeElapsed = selectedTime - gameTime;
            const minutes = Math.floor(timeElapsed / 60);
            const seconds = Math.floor(timeElapsed % 60);

            stats.innerHTML = `
                <div class="stat-row">
                    <span>Time Survived:</span>
                    <span style="color: #00d4ff">${minutes}:${seconds.toString().padStart(2, '0')}</span>
                </div>
                <div class="stat-row">
                    <span>Difficulty:</span>
                    <span style="color: #ff6600">${selectedDifficulty.toUpperCase()}</span>
                </div>
                <div class="stat-row">
                    <span>Traps Used:</span>
                    <span style="color: #00ff88">${3 - survivorState.trapsRemaining}</span>
                </div>
                <div class="stat-row">
                    <span>Final Distance:</span>
                    <span style="color: #fff">${Math.floor(maniac.position.distanceTo(survivor.position))}m</span>
                </div>
            `;

            gameOver.classList.add('show');

            // Stop heartbeat
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                document.getElementById('heartbeat').classList.remove('active');
            }
        }

        function backToMenu() {
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('menu').classList.remove('hidden');
            gameActive = false;
        }

        function restartGame() {
            document.getElementById('gameOver').classList.remove('show');
            startGame();
        }

        // Initialize
        initThree();
        gameLoop();
    </script>
</body>
</html>
