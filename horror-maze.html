<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE MAZE - First Person Horror</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #fff;
        }
        #gameContainer { width: 100vw; height: 100vh; }
        canvas { display: block; }

        .crosshair {
            position: fixed;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }
        .crosshair::before { width: 20px; height: 2px; left: -10px; top: -1px; }
        .crosshair::after { width: 2px; height: 20px; left: -1px; top: -10px; }

        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 40%, rgba(0, 0, 0, 0.7) 100%);
            z-index: 50;
        }

        .blood-vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 20%, rgba(180, 0, 0, 0.8) 100%);
            opacity: 0;
            z-index: 51;
            transition: opacity 0.3s;
        }

        #hud {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 16px;
            border: 1px solid #333;
        }

        .battery-container { bottom: 20px; left: 20px; min-width: 180px; }
        .stamina-container { bottom: 20px; right: 20px; min-width: 180px; }

        .bar-label {
            color: #888;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .bar-bg {
            background: #222;
            height: 16px;
            border: 1px solid #444;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s;
        }

        #batteryBar { background: linear-gradient(90deg, #ff3300, #ffcc00, #33ff00); }
        #staminaBar { background: linear-gradient(90deg, #0066ff, #00ccff); }

        .battery-low { animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

        .objective {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        .objective-text {
            color: #ff4444;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .warning-text {
            position: absolute;
            top: 80px; left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 24px;
            opacity: 0;
            transition: opacity 0.2s;
            text-shadow: 0 0 20px #ff0000;
        }

        .heartbeat {
            position: absolute;
            bottom: 100px; left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: #ff0000;
            opacity: 0;
            text-shadow: 0 0 20px #ff0000;
        }

        /* Screens */
        .game-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #startScreen { background: linear-gradient(180deg, #000 0%, #200000 50%, #000 100%); }
        #gameOverScreen, #winScreen { background: rgba(0, 0, 0, 0.95); display: none; }

        .title {
            font-size: 72px;
            color: #ff0000;
            text-shadow: 0 0 40px #ff0000;
            margin-bottom: 16px;
            letter-spacing: 16px;
            animation: flicker 4s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.2; }
            94% { opacity: 1; }
            96% { opacity: 0.4; }
        }

        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 50px;
            letter-spacing: 4px;
        }

        .game-btn {
            background: transparent;
            border: 2px solid #ff0000;
            color: #ff0000;
            padding: 16px 50px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            letter-spacing: 4px;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .game-btn:hover {
            background: #ff0000;
            color: #000;
            box-shadow: 0 0 40px #ff0000;
        }

        .instructions {
            margin-top: 40px;
            color: #555;
            text-align: center;
            line-height: 2;
        }
        .instructions span { color: #999; }

        .game-over-title {
            font-size: 90px;
            color: #ff0000;
            text-shadow: 0 0 40px #ff0000;
            animation: shake 0.1s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }

        .game-over-sub, .win-sub {
            font-size: 20px;
            color: #880000;
            margin: 30px 0 50px;
        }

        .win-title {
            font-size: 72px;
            color: #00ff00;
            text-shadow: 0 0 40px #00ff00;
        }
        .win-sub { color: #008800; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <div class="crosshair"></div>
    <div class="vignette"></div>
    <div class="blood-vignette" id="bloodVignette"></div>

    <div id="hud">
        <div class="hud-panel battery-container">
            <div class="bar-label">Flashlight</div>
            <div class="bar-bg"><div class="bar-fill" id="batteryBar" style="width: 100%"></div></div>
        </div>
        <div class="hud-panel stamina-container">
            <div class="bar-label">Stamina</div>
            <div class="bar-bg"><div class="bar-fill" id="staminaBar" style="width: 100%"></div></div>
        </div>
        <div class="objective"><div class="objective-text">FIND THE EXIT</div></div>
        <div class="warning-text" id="warningText">HE'S CLOSE...</div>
        <div class="heartbeat" id="heartbeat">‚ù§</div>
    </div>

    <div class="game-screen" id="startScreen">
        <div class="title">THE MAZE</div>
        <div class="subtitle">He's watching. He's waiting. He's hunting.</div>
        <button class="game-btn" id="startBtn">ENTER</button>
        <div class="instructions">
            <span>WASD</span> - Move | <span>MOUSE</span> - Look<br>
            <span>SHIFT</span> - Sprint | <span>F</span> - Toggle Flashlight<br>
            Find the <span style="color:#0f0">green exit</span> before HE finds you
        </div>
    </div>

    <div class="game-screen" id="gameOverScreen">
        <div class="game-over-title">DEAD</div>
        <div class="game-over-sub">The maniac caught you...</div>
        <button class="game-btn" id="restartBtn">TRY AGAIN</button>
    </div>

    <div class="game-screen" id="winScreen">
        <div class="win-title">ESCAPED</div>
        <div class="win-sub">You made it out alive... this time.</div>
        <button class="game-btn" id="playAgainBtn">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== AUDIO ====================
        let audioCtx = null;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(freq, duration, type = 'sine', volume = 0.3) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playHeartbeat() { playSound(55, 0.2, 'sine', 0.5); }

        function playFootstep() {
            if (!audioCtx) return;
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.08, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.05));
            }
            const src = audioCtx.createBufferSource();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            src.buffer = buffer;
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            src.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = 0.4;
            src.start();
        }

        function playManiacSound() { playSound(70 + Math.random() * 30, 0.6, 'sawtooth', 0.15); }

        // ==================== GAME SETUP ====================
        let scene, camera, renderer, clock;
        let flashlight, flashlightTarget;
        let maniacMesh;
        let maze = [];
        let walls = [];
        let gameRunning = false;

        const MAZE_SIZE = 15;
        const CELL_SIZE = 5;
        const WALL_HEIGHT = 4;

        const player = {
            stamina: 100,
            battery: 100,
            flashlightOn: true
        };

        const maniac = {
            pos: new THREE.Vector3(),
            isChasing: false,
            lastSeen: new THREE.Vector3(),
            patrol: null
        };

        const keys = {};
        let mouseX = 0, mouseY = 0;
        let isLocked = false;
        let exitPos = new THREE.Vector3();

        let footstepTimer = 0;
        let heartbeatTimer = 0;

        // ==================== MAZE GENERATION ====================
        function generateMaze() {
            maze = Array.from({ length: MAZE_SIZE }, () => Array(MAZE_SIZE).fill(1));

            const stack = [{ x: 1, y: 1 }];
            maze[1][1] = 0;

            while (stack.length > 0) {
                const curr = stack[stack.length - 1];
                const neighbors = [];
                const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]];

                for (const [dx, dy] of dirs) {
                    const nx = curr.x + dx, ny = curr.y + dy;
                    if (nx > 0 && nx < MAZE_SIZE - 1 && ny > 0 && ny < MAZE_SIZE - 1 && maze[ny][nx] === 1) {
                        neighbors.push({ x: nx, y: ny, wx: curr.x + dx / 2, wy: curr.y + dy / 2 });
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[next.wy][next.wx] = 0;
                    maze[next.y][next.x] = 0;
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }

            // Exit
            maze[MAZE_SIZE - 2][MAZE_SIZE - 2] = 2;
            maze[MAZE_SIZE - 2][MAZE_SIZE - 3] = 0;
            maze[MAZE_SIZE - 3][MAZE_SIZE - 2] = 0;
        }

        // ==================== THREE.JS INIT ====================
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 5, 40);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(1.5 * CELL_SIZE, 1.7, 1.5 * CELL_SIZE);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            generateMaze();
            createEnvironment();
            createManiac();
            createFlashlight();

            // Ambient light
            scene.add(new THREE.AmbientLight(0x222233, 0.4));

            clock = new THREE.Clock();

            // Events
            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyF' && gameRunning) {
                    player.flashlightOn = !player.flashlightOn;
                    flashlight.visible = player.flashlightOn && player.battery > 0;
                }
            });
            document.addEventListener('keyup', e => keys[e.code] = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', () => {
                if (gameRunning && !isLocked) renderer.domElement.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === renderer.domElement;
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function onMouseMove(e) {
            if (isLocked && gameRunning) {
                mouseX += e.movementX * 0.002;
                mouseY = Math.max(-1.4, Math.min(1.4, mouseY - e.movementY * 0.002));
            }
        }

        // ==================== ENVIRONMENT ====================
        function createEnvironment() {
            // Clear old walls
            walls.forEach(w => scene.remove(w));
            walls = [];

            // Wall material
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x333340,
                roughness: 0.9,
                metalness: 0.1
            });

            // Create walls
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[y][x] === 1) {
                        const wall = new THREE.Mesh(
                            new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE),
                            wallMat
                        );
                        wall.position.set(
                            x * CELL_SIZE + CELL_SIZE / 2,
                            WALL_HEIGHT / 2,
                            y * CELL_SIZE + CELL_SIZE / 2
                        );
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }

            // Floor
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1f, roughness: 0.95 });
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(MAZE_SIZE * CELL_SIZE, MAZE_SIZE * CELL_SIZE),
                floorMat
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(MAZE_SIZE * CELL_SIZE / 2, 0, MAZE_SIZE * CELL_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);

            // Ceiling
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(MAZE_SIZE * CELL_SIZE, MAZE_SIZE * CELL_SIZE),
                new THREE.MeshStandardMaterial({ color: 0x111115, roughness: 1 })
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(MAZE_SIZE * CELL_SIZE / 2, WALL_HEIGHT, MAZE_SIZE * CELL_SIZE / 2);
            scene.add(ceiling);

            // Exit
            exitPos.set((MAZE_SIZE - 2) * CELL_SIZE + CELL_SIZE / 2, 0, (MAZE_SIZE - 2) * CELL_SIZE + CELL_SIZE / 2);

            const exitLight = new THREE.PointLight(0x00ff00, 3, 20);
            exitLight.position.set(exitPos.x, 2, exitPos.z);
            scene.add(exitLight);

            const exitMarker = new THREE.Mesh(
                new THREE.PlaneGeometry(CELL_SIZE * 0.7, CELL_SIZE * 0.7),
                new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.8
                })
            );
            exitMarker.rotation.x = -Math.PI / 2;
            exitMarker.position.set(exitPos.x, 0.02, exitPos.z);
            scene.add(exitMarker);
        }

        // ==================== MANIAC ====================
        function createManiac() {
            if (maniacMesh) scene.remove(maniacMesh);

            maniacMesh = new THREE.Group();

            // Body
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.45, 1.6, 8), bodyMat);
            body.position.y = 0.8;
            body.castShadow = true;
            maniacMesh.add(body);

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 12), bodyMat);
            head.position.y = 1.8;
            head.castShadow = true;
            maniacMesh.add(head);

            // Eyes
            const eyeMat = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 3
            });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
            leftEye.position.set(-0.1, 1.85, 0.22);
            maniacMesh.add(leftEye);

            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
            rightEye.position.set(0.1, 1.85, 0.22);
            maniacMesh.add(rightEye);

            // Eye glow
            const eyeLight = new THREE.PointLight(0xff0000, 1, 8);
            eyeLight.position.set(0, 1.85, 0.3);
            maniacMesh.add(eyeLight);

            maniac.pos.set(
                (MAZE_SIZE - 2) * CELL_SIZE + CELL_SIZE / 2,
                0,
                (MAZE_SIZE - 4) * CELL_SIZE + CELL_SIZE / 2
            );
            maniacMesh.position.copy(maniac.pos);
            scene.add(maniacMesh);
        }

        // ==================== FLASHLIGHT ====================
        function createFlashlight() {
            flashlight = new THREE.SpotLight(0xffffff, 2, 35, Math.PI / 5, 0.4, 1);
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 512;
            flashlight.shadow.mapSize.height = 512;

            flashlightTarget = new THREE.Object3D();
            scene.add(flashlightTarget);
            flashlight.target = flashlightTarget;

            camera.add(flashlight);
            flashlight.position.set(0.2, -0.1, 0);
            scene.add(camera);
        }

        // ==================== COLLISION ====================
        function checkCollision(pos, radius = 0.4) {
            const mx = Math.floor(pos.x / CELL_SIZE);
            const mz = Math.floor(pos.z / CELL_SIZE);

            for (let dz = -1; dz <= 1; dz++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const cx = mx + dx, cz = mz + dz;
                    if (cx >= 0 && cx < MAZE_SIZE && cz >= 0 && cz < MAZE_SIZE && maze[cz][cx] === 1) {
                        const wcx = cx * CELL_SIZE + CELL_SIZE / 2;
                        const wcz = cz * CELL_SIZE + CELL_SIZE / 2;
                        const closestX = Math.max(wcx - CELL_SIZE / 2, Math.min(pos.x, wcx + CELL_SIZE / 2));
                        const closestZ = Math.max(wcz - CELL_SIZE / 2, Math.min(pos.z, wcz + CELL_SIZE / 2));
                        const dist = Math.hypot(pos.x - closestX, pos.z - closestZ);
                        if (dist < radius) return true;
                    }
                }
            }
            return false;
        }

        function hasLineOfSight(from, to) {
            const dir = new THREE.Vector3().subVectors(to, from).normalize();
            const dist = from.distanceTo(to);
            const ray = new THREE.Raycaster(from, dir, 0, dist);
            return ray.intersectObjects(walls).length === 0;
        }

        // ==================== UPDATE PLAYER ====================
        function updatePlayer(dt) {
            const running = (keys['ShiftLeft'] || keys['ShiftRight']) && player.stamina > 0;
            const speed = running ? 9 : 5;

            // Stamina
            if (running && (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'])) {
                player.stamina = Math.max(0, player.stamina - dt * 25);
            } else {
                player.stamina = Math.min(100, player.stamina + dt * 12);
            }

            // Battery
            if (player.flashlightOn) {
                player.battery = Math.max(0, player.battery - dt * 1.5);
                if (player.battery <= 0) {
                    player.flashlightOn = false;
                    flashlight.visible = false;
                }
            }
            flashlight.intensity = 2 * (player.battery / 100);

            // Camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = -mouseX;
            camera.rotation.x = mouseY;

            // Update flashlight target
            const target = new THREE.Vector3(0, 0, -15);
            target.applyQuaternion(camera.quaternion);
            target.add(camera.position);
            flashlightTarget.position.copy(target);

            // Movement
            const move = new THREE.Vector3();
            if (keys['KeyW']) move.z -= 1;
            if (keys['KeyS']) move.z += 1;
            if (keys['KeyA']) move.x -= 1;
            if (keys['KeyD']) move.x += 1;

            if (move.length() > 0) {
                move.normalize().applyAxisAngle(new THREE.Vector3(0, 1, 0), -mouseX);

                const newX = camera.position.x + move.x * speed * dt;
                const newZ = camera.position.z + move.z * speed * dt;

                if (!checkCollision(new THREE.Vector3(newX, 0, camera.position.z))) camera.position.x = newX;
                if (!checkCollision(new THREE.Vector3(camera.position.x, 0, newZ))) camera.position.z = newZ;

                // Head bob
                const bobSpeed = running ? 14 : 10;
                const bobAmt = running ? 0.1 : 0.05;
                camera.position.y = 1.7 + Math.sin(performance.now() * 0.001 * bobSpeed) * bobAmt;

                // Footsteps
                footstepTimer += dt;
                if (footstepTimer > (running ? 0.25 : 0.4)) {
                    footstepTimer = 0;
                    playFootstep();
                }
            }

            // Win check
            if (camera.position.distanceTo(exitPos) < 2) {
                winGame();
            }
        }

        // ==================== UPDATE MANIAC ====================
        function updateManiac(dt) {
            const playerPos = new THREE.Vector3(camera.position.x, 0, camera.position.z);
            const maniacPos = new THREE.Vector3(maniac.pos.x, 0, maniac.pos.z);
            const dist = playerPos.distanceTo(maniacPos);

            // Line of sight check
            const canSee = hasLineOfSight(
                new THREE.Vector3(maniac.pos.x, 1.5, maniac.pos.z),
                new THREE.Vector3(camera.position.x, 1.5, camera.position.z)
            );

            if (canSee || dist < 10) {
                maniac.isChasing = true;
                maniac.lastSeen.copy(playerPos);
            }

            // Blood vignette
            const danger = Math.max(0, 1 - dist / 20);
            document.getElementById('bloodVignette').style.opacity = danger * 0.7;

            // Warning text
            const warning = document.getElementById('warningText');
            if (dist < 15) {
                warning.style.opacity = 1;
                warning.textContent = dist < 8 ? "HE'S RIGHT BEHIND YOU!" : "HE'S CLOSE...";
            } else {
                warning.style.opacity = 0;
            }

            // Movement
            let targetPos, speed;
            if (maniac.isChasing) {
                targetPos = maniac.lastSeen;
                speed = 6;
                if (maniacPos.distanceTo(targetPos) < 1) maniac.isChasing = false;
            } else {
                if (!maniac.patrol || maniacPos.distanceTo(maniac.patrol) < 1) {
                    for (let i = 0; i < 10; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const newTarget = new THREE.Vector3(
                            maniac.pos.x + Math.cos(angle) * CELL_SIZE * 3,
                            0,
                            maniac.pos.z + Math.sin(angle) * CELL_SIZE * 3
                        );
                        if (!checkCollision(newTarget, 0.5)) {
                            maniac.patrol = newTarget;
                            break;
                        }
                    }
                }
                targetPos = maniac.patrol || maniacPos;
                speed = 3;
            }

            const dir = new THREE.Vector3().subVectors(targetPos, maniacPos).normalize();
            const moveX = maniac.pos.x + dir.x * speed * dt;
            const moveZ = maniac.pos.z + dir.z * speed * dt;

            if (!checkCollision(new THREE.Vector3(moveX, 0, maniac.pos.z), 0.5)) maniac.pos.x = moveX;
            if (!checkCollision(new THREE.Vector3(maniac.pos.x, 0, moveZ), 0.5)) maniac.pos.z = moveZ;

            maniacMesh.position.copy(maniac.pos);
            if (dir.length() > 0.1) maniacMesh.rotation.y = Math.atan2(dir.x, dir.z);

            // Maniac sounds
            if (maniac.isChasing && Math.random() < dt * 0.5) playManiacSound();

            // Death check
            if (dist < 1.2) loseGame();

            // Heartbeat
            if (dist < 20) {
                heartbeatTimer += dt;
                const interval = Math.max(0.25, dist / 20);
                if (heartbeatTimer > interval) {
                    heartbeatTimer = 0;
                    playHeartbeat();
                    const hb = document.getElementById('heartbeat');
                    hb.style.opacity = 1;
                    setTimeout(() => hb.style.opacity = 0, 100);
                }
            }
        }

        // ==================== HUD ====================
        function updateHUD() {
            document.getElementById('batteryBar').style.width = player.battery + '%';
            document.getElementById('staminaBar').style.width = player.stamina + '%';

            const bb = document.getElementById('batteryBar');
            bb.classList.toggle('battery-low', player.battery < 20);
        }

        // ==================== GAME STATE ====================
        function loseGame() {
            gameRunning = false;
            document.exitPointerLock();
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function winGame() {
            gameRunning = false;
            document.exitPointerLock();
            document.getElementById('winScreen').style.display = 'flex';
        }

        // ==================== GAME LOOP ====================
        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            updatePlayer(dt);
            updateManiac(dt);
            updateHUD();
            renderer.render(scene, camera);
        }

        // ==================== START/RESTART ====================
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';

            initAudio();
            if (!scene) init();

            generateMaze();
            createEnvironment();
            createManiac();

            // Reset player
            camera.position.set(1.5 * CELL_SIZE, 1.7, 1.5 * CELL_SIZE);
            mouseX = 0;
            mouseY = 0;
            player.stamina = 100;
            player.battery = 100;
            player.flashlightOn = true;
            flashlight.visible = true;

            // Reset maniac
            maniac.pos.set(
                (MAZE_SIZE - 2) * CELL_SIZE + CELL_SIZE / 2,
                0,
                (MAZE_SIZE - 4) * CELL_SIZE + CELL_SIZE / 2
            );
            maniac.isChasing = false;
            maniac.patrol = null;

            document.getElementById('bloodVignette').style.opacity = 0;

            gameRunning = true;
            clock.start();
            animate();
            renderer.domElement.requestPointerLock();
        }

        function restart() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            startGame();
        }

        // Button events
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restart);
        document.getElementById('playAgainBtn').addEventListener('click', restart);
    </script>
</body>
</html>
