<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE MAZE - First Person Horror</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #fff;
            cursor: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* Custom cursor */
        #cursor {
            position: fixed;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #fff;
        }

        /* Crosshair */
        .crosshair {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }

        .crosshair::before {
            width: 20px;
            height: 2px;
            left: -10px;
            top: -1px;
        }

        .crosshair::after {
            width: 2px;
            height: 20px;
            left: -1px;
            top: -10px;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Vignette effect */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.9) 100%);
            opacity: 0.7;
            z-index: 50;
        }

        /* Blood vignette when maniac is close */
        .blood-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 30%, rgba(139, 0, 0, 0.6) 100%);
            opacity: 0;
            z-index: 51;
            transition: opacity 0.3s;
        }

        /* Flashlight battery */
        .battery-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border: 2px solid #444;
            min-width: 200px;
        }

        .battery-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .battery-bar-bg {
            background: #222;
            height: 20px;
            border: 1px solid #444;
            position: relative;
        }

        .battery-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s;
        }

        .battery-bar.low {
            background: #ff0000;
            animation: batteryPulse 0.5s infinite;
        }

        @keyframes batteryPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stamina */
        .stamina-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border: 2px solid #444;
            min-width: 200px;
        }

        .stamina-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stamina-bar-bg {
            background: #222;
            height: 20px;
            border: 1px solid #444;
        }

        .stamina-bar {
            height: 100%;
            background: linear-gradient(90deg, #0088ff, #00ffff);
            transition: width 0.1s;
        }

        /* Objective */
        .objective {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border: 2px solid #ff0000;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
        }

        .objective-text {
            color: #ff4444;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: objectivePulse 2s infinite;
        }

        @keyframes objectivePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Warning indicator */
        .warning-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            color: #ff0000;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 50px #ff0000;
            z-index: 200;
        }

        /* Breathing overlay */
        .breathing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: rgba(0, 0, 0, 0);
            z-index: 52;
        }

        /* Start screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #000 0%, #1a0000 50%, #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: default;
        }

        .title {
            font-size: 80px;
            color: #ff0000;
            text-shadow: 0 0 50px #ff0000, 0 0 100px #ff0000;
            margin-bottom: 20px;
            letter-spacing: 20px;
            animation: titleFlicker 3s infinite;
        }

        @keyframes titleFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.3; }
            94% { opacity: 1; }
            96% { opacity: 0.5; }
            97% { opacity: 1; }
        }

        .subtitle {
            font-size: 20px;
            color: #666;
            margin-bottom: 60px;
            letter-spacing: 5px;
        }

        .start-btn {
            background: transparent;
            border: 3px solid #ff0000;
            color: #ff0000;
            padding: 20px 60px;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            letter-spacing: 5px;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .start-btn:hover {
            background: #ff0000;
            color: #000;
            box-shadow: 0 0 50px #ff0000;
        }

        .instructions {
            margin-top: 50px;
            color: #444;
            text-align: center;
            line-height: 2;
        }

        .instructions span {
            color: #888;
        }

        /* Game over screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: default;
        }

        .game-over-title {
            font-size: 100px;
            color: #ff0000;
            text-shadow: 0 0 50px #ff0000;
            margin-bottom: 30px;
            animation: gameOverShake 0.1s infinite;
        }

        @keyframes gameOverShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .game-over-subtitle {
            font-size: 24px;
            color: #880000;
            margin-bottom: 50px;
        }

        /* Win screen */
        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: default;
        }

        .win-title {
            font-size: 80px;
            color: #00ff00;
            text-shadow: 0 0 50px #00ff00;
            margin-bottom: 30px;
        }

        .win-subtitle {
            font-size: 24px;
            color: #008800;
            margin-bottom: 50px;
        }

        /* Heartbeat */
        .heartbeat-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: #ff0000;
            opacity: 0;
        }

        /* Minimap */
        .minimap-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 2px solid #333;
        }

        #minimap {
            display: block;
        }

        /* Distance indicator */
        .distance-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="cursor"></div>
    <div class="crosshair"></div>

    <div class="vignette"></div>
    <div class="blood-vignette" id="bloodVignette"></div>
    <div class="breathing-overlay" id="breathingOverlay"></div>

    <div id="hud">
        <div class="battery-container">
            <div class="battery-label">Flashlight</div>
            <div class="battery-bar-bg">
                <div class="battery-bar" id="batteryBar"></div>
            </div>
        </div>

        <div class="stamina-container">
            <div class="stamina-label">Stamina</div>
            <div class="stamina-bar-bg">
                <div class="stamina-bar" id="staminaBar"></div>
            </div>
        </div>

        <div class="objective">
            <div class="objective-text" id="objectiveText">FIND THE EXIT</div>
        </div>

        <div class="distance-indicator" id="distanceIndicator">HE'S CLOSE...</div>

        <div class="heartbeat-indicator" id="heartbeat">&#x2764;</div>

        <div class="minimap-container">
            <canvas id="minimap" width="150" height="150"></canvas>
        </div>
    </div>

    <div class="warning-indicator" id="warningIndicator">!</div>

    <div id="startScreen">
        <div class="title">THE MAZE</div>
        <div class="subtitle">He's watching. He's waiting. He's hunting.</div>
        <button class="start-btn" onclick="startGame()">ENTER</button>
        <div class="instructions">
            <span>WASD</span> - Move | <span>MOUSE</span> - Look<br>
            <span>SHIFT</span> - Sprint | <span>F</span> - Toggle Flashlight<br>
            <span>Find the green exit before HE finds you</span>
        </div>
    </div>

    <div id="gameOverScreen">
        <div class="game-over-title">DEAD</div>
        <div class="game-over-subtitle">The maniac caught you...</div>
        <button class="start-btn" onclick="restartGame()">TRY AGAIN</button>
    </div>

    <div id="winScreen">
        <div class="win-title">ESCAPED</div>
        <div class="win-subtitle">You made it out alive... this time.</div>
        <button class="start-btn" onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <script>
        // Audio context for horror sounds
        let audioCtx = null;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playHeartbeat(rate = 1) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 60;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.15);
        }

        function playFootstep() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
            }
            const source = audioCtx.createBufferSource();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            source.buffer = buffer;
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = 0.2;
            source.start();
        }

        function playManiacSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 100 + Math.random() * 50;
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.5);
        }

        function playAmbientDrone() {
            if (!audioCtx) return;
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(audioCtx.destination);
            osc1.frequency.value = 40;
            osc2.frequency.value = 42;
            osc1.type = 'sine';
            osc2.type = 'sine';
            gain.gain.value = 0.05;
            osc1.start();
            osc2.start();
            return { osc1, osc2, gain };
        }

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Screen dimensions
        let screenWidth, screenHeight;

        function resizeCanvas() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game settings
        const TILE_SIZE = 64;
        const FOV = Math.PI / 3; // 60 degrees
        const HALF_FOV = FOV / 2;
        const NUM_RAYS = 320;
        const MAX_DEPTH = 800;
        const PLAYER_SPEED = 3;
        const SPRINT_SPEED = 5;
        const ROTATION_SPEED = 0.003;

        // Maze generation
        const MAZE_WIDTH = 21;
        const MAZE_HEIGHT = 21;
        let maze = [];

        // Player
        let player = {
            x: 1.5 * TILE_SIZE,
            y: 1.5 * TILE_SIZE,
            angle: 0,
            stamina: 100,
            maxStamina: 100,
            flashlightOn: true,
            battery: 100,
            isRunning: false
        };

        // Maniac
        let maniac = {
            x: (MAZE_WIDTH - 2) * TILE_SIZE + TILE_SIZE / 2,
            y: (MAZE_HEIGHT - 2) * TILE_SIZE + TILE_SIZE / 2,
            angle: 0,
            speed: 1.8,
            detectionRange: 300,
            chaseSpeed: 2.5,
            isChasing: false,
            lastSeenX: 0,
            lastSeenY: 0,
            pathUpdateTimer: 0
        };

        // Exit position
        let exitX, exitY;

        // Input
        const keys = {};
        let mouseLocked = false;

        // Game state
        let gameRunning = false;
        let gameOver = false;
        let won = false;
        let footstepTimer = 0;
        let heartbeatTimer = 0;
        let ambientDrone = null;

        // Generate maze using recursive backtracking
        function generateMaze() {
            // Initialize maze with walls
            maze = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                maze[y] = [];
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    maze[y][x] = 1; // Wall
                }
            }

            // Recursive backtracking
            const stack = [];
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            stack.push({ x: startX, y: startY });

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                // Check all 4 directions
                const directions = [
                    { dx: 0, dy: -2 }, // Up
                    { dx: 2, dy: 0 },  // Right
                    { dx: 0, dy: 2 },  // Down
                    { dx: -2, dy: 0 }  // Left
                ];

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;

                    if (nx > 0 && nx < MAZE_WIDTH - 1 && ny > 0 && ny < MAZE_HEIGHT - 1 && maze[ny][nx] === 1) {
                        neighbors.push({ x: nx, y: ny, wallX: current.x + dir.dx / 2, wallY: current.y + dir.dy / 2 });
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[next.wallY][next.wallX] = 0; // Remove wall between
                    maze[next.y][next.x] = 0; // Mark as passage
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }

            // Set exit at far corner
            exitX = MAZE_WIDTH - 2;
            exitY = MAZE_HEIGHT - 2;
            maze[exitY][exitX] = 2; // Exit marker

            // Ensure path to exit
            maze[exitY][exitX - 1] = 0;
            maze[exitY - 1][exitX] = 0;
        }

        // Check if position collides with wall
        function isWall(x, y) {
            const mapX = Math.floor(x / TILE_SIZE);
            const mapY = Math.floor(y / TILE_SIZE);
            if (mapX < 0 || mapX >= MAZE_WIDTH || mapY < 0 || mapY >= MAZE_HEIGHT) {
                return true;
            }
            return maze[mapY][mapX] === 1;
        }

        // Check if position is at exit
        function isExit(x, y) {
            const mapX = Math.floor(x / TILE_SIZE);
            const mapY = Math.floor(y / TILE_SIZE);
            return mapX === exitX && mapY === exitY;
        }

        // Cast a single ray
        function castRay(angle) {
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);

            let distance = 0;
            let hitWall = false;
            let wallType = 1;
            let textureX = 0;

            while (!hitWall && distance < MAX_DEPTH) {
                distance += 1;

                const testX = player.x + cos * distance;
                const testY = player.y + sin * distance;

                const mapX = Math.floor(testX / TILE_SIZE);
                const mapY = Math.floor(testY / TILE_SIZE);

                if (mapX < 0 || mapX >= MAZE_WIDTH || mapY < 0 || mapY >= MAZE_HEIGHT) {
                    hitWall = true;
                    distance = MAX_DEPTH;
                } else if (maze[mapY][mapX] >= 1) {
                    hitWall = true;
                    wallType = maze[mapY][mapX];

                    // Calculate texture X coordinate
                    const hitX = testX - mapX * TILE_SIZE;
                    const hitY = testY - mapY * TILE_SIZE;

                    if (Math.abs(hitX) < 1 || Math.abs(hitX - TILE_SIZE) < 1) {
                        textureX = hitY / TILE_SIZE;
                    } else {
                        textureX = hitX / TILE_SIZE;
                    }
                }
            }

            return { distance, wallType, textureX };
        }

        // Render 3D view
        function render3D() {
            // Sky (dark)
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, screenWidth, screenHeight / 2);

            // Floor (darker)
            const gradient = ctx.createLinearGradient(0, screenHeight / 2, 0, screenHeight);
            gradient.addColorStop(0, '#1a1a1a');
            gradient.addColorStop(1, '#050505');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, screenHeight / 2, screenWidth, screenHeight / 2);

            // Cast rays and render walls
            const rayWidth = screenWidth / NUM_RAYS;

            for (let i = 0; i < NUM_RAYS; i++) {
                const rayAngle = player.angle - HALF_FOV + (i / NUM_RAYS) * FOV;
                const ray = castRay(rayAngle);

                // Fix fisheye
                const correctedDist = ray.distance * Math.cos(rayAngle - player.angle);

                // Calculate wall height
                const wallHeight = (TILE_SIZE * screenHeight) / correctedDist;

                // Calculate lighting (flashlight effect)
                let brightness = 0.1; // Base ambient light

                if (player.flashlightOn && player.battery > 0) {
                    const flashlightRange = 400;
                    const flashlightIntensity = Math.max(0, 1 - (correctedDist / flashlightRange));
                    brightness = Math.min(1, 0.1 + flashlightIntensity * 0.9);
                }

                // Wall color based on type and distance
                let r, g, b;
                if (ray.wallType === 2) {
                    // Exit - green glow
                    r = Math.floor(0 * brightness);
                    g = Math.floor(255 * brightness);
                    b = Math.floor(0 * brightness);
                } else {
                    // Normal wall - dark stone texture simulation
                    const shade = (ray.textureX * 0.3 + 0.7);
                    r = Math.floor(40 * brightness * shade);
                    g = Math.floor(35 * brightness * shade);
                    b = Math.floor(45 * brightness * shade);
                }

                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

                const wallTop = (screenHeight - wallHeight) / 2;
                ctx.fillRect(i * rayWidth, wallTop, rayWidth + 1, wallHeight);

                // Add vertical lines for texture
                if (brightness > 0.2) {
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 * brightness})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(i * rayWidth, wallTop);
                    ctx.lineTo(i * rayWidth, wallTop + wallHeight);
                    ctx.stroke();
                }
            }
        }

        // Render maniac (billboard sprite)
        function renderManiac() {
            // Calculate angle to maniac
            const dx = maniac.x - player.x;
            const dy = maniac.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angleToManiac = Math.atan2(dy, dx);

            // Check if maniac is in FOV
            let relativeAngle = angleToManiac - player.angle;
            while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
            while (relativeAngle < -Math.PI) relativeAngle += 2 * Math.PI;

            if (Math.abs(relativeAngle) < HALF_FOV + 0.2) {
                // Check if there's a wall between player and maniac
                const rayToManiac = castRay(angleToManiac);
                if (rayToManiac.distance > distance - TILE_SIZE / 2) {
                    // Maniac is visible
                    const screenX = screenWidth / 2 + (relativeAngle / HALF_FOV) * (screenWidth / 2);

                    // Calculate maniac size based on distance
                    const maniacHeight = (TILE_SIZE * 1.8 * screenHeight) / distance;
                    const maniacWidth = maniacHeight * 0.5;

                    // Lighting
                    let brightness = 0.2;
                    if (player.flashlightOn && player.battery > 0) {
                        const flashlightRange = 400;
                        brightness = Math.min(1, 0.2 + (1 - distance / flashlightRange) * 0.8);
                    }

                    // Draw maniac silhouette
                    const x = screenX - maniacWidth / 2;
                    const y = screenHeight / 2 - maniacHeight / 2;

                    // Body
                    ctx.fillStyle = `rgba(${Math.floor(30 * brightness)}, ${Math.floor(10 * brightness)}, ${Math.floor(10 * brightness)}, 1)`;
                    ctx.fillRect(x + maniacWidth * 0.2, y + maniacHeight * 0.25, maniacWidth * 0.6, maniacHeight * 0.75);

                    // Head
                    ctx.beginPath();
                    ctx.arc(screenX, y + maniacHeight * 0.15, maniacWidth * 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Glowing eyes
                    if (brightness > 0.1) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${brightness})`;
                        ctx.beginPath();
                        ctx.arc(screenX - maniacWidth * 0.1, y + maniacHeight * 0.12, maniacWidth * 0.05, 0, Math.PI * 2);
                        ctx.arc(screenX + maniacWidth * 0.1, y + maniacHeight * 0.12, maniacWidth * 0.05, 0, Math.PI * 2);
                        ctx.fill();

                        // Eye glow
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff0000';
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }

                    // Arms (holding weapon)
                    ctx.fillStyle = `rgba(${Math.floor(40 * brightness)}, ${Math.floor(20 * brightness)}, ${Math.floor(20 * brightness)}, 1)`;
                    ctx.fillRect(x, y + maniacHeight * 0.3, maniacWidth * 0.25, maniacHeight * 0.4);
                    ctx.fillRect(x + maniacWidth * 0.75, y + maniacHeight * 0.3, maniacWidth * 0.25, maniacHeight * 0.4);
                }
            }
        }

        // Simple pathfinding for maniac
        function updateManiac(deltaTime) {
            const dx = player.x - maniac.x;
            const dy = player.y - maniac.y;
            const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);

            // Update blood vignette based on distance
            const bloodVignette = document.getElementById('bloodVignette');
            const dangerLevel = Math.max(0, 1 - distanceToPlayer / 300);
            bloodVignette.style.opacity = dangerLevel * 0.8;

            // Distance indicator
            const distanceIndicator = document.getElementById('distanceIndicator');
            if (distanceToPlayer < 200) {
                distanceIndicator.style.opacity = 1;
                distanceIndicator.textContent = distanceToPlayer < 100 ? "HE'S RIGHT BEHIND YOU!" : "HE'S CLOSE...";
            } else {
                distanceIndicator.style.opacity = 0;
            }

            // Check if player is in line of sight
            const angleToPlayer = Math.atan2(dy, dx);
            const rayToPlayer = castRayFrom(maniac.x, maniac.y, angleToPlayer);

            if (rayToPlayer.distance > distanceToPlayer || distanceToPlayer < maniac.detectionRange) {
                // Can see player or player is very close
                maniac.isChasing = true;
                maniac.lastSeenX = player.x;
                maniac.lastSeenY = player.y;
            }

            let targetX, targetY;
            let speed = maniac.speed;

            if (maniac.isChasing) {
                targetX = maniac.lastSeenX;
                targetY = maniac.lastSeenY;
                speed = maniac.chaseSpeed;

                // Check if reached last seen position
                const distToTarget = Math.sqrt((targetX - maniac.x) ** 2 + (targetY - maniac.y) ** 2);
                if (distToTarget < TILE_SIZE / 2) {
                    maniac.isChasing = false;
                }
            } else {
                // Patrol randomly
                maniac.pathUpdateTimer += deltaTime;
                if (maniac.pathUpdateTimer > 2000) {
                    maniac.pathUpdateTimer = 0;
                    // Find random valid position nearby
                    const angle = Math.random() * Math.PI * 2;
                    targetX = maniac.x + Math.cos(angle) * TILE_SIZE * 3;
                    targetY = maniac.y + Math.sin(angle) * TILE_SIZE * 3;
                }
                targetX = targetX || maniac.x;
                targetY = targetY || maniac.y;
            }

            // Move towards target
            const moveAngle = Math.atan2(targetY - maniac.y, targetX - maniac.x);
            const moveX = Math.cos(moveAngle) * speed;
            const moveY = Math.sin(moveAngle) * speed;

            // Check collision
            const newX = maniac.x + moveX;
            const newY = maniac.y + moveY;

            if (!isWall(newX, maniac.y)) {
                maniac.x = newX;
            }
            if (!isWall(maniac.x, newY)) {
                maniac.y = newY;
            }

            maniac.angle = moveAngle;

            // Check if caught player
            if (distanceToPlayer < 30) {
                gameOver = true;
                document.getElementById('gameOverScreen').style.display = 'flex';
                gameRunning = false;
            }

            // Play maniac sounds occasionally
            if (maniac.isChasing && Math.random() < 0.01) {
                playManiacSound();
            }
        }

        // Cast ray from any position
        function castRayFrom(startX, startY, angle) {
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);

            let distance = 0;
            let hitWall = false;

            while (!hitWall && distance < MAX_DEPTH) {
                distance += 2;

                const testX = startX + cos * distance;
                const testY = startY + sin * distance;

                const mapX = Math.floor(testX / TILE_SIZE);
                const mapY = Math.floor(testY / TILE_SIZE);

                if (mapX < 0 || mapX >= MAZE_WIDTH || mapY < 0 || mapY >= MAZE_HEIGHT) {
                    hitWall = true;
                } else if (maze[mapY][mapX] === 1) {
                    hitWall = true;
                }
            }

            return { distance };
        }

        // Update player
        function updatePlayer(deltaTime) {
            const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
            let speed = isRunning && player.stamina > 0 ? SPRINT_SPEED : PLAYER_SPEED;

            // Stamina management
            if (isRunning && (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'])) {
                player.stamina = Math.max(0, player.stamina - deltaTime * 0.03);
                player.isRunning = true;
            } else {
                player.stamina = Math.min(player.maxStamina, player.stamina + deltaTime * 0.015);
                player.isRunning = false;
            }

            // Battery drain
            if (player.flashlightOn) {
                player.battery = Math.max(0, player.battery - deltaTime * 0.005);
            }

            // Movement
            let moveX = 0;
            let moveY = 0;

            if (keys['KeyW']) {
                moveX += Math.cos(player.angle) * speed;
                moveY += Math.sin(player.angle) * speed;
            }
            if (keys['KeyS']) {
                moveX -= Math.cos(player.angle) * speed;
                moveY -= Math.sin(player.angle) * speed;
            }
            if (keys['KeyA']) {
                moveX += Math.cos(player.angle - Math.PI / 2) * speed;
                moveY += Math.sin(player.angle - Math.PI / 2) * speed;
            }
            if (keys['KeyD']) {
                moveX += Math.cos(player.angle + Math.PI / 2) * speed;
                moveY += Math.sin(player.angle + Math.PI / 2) * speed;
            }

            // Collision detection
            const margin = 10;
            if (!isWall(player.x + moveX + margin, player.y) && !isWall(player.x + moveX - margin, player.y)) {
                player.x += moveX;
            }
            if (!isWall(player.x, player.y + moveY + margin) && !isWall(player.x, player.y + moveY - margin)) {
                player.y += moveY;
            }

            // Check exit
            if (isExit(player.x, player.y)) {
                won = true;
                document.getElementById('winScreen').style.display = 'flex';
                gameRunning = false;
            }

            // Footstep sounds
            if ((keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'])) {
                footstepTimer += deltaTime;
                const footstepInterval = isRunning ? 250 : 400;
                if (footstepTimer > footstepInterval) {
                    footstepTimer = 0;
                    playFootstep();
                }
            }
        }

        // Render minimap
        function renderMinimap() {
            const cellSize = 7;
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 150, 150);

            const playerMapX = Math.floor(player.x / TILE_SIZE);
            const playerMapY = Math.floor(player.y / TILE_SIZE);
            const viewRadius = 5;

            for (let dy = -viewRadius; dy <= viewRadius; dy++) {
                for (let dx = -viewRadius; dx <= viewRadius; dx++) {
                    const mapX = playerMapX + dx;
                    const mapY = playerMapY + dy;

                    if (mapX >= 0 && mapX < MAZE_WIDTH && mapY >= 0 && mapY < MAZE_HEIGHT) {
                        const screenX = 75 + dx * cellSize;
                        const screenY = 75 + dy * cellSize;

                        if (maze[mapY][mapX] === 1) {
                            minimapCtx.fillStyle = '#333';
                        } else if (maze[mapY][mapX] === 2) {
                            minimapCtx.fillStyle = '#00ff00';
                        } else {
                            minimapCtx.fillStyle = '#111';
                        }

                        minimapCtx.fillRect(screenX, screenY, cellSize, cellSize);
                    }
                }
            }

            // Draw player
            minimapCtx.fillStyle = '#00ffff';
            minimapCtx.beginPath();
            minimapCtx.arc(75, 75, 3, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw player direction
            minimapCtx.strokeStyle = '#00ffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(75, 75);
            minimapCtx.lineTo(75 + Math.cos(player.angle) * 10, 75 + Math.sin(player.angle) * 10);
            minimapCtx.stroke();

            // Draw maniac if close
            const maniacMapX = Math.floor(maniac.x / TILE_SIZE);
            const maniacMapY = Math.floor(maniac.y / TILE_SIZE);
            const maniacDx = maniacMapX - playerMapX;
            const maniacDy = maniacMapY - playerMapY;

            if (Math.abs(maniacDx) <= viewRadius && Math.abs(maniacDy) <= viewRadius) {
                minimapCtx.fillStyle = '#ff0000';
                minimapCtx.beginPath();
                minimapCtx.arc(75 + maniacDx * cellSize, 75 + maniacDy * cellSize, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }
        }

        // Update HUD
        function updateHUD() {
            // Battery
            const batteryBar = document.getElementById('batteryBar');
            batteryBar.style.width = player.battery + '%';
            if (player.battery < 20) {
                batteryBar.classList.add('low');
            } else {
                batteryBar.classList.remove('low');
            }

            // Stamina
            const staminaBar = document.getElementById('staminaBar');
            staminaBar.style.width = player.stamina + '%';

            // Heartbeat effect when maniac is close
            const dx = maniac.x - player.x;
            const dy = maniac.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 300) {
                heartbeatTimer += 16;
                const heartbeatRate = Math.max(200, 600 - (300 - distance) * 2);

                if (heartbeatTimer > heartbeatRate) {
                    heartbeatTimer = 0;
                    playHeartbeat();

                    const heartbeat = document.getElementById('heartbeat');
                    heartbeat.style.opacity = 1;
                    setTimeout(() => heartbeat.style.opacity = 0, 100);
                }
            }
        }

        // Main game loop
        let lastTime = 0;

        function gameLoop(currentTime) {
            if (!gameRunning) return;

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            updatePlayer(deltaTime);
            updateManiac(deltaTime);

            render3D();
            renderManiac();
            renderMinimap();
            updateHUD();

            requestAnimationFrame(gameLoop);
        }

        // Input handlers
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'KeyF' && gameRunning) {
                player.flashlightOn = !player.flashlightOn;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (mouseLocked && gameRunning) {
                player.angle += e.movementX * ROTATION_SPEED;
            }
        });

        document.addEventListener('click', () => {
            if (gameRunning && !mouseLocked) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
        });

        // Start game
        function startGame() {
            initAudio();
            document.getElementById('startScreen').style.display = 'none';

            generateMaze();

            // Reset player
            player.x = 1.5 * TILE_SIZE;
            player.y = 1.5 * TILE_SIZE;
            player.angle = 0;
            player.stamina = 100;
            player.battery = 100;
            player.flashlightOn = true;

            // Reset maniac
            maniac.x = (MAZE_WIDTH - 2) * TILE_SIZE + TILE_SIZE / 2;
            maniac.y = (MAZE_HEIGHT - 4) * TILE_SIZE + TILE_SIZE / 2;
            maniac.isChasing = false;

            gameRunning = true;
            gameOver = false;
            won = false;
            lastTime = performance.now();

            // Start ambient drone
            ambientDrone = playAmbientDrone();

            canvas.requestPointerLock();
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('bloodVignette').style.opacity = 0;
            startGame();
        }

        // Breathing effect
        function breathingEffect() {
            if (!gameRunning) return;

            const overlay = document.getElementById('breathingOverlay');
            const dx = maniac.x - player.x;
            const dy = maniac.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 200 || player.stamina < 20) {
                const intensity = Math.max((200 - distance) / 200, (20 - player.stamina) / 20);
                overlay.style.background = `rgba(0, 0, 0, ${0.1 + Math.sin(Date.now() / 200) * 0.05 * intensity})`;
            } else {
                overlay.style.background = 'rgba(0, 0, 0, 0)';
            }

            requestAnimationFrame(breathingEffect);
        }

        breathingEffect();
    </script>
</body>
</html>
