<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE MAZE - First Person Horror</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .crosshair {
            position: fixed;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }
        .crosshair::before { width: 16px; height: 2px; left: -8px; top: -1px; }
        .crosshair::after { width: 2px; height: 16px; left: -1px; top: -8px; }

        .vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            z-index: 50;
        }

        .blood-vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 20%, rgba(139,0,0,0.6) 100%);
            opacity: 0;
            z-index: 51;
            transition: opacity 0.3s;
        }

        .hud-bar-container {
            position: absolute;
            bottom: 30px;
            background: rgba(0,0,0,0.7);
            padding: 12px 16px;
            border: 1px solid #555;
            min-width: 180px;
        }
        .hud-bar-container.left { left: 30px; }
        .hud-bar-container.right { right: 30px; }

        .hud-label {
            color: #999;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .hud-bar-bg {
            background: #333;
            height: 16px;
            border: 1px solid #555;
        }

        .hud-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }
        #batteryBar { background: linear-gradient(90deg, #cc4400, #ffcc00, #44cc00); }
        #batteryBar.low { background: #ff0000; animation: barPulse 0.5s infinite; }
        #staminaBar { background: linear-gradient(90deg, #0066cc, #00ccff); }

        @keyframes barPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

        .objective {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            padding: 12px 28px;
            border: 2px solid #cc0000;
            text-align: center;
            box-shadow: 0 0 20px rgba(200,0,0,0.3);
        }
        .objective-text {
            color: #ff4444;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: objPulse 2s infinite;
        }
        @keyframes objPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }

        .distance-indicator {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 15px #ff0000;
        }

        .heartbeat-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: #ff0000;
            opacity: 0;
            text-shadow: 0 0 20px #ff0000;
        }

        /* Overlay screens */
        .overlay-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .overlay-screen.hidden { display: none; }

        #startScreen {
            background: linear-gradient(180deg, #000 0%, #1a0000 50%, #000 100%);
        }

        .title {
            font-size: 80px;
            color: #ff0000;
            text-shadow: 0 0 40px #ff0000, 0 0 80px #990000;
            margin-bottom: 15px;
            letter-spacing: 20px;
            animation: titleFlicker 4s infinite;
        }
        @keyframes titleFlicker {
            0%,91%,94%,97%,100% { opacity: 1; }
            92% { opacity: 0.2; }
            93% { opacity: 0.8; }
            95% { opacity: 0.3; }
            96% { opacity: 0.9; }
        }

        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 50px;
            letter-spacing: 4px;
        }

        .game-btn {
            background: transparent;
            border: 2px solid #cc0000;
            color: #cc0000;
            padding: 18px 55px;
            font-size: 22px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            letter-spacing: 4px;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        .game-btn:hover {
            background: #cc0000;
            color: #000;
            box-shadow: 0 0 40px rgba(200,0,0,0.6);
        }

        .instructions {
            margin-top: 40px;
            color: #555;
            text-align: center;
            line-height: 2;
            font-size: 14px;
        }
        .instructions span { color: #999; }

        #loadingScreen { background: #000; z-index: 999; }
        .loading-text { color: #cc0000; font-size: 22px; letter-spacing: 4px; }

        #gameOverScreen, #winScreen { background: rgba(0,0,0,0.95); z-index: 2000; }

        .end-title {
            font-size: 90px;
            margin-bottom: 25px;
        }
        .end-title.dead {
            color: #ff0000;
            text-shadow: 0 0 40px #ff0000;
            animation: shakeTitle 0.1s infinite;
        }
        .end-title.escaped {
            color: #00ff00;
            text-shadow: 0 0 40px #00ff00;
        }
        @keyframes shakeTitle {
            0%,100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }

        .end-subtitle {
            font-size: 20px;
            margin-bottom: 40px;
        }
        .end-subtitle.dead { color: #880000; }
        .end-subtitle.escaped { color: #008800; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <div class="crosshair" id="crosshair" style="display:none;"></div>
    <div class="vignette" id="vignette" style="display:none;"></div>
    <div class="blood-vignette" id="bloodVignette"></div>

    <div id="hud">
        <div class="hud-bar-container left">
            <div class="hud-label">Flashlight</div>
            <div class="hud-bar-bg"><div class="hud-bar-fill" id="batteryBar" style="width:100%"></div></div>
        </div>
        <div class="hud-bar-container right">
            <div class="hud-label">Stamina</div>
            <div class="hud-bar-bg"><div class="hud-bar-fill" id="staminaBar" style="width:100%"></div></div>
        </div>
        <div class="objective"><div class="objective-text">FIND THE EXIT</div></div>
        <div class="distance-indicator" id="distanceIndicator">HE'S CLOSE...</div>
        <div class="heartbeat-indicator" id="heartbeat">&#x2764;</div>
    </div>

    <div id="startScreen" class="overlay-screen">
        <div class="title">THE MAZE</div>
        <div class="subtitle">He's watching. He's waiting. He's hunting.</div>
        <button class="game-btn" id="startBtn">ENTER</button>
        <div class="instructions">
            <span>WASD</span> - Move &nbsp;|&nbsp; <span>MOUSE</span> - Look<br>
            <span>SHIFT</span> - Sprint &nbsp;|&nbsp; <span>F</span> - Toggle Flashlight<br>
            <span>Find the green exit before HE finds you</span>
        </div>
    </div>

    <div id="loadingScreen" class="overlay-screen hidden">
        <div class="loading-text">ENTERING THE MAZE...</div>
    </div>

    <div id="gameOverScreen" class="overlay-screen hidden">
        <div class="end-title dead">DEAD</div>
        <div class="end-subtitle dead">The maniac caught you...</div>
        <button class="game-btn" id="restartBtn">TRY AGAIN</button>
    </div>

    <div id="winScreen" class="overlay-screen hidden">
        <div class="end-title escaped">ESCAPED</div>
        <div class="end-subtitle escaped">You made it out alive... this time.</div>
        <button class="game-btn" id="playAgainBtn">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // ─── Audio ───
        let audioCtx = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playHeartbeat() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 55;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.25);
        }

        function playFootstep() {
            if (!audioCtx) return;
            const len = Math.floor(audioCtx.sampleRate * 0.07);
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < len; i++) {
                d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (len * 0.04));
            }
            const src = audioCtx.createBufferSource();
            const gain = audioCtx.createGain();
            const filt = audioCtx.createBiquadFilter();
            src.buffer = buf;
            filt.type = 'lowpass';
            filt.frequency.value = 200;
            src.connect(filt);
            filt.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.value = 0.25;
            src.start();
        }

        function playBreathing() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 70 + Math.random() * 50;
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.6);
        }

        // ─── Constants ───
        const MAZE_W = 21;
        const MAZE_H = 21;
        const CELL = 3;
        const WALL_H = 3.5;
        const EYE_HEIGHT = 1.6;
        const WALK_SPEED = 5;
        const RUN_SPEED = 9;

        // ─── State ───
        let scene, camera, renderer, clock;
        let flashlight, flashlightTarget;
        let exitLight, exitMarkerMat;
        let maniacGroup;
        let maze = [];
        let wallMeshes = [];
        let gameRunning = false;
        let isLocked = false;
        let yaw = 0, pitch = 0;
        const keys = {};

        const player = {
            stamina: 100,
            battery: 100,
            flashlightOn: true
        };

        const maniac = {
            pos: new THREE.Vector3(),
            chasing: false,
            speed: 2.5,
            chaseSpeed: 4.5,
            lastSeen: new THREE.Vector3(),
            patrolTarget: null
        };

        let exitPos = new THREE.Vector3();
        let footstepTimer = 0;
        let heartbeatTimer = 0;
        let breathTimer = 0;

        // ─── DOM refs ───
        const $container = document.getElementById('gameContainer');
        const $hud = document.getElementById('hud');
        const $crosshair = document.getElementById('crosshair');
        const $vignette = document.getElementById('vignette');
        const $blood = document.getElementById('bloodVignette');
        const $battery = document.getElementById('batteryBar');
        const $stamina = document.getElementById('staminaBar');
        const $dist = document.getElementById('distanceIndicator');
        const $heart = document.getElementById('heartbeat');
        const $start = document.getElementById('startScreen');
        const $loading = document.getElementById('loadingScreen');
        const $gameOver = document.getElementById('gameOverScreen');
        const $win = document.getElementById('winScreen');

        // ─── Maze generation (recursive backtracking) ───
        function generateMaze() {
            maze = [];
            for (let r = 0; r < MAZE_H; r++) {
                maze[r] = [];
                for (let c = 0; c < MAZE_W; c++) {
                    maze[r][c] = 1;
                }
            }

            function carve(cx, cy) {
                maze[cy][cx] = 0;
                const dirs = [
                    { dx: 0, dy: -2 },
                    { dx: 2, dy: 0 },
                    { dx: 0, dy: 2 },
                    { dx: -2, dy: 0 }
                ];
                // shuffle
                for (let i = dirs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                }
                for (const d of dirs) {
                    const nx = cx + d.dx;
                    const ny = cy + d.dy;
                    if (nx > 0 && nx < MAZE_W - 1 && ny > 0 && ny < MAZE_H - 1 && maze[ny][nx] === 1) {
                        maze[cy + d.dy / 2][cx + d.dx / 2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);

            // Ensure exit area is open
            maze[MAZE_H - 2][MAZE_W - 2] = 0;
            maze[MAZE_H - 2][MAZE_W - 3] = 0;
            maze[MAZE_H - 3][MAZE_W - 2] = 0;
        }

        // ─── Textures ───
        function makeWallTexture() {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const g = c.getContext('2d');
            g.fillStyle = '#3a3535';
            g.fillRect(0, 0, 128, 128);
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 4; col++) {
                    const ox = (row % 2) * 16;
                    const r = 45 + Math.floor(Math.random() * 20);
                    const gv = 38 + Math.floor(Math.random() * 18);
                    const b = 35 + Math.floor(Math.random() * 15);
                    g.fillStyle = `rgb(${r},${gv},${b})`;
                    g.fillRect(col * 32 + ox + 1, row * 16 + 1, 30, 14);
                }
            }
            // mortar lines
            g.strokeStyle = '#222';
            g.lineWidth = 1;
            for (let row = 0; row <= 8; row++) {
                g.beginPath();
                g.moveTo(0, row * 16);
                g.lineTo(128, row * 16);
                g.stroke();
            }
            const tex = new THREE.CanvasTexture(c);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function makeFloorTexture() {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const g = c.getContext('2d');
            g.fillStyle = '#2a2520';
            g.fillRect(0, 0, 128, 128);
            for (let i = 0; i < 60; i++) {
                const v = 25 + Math.floor(Math.random() * 25);
                g.fillStyle = `rgba(${v}, ${v - 5}, ${v - 10}, 0.4)`;
                g.beginPath();
                g.arc(Math.random() * 128, Math.random() * 128, 2 + Math.random() * 8, 0, Math.PI * 2);
                g.fill();
            }
            const tex = new THREE.CanvasTexture(c);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(MAZE_W, MAZE_H);
            return tex;
        }

        // ─── Build scene ───
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 2, 30);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            $container.innerHTML = '';
            $container.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Ambient — dim but non-zero so geometry is faintly visible
            const ambient = new THREE.AmbientLight(0x444455, 0.35);
            scene.add(ambient);

            // Subtle hemisphere light for depth
            const hemi = new THREE.HemisphereLight(0x222233, 0x111100, 0.2);
            scene.add(hemi);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function buildMaze() {
            // Clear old walls
            for (const w of wallMeshes) {
                scene.remove(w);
                w.geometry.dispose();
            }
            wallMeshes = [];

            const wallTex = makeWallTexture();
            const wallMat = new THREE.MeshStandardMaterial({
                map: wallTex,
                roughness: 0.85,
                metalness: 0.05
            });

            const wallGeo = new THREE.BoxGeometry(CELL, WALL_H, CELL);

            for (let r = 0; r < MAZE_H; r++) {
                for (let c = 0; c < MAZE_W; c++) {
                    if (maze[r][c] === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set(
                            c * CELL + CELL / 2,
                            WALL_H / 2,
                            r * CELL + CELL / 2
                        );
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        wallMeshes.push(wall);
                    }
                }
            }

            // Floor
            const floorGeo = new THREE.PlaneGeometry(MAZE_W * CELL, MAZE_H * CELL);
            const floorMat = new THREE.MeshStandardMaterial({
                map: makeFloorTexture(),
                roughness: 0.9,
                metalness: 0.05
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(MAZE_W * CELL / 2, 0, MAZE_H * CELL / 2);
            floor.receiveShadow = true;
            scene.add(floor);
            wallMeshes.push(floor);

            // Ceiling
            const ceilGeo = new THREE.PlaneGeometry(MAZE_W * CELL, MAZE_H * CELL);
            const ceilMat = new THREE.MeshStandardMaterial({
                color: 0x1a1816,
                roughness: 1,
                metalness: 0
            });
            const ceil = new THREE.Mesh(ceilGeo, ceilMat);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.set(MAZE_W * CELL / 2, WALL_H, MAZE_H * CELL / 2);
            ceil.receiveShadow = true;
            scene.add(ceil);
            wallMeshes.push(ceil);
        }

        function buildExit() {
            const ex = MAZE_W - 2;
            const ey = MAZE_H - 2;
            exitPos.set(ex * CELL + CELL / 2, 0, ey * CELL + CELL / 2);

            // Green point light
            exitLight = new THREE.PointLight(0x00ff44, 8, 18);
            exitLight.position.set(exitPos.x, 2, exitPos.z);
            scene.add(exitLight);

            // Glowing floor marker
            const geo = new THREE.PlaneGeometry(CELL * 0.7, CELL * 0.7);
            exitMarkerMat = new THREE.MeshStandardMaterial({
                color: 0x00ff44,
                emissive: 0x00ff44,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.85
            });
            const marker = new THREE.Mesh(geo, exitMarkerMat);
            marker.rotation.x = -Math.PI / 2;
            marker.position.set(exitPos.x, 0.02, exitPos.z);
            scene.add(marker);
        }

        function buildManiac() {
            maniacGroup = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });

            // Body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.28, 0.38, 1.4, 8),
                bodyMat
            );
            body.position.y = 0.7;
            body.castShadow = true;
            maniacGroup.add(body);

            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.22, 12, 12),
                new THREE.MeshStandardMaterial({ color: 0x3a2828, roughness: 0.8 })
            );
            head.position.y = 1.65;
            head.castShadow = true;
            maniacGroup.add(head);

            // Eyes — glowing red
            const eyeMat = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 3
            });
            const eyeGeo = new THREE.SphereGeometry(0.04, 6, 6);

            const lEye = new THREE.Mesh(eyeGeo, eyeMat);
            lEye.position.set(-0.08, 1.67, 0.18);
            maniacGroup.add(lEye);

            const rEye = new THREE.Mesh(eyeGeo, eyeMat);
            rEye.position.set(0.08, 1.67, 0.18);
            maniacGroup.add(rEye);

            // Eye glow light
            const eyeLight = new THREE.PointLight(0xff0000, 1.5, 8);
            eyeLight.position.set(0, 1.67, 0.25);
            maniacGroup.add(eyeLight);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.07, 0.09, 0.7, 6);
            const lArm = new THREE.Mesh(armGeo, bodyMat);
            lArm.position.set(-0.4, 0.95, 0);
            lArm.rotation.z = 0.3;
            lArm.castShadow = true;
            maniacGroup.add(lArm);

            const rArm = new THREE.Mesh(armGeo, bodyMat);
            rArm.position.set(0.4, 0.95, 0);
            rArm.rotation.z = -0.3;
            rArm.castShadow = true;
            maniacGroup.add(rArm);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.09, 0.11, 0.7, 6);
            const lLeg = new THREE.Mesh(legGeo, bodyMat);
            lLeg.position.set(-0.14, 0.18, 0);
            lLeg.castShadow = true;
            maniacGroup.add(lLeg);

            const rLeg = new THREE.Mesh(legGeo, bodyMat);
            rLeg.position.set(0.14, 0.18, 0);
            rLeg.castShadow = true;
            maniacGroup.add(rLeg);

            scene.add(maniacGroup);
        }

        function buildFlashlight() {
            // Remove old if any
            if (flashlight) {
                camera.remove(flashlight);
                scene.remove(camera);
            }
            if (flashlightTarget) {
                scene.remove(flashlightTarget);
            }

            flashlight = new THREE.SpotLight(0xfff5e0, 50, 35, Math.PI / 5.5, 0.35, 1.5);
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            flashlight.shadow.camera.near = 0.5;
            flashlight.shadow.camera.far = 35;

            flashlightTarget = new THREE.Object3D();
            scene.add(flashlightTarget);
            flashlight.target = flashlightTarget;

            flashlight.position.set(0.15, -0.1, -0.2);
            camera.add(flashlight);
            scene.add(camera);
        }

        // ─── Collision ───
        function isWall(worldX, worldZ) {
            const c = Math.floor(worldX / CELL);
            const r = Math.floor(worldZ / CELL);
            if (c < 0 || c >= MAZE_W || r < 0 || r >= MAZE_H) return true;
            return maze[r][c] === 1;
        }

        function checkCollision(x, z, radius) {
            const mc = Math.floor(x / CELL);
            const mr = Math.floor(z / CELL);
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const cc = mc + dc;
                    const cr = mr + dr;
                    if (cc < 0 || cc >= MAZE_W || cr < 0 || cr >= MAZE_H) continue;
                    if (maze[cr][cc] !== 1) continue;
                    // AABB collision
                    const wx = cc * CELL + CELL / 2;
                    const wz = cr * CELL + CELL / 2;
                    const nearX = Math.max(wx - CELL / 2, Math.min(x, wx + CELL / 2));
                    const nearZ = Math.max(wz - CELL / 2, Math.min(z, wz + CELL / 2));
                    const dx = x - nearX;
                    const dz = z - nearZ;
                    if (dx * dx + dz * dz < radius * radius) return true;
                }
            }
            return false;
        }

        function hasLineOfSight(ax, az, bx, bz) {
            const dx = bx - ax;
            const dz = bz - az;
            const dist = Math.sqrt(dx * dx + dz * dz);
            const steps = Math.ceil(dist / 0.5);
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                if (isWall(ax + dx * t, az + dz * t)) return false;
            }
            return true;
        }

        // ─── Input ───
        function setupInput() {
            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyF' && gameRunning) {
                    player.flashlightOn = !player.flashlightOn;
                    flashlight.visible = player.flashlightOn;
                }
            });
            document.addEventListener('keyup', e => { keys[e.code] = false; });

            document.addEventListener('mousemove', e => {
                if (!isLocked || !gameRunning) return;
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-1.4, Math.min(1.4, pitch));
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('click', () => {
                if (gameRunning && !isLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
        }

        // ─── Player update ───
        function updatePlayer(dt) {
            const shifting = (keys['ShiftLeft'] || keys['ShiftRight']) && player.stamina > 0;
            const moving = keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'];
            const speed = shifting && moving ? RUN_SPEED : WALK_SPEED;

            // Stamina
            if (shifting && moving) {
                player.stamina = Math.max(0, player.stamina - dt * 20);
            } else {
                player.stamina = Math.min(100, player.stamina + dt * 12);
            }

            // Battery
            if (player.flashlightOn) {
                player.battery = Math.max(0, player.battery - dt * 1.5);
                if (player.battery <= 0) {
                    player.flashlightOn = false;
                    flashlight.visible = false;
                }
            }
            flashlight.intensity = 50 * (player.battery / 100);

            // Camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;

            // Flashlight target
            const fwd = new THREE.Vector3(0, 0, -10);
            fwd.applyQuaternion(camera.quaternion);
            fwd.add(camera.position);
            flashlightTarget.position.copy(fwd);

            // Movement
            if (moving) {
                const dir = new THREE.Vector3();
                if (keys['KeyW']) dir.z -= 1;
                if (keys['KeyS']) dir.z += 1;
                if (keys['KeyA']) dir.x -= 1;
                if (keys['KeyD']) dir.x += 1;
                dir.normalize();
                dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                const nx = camera.position.x + dir.x * speed * dt;
                const nz = camera.position.z + dir.z * speed * dt;

                if (!checkCollision(nx, camera.position.z, 0.3)) {
                    camera.position.x = nx;
                }
                if (!checkCollision(camera.position.x, nz, 0.3)) {
                    camera.position.z = nz;
                }

                // Footsteps
                footstepTimer += dt;
                const interval = shifting ? 0.28 : 0.42;
                if (footstepTimer >= interval) {
                    footstepTimer = 0;
                    playFootstep();
                }

                // Head bob
                const bobSpd = shifting ? 11 : 7;
                const bobAmt = shifting ? 0.06 : 0.03;
                camera.position.y = EYE_HEIGHT + Math.sin(Date.now() * 0.001 * bobSpd) * bobAmt;
            } else {
                camera.position.y = EYE_HEIGHT;
            }

            // Exit check (2D distance)
            const dxE = camera.position.x - exitPos.x;
            const dzE = camera.position.z - exitPos.z;
            if (Math.sqrt(dxE * dxE + dzE * dzE) < 2) {
                winGame();
            }
        }

        // ─── Maniac AI ───
        function updateManiac(dt) {
            const px = camera.position.x;
            const pz = camera.position.z;
            const mx = maniac.pos.x;
            const mz = maniac.pos.z;
            const dist = Math.sqrt((px - mx) * (px - mx) + (pz - mz) * (pz - mz));

            // Detection
            const canSee = dist < 20 && hasLineOfSight(mx, mz, px, pz);
            if (canSee || dist < 6) {
                maniac.chasing = true;
                maniac.lastSeen.set(px, 0, pz);
            }

            // Blood vignette
            const danger = Math.max(0, 1 - dist / 15);
            $blood.style.opacity = danger * 0.7;

            // Distance indicator
            if (dist < 12) {
                $dist.style.opacity = '1';
                $dist.textContent = dist < 5 ? "HE'S RIGHT BEHIND YOU!" : "HE'S CLOSE...";
            } else {
                $dist.style.opacity = '0';
            }

            // Pick target
            let tx, tz, spd;
            if (maniac.chasing) {
                tx = maniac.lastSeen.x;
                tz = maniac.lastSeen.z;
                spd = maniac.chaseSpeed;
                const dToTarget = Math.sqrt((mx - tx) * (mx - tx) + (mz - tz) * (mz - tz));
                if (dToTarget < 0.5) maniac.chasing = false;
            } else {
                // Patrol
                if (!maniac.patrolTarget) pickPatrolTarget();
                const pt = maniac.patrolTarget;
                if (pt) {
                    tx = pt.x; tz = pt.z;
                    const dPt = Math.sqrt((mx - tx) * (mx - tx) + (mz - tz) * (mz - tz));
                    if (dPt < 0.5) pickPatrolTarget();
                } else {
                    tx = mx; tz = mz;
                }
                spd = maniac.speed;
            }

            // Move
            const ddx = tx - mx;
            const ddz = tz - mz;
            const dd = Math.sqrt(ddx * ddx + ddz * ddz);
            if (dd > 0.1) {
                const nx2 = ddx / dd;
                const nz2 = ddz / dd;
                const moveX = mx + nx2 * spd * dt;
                const moveZ = mz + nz2 * spd * dt;
                if (!checkCollision(moveX, mz, 0.35)) maniac.pos.x = moveX;
                if (!checkCollision(maniac.pos.x, moveZ, 0.35)) maniac.pos.z = moveZ;
                maniacGroup.rotation.y = Math.atan2(nx2, nz2);
            }

            maniacGroup.position.set(maniac.pos.x, 0, maniac.pos.z);

            // Breathing sounds when chasing
            if (maniac.chasing) {
                breathTimer += dt;
                if (breathTimer > 1.5) {
                    breathTimer = 0;
                    playBreathing();
                }
            }

            // Caught check
            if (dist < 1.0) {
                loseGame();
            }

            // Heartbeat when close
            if (dist < 15) {
                heartbeatTimer += dt;
                const hbInterval = Math.max(0.3, dist / 15);
                if (heartbeatTimer >= hbInterval) {
                    heartbeatTimer = 0;
                    playHeartbeat();
                    $heart.style.opacity = '1';
                    setTimeout(() => { $heart.style.opacity = '0'; }, 120);
                }
            }
        }

        function pickPatrolTarget() {
            for (let i = 0; i < 15; i++) {
                const ang = Math.random() * Math.PI * 2;
                const d = CELL * (2 + Math.random() * 3);
                const tx = maniac.pos.x + Math.cos(ang) * d;
                const tz = maniac.pos.z + Math.sin(ang) * d;
                if (!checkCollision(tx, tz, 0.4)) {
                    maniac.patrolTarget = { x: tx, z: tz };
                    return;
                }
            }
        }

        // ─── HUD ───
        function updateHUD() {
            $battery.style.width = player.battery + '%';
            $stamina.style.width = player.stamina + '%';
            if (player.battery < 20) {
                $battery.classList.add('low');
            } else {
                $battery.classList.remove('low');
            }
        }

        // ─── Game flow ───
        function showScreen(el) {
            el.classList.remove('hidden');
        }
        function hideScreen(el) {
            el.classList.add('hidden');
        }

        function loseGame() {
            if (!gameRunning) return;
            gameRunning = false;
            document.exitPointerLock();
            $hud.style.display = 'none';
            $crosshair.style.display = 'none';
            $vignette.style.display = 'none';
            showScreen($gameOver);
        }

        function winGame() {
            if (!gameRunning) return;
            gameRunning = false;
            document.exitPointerLock();
            $hud.style.display = 'none';
            $crosshair.style.display = 'none';
            $vignette.style.display = 'none';
            showScreen($win);
        }

        function startGame() {
            hideScreen($start);
            showScreen($loading);
            initAudio();

            setTimeout(() => {
                if (!scene) {
                    initScene();
                    setupInput();
                }

                // Reset scene objects: remove old maze, exit, maniac
                if (exitLight) { scene.remove(exitLight); exitLight = null; }
                // Remove old exit marker if any
                scene.traverse(obj => {
                    if (obj.isMesh && obj.material === exitMarkerMat) {
                        scene.remove(obj);
                    }
                });

                generateMaze();
                buildMaze();
                buildExit();

                if (!maniacGroup) {
                    buildManiac();
                }

                buildFlashlight();

                // Reset player
                camera.position.set(1.5 * CELL, EYE_HEIGHT, 1.5 * CELL);
                yaw = 0;
                pitch = 0;
                player.stamina = 100;
                player.battery = 100;
                player.flashlightOn = true;
                flashlight.visible = true;
                footstepTimer = 0;
                heartbeatTimer = 0;
                breathTimer = 0;

                // Reset maniac — place far from player, near middle of maze
                const mStartR = MAZE_H - 4;
                const mStartC = MAZE_W - 4;
                maniac.pos.set(mStartC * CELL + CELL / 2, 0, mStartR * CELL + CELL / 2);
                maniac.chasing = false;
                maniac.patrolTarget = null;
                maniacGroup.position.set(maniac.pos.x, 0, maniac.pos.z);

                // Show game UI
                hideScreen($loading);
                hideScreen($gameOver);
                hideScreen($win);
                $hud.style.display = 'block';
                $crosshair.style.display = 'block';
                $vignette.style.display = 'block';
                $blood.style.opacity = '0';

                gameRunning = true;
                clock.start();
                renderer.domElement.requestPointerLock();
                animate();
            }, 600);
        }

        // ─── Game loop ───
        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.05); // cap delta

            updatePlayer(dt);
            updateManiac(dt);
            updateHUD();

            // Pulse exit
            const t = Date.now() * 0.004;
            exitLight.intensity = 8 + Math.sin(t) * 3;
            exitMarkerMat.emissiveIntensity = 0.8 + Math.sin(t) * 0.4;

            renderer.render(scene, camera);
        }

        // ─── Button handlers ───
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('playAgainBtn').addEventListener('click', startGame);
    })();
    </script>
</body>
</html>
